[
  {
    "title": "1 - ¿Qué es Angular? - Herramientas necesarias",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=1&codigo=1&inicio=0",
    "content": "Angular es un framework para el desarrollo de aplicaciones web. Está pensado para dividir un proyecto en componentes y ser reutilizadas en proyectos medianos y grandes.\nSus principales competidores son Vue (proyecto iniciado por Evan You en 2014) \ny React ( proyecto iniciado por Facebook en 2013)\n\nLa última versión (19) introducida a fines de 2024 presenta cambios muy importantes con las 16 versiones anteriores, a tal punto que ha creado un nuevo sitio web para empezar desde cero (sitio presentado a fines de 2023 con la versión 17):\nAngular Dev\n\nLa versión anterior de \nAngular tiene su salida al mercado en 2016 pero además tiene una versión previa no compatible y solo mantenida para proyectos antiguos llamada Angular.js (2010) \nSi tiene que trabajar con proyectos legacy puede tal vez tener la necesidad de ver el \ntutorial de Angular previo a la versión 17\n\nEl proyecto de Angular es propiedad de la empresa de Google.\nLa versión de Angular que trabajamos en este tutorial es la 19 (salió el 19/11/2024)\n\nPara desarrollar en forma efectiva una aplicación en Angular debemos instalar al menos dos herramientas básicas:\n\n\nNode.js\n\n\nAngular CLI (Command Line Interface - Interfaz de línea de comandos)\n\n\n\nInstalación de Node.js\n\nLa primer herramienta a instalar será Node.js, esto debido a que gran cantidad de programas para el desarrollo en Angular están implementadas en Node.\nDebemos Descargar e instalar la última versión estable de Node.js:\n\n\nUna vez instalado debemos ingresar a la línea de comandos que nos provee Nodo.js:\n\nPara comprobar su correcto funcionamiento podemos averiguar su versión:\n\n\nInstalación de Angular CLI\nPara instalar este software lo hacemos desde la misma línea de comandos de Node.js (por eso lo instalamos primero), debemos ejecutar el siguiente comando:\nnpm install -g @angular/cli\n\n\nEs importante el -g para que se instale en forma global."
  },
  {
    "title": "2 - Creación de un proyecto y prueba de su funcionamiento",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=2&codigo=2&inicio=0",
    "content": "Para crear un proyecto vamos a utilizar la aplicación Angular CLI que acabamos de instalar en el concepto anterior.\nDesde la línea de comandos de Node.js procedemos a ejecutar el siguiente comando:\nng new proyecto001\n\nSeleccionaremos que utilizaremos archivos CSS para los estilos (valor seleccionado por defecto), presionamos la tecla \"entrada\":\n\nSeguidamente nos consulta si queremos generar \"Server-Side Rendering (SSR) and Static Site Generation (SSG/Prerendering)\", por el momento dejamos por defecto que No (es una característica agregada a Angular a partir de la versión 17):\n\nEl comando \"ng new\" crea la carpeta proyecto001 e instala una gran cantidad de herramientas que nos auxiliarán durante el desarrollo del proyecto (255 MB). Como Angular esta pensado para aplicaciones de complejidad media o alta no hay posibilidad de instalar menos herramientas.\nEl proceso de generar el proyecto lleva bastante tiempo ya que deben descargarse de internet muchas herramientas.\nSe genera una aplicación con el esqueleto mínimo, para probarlo podemos abrir el Visual Studio Code y debemos ir a la carpeta que se acaba de crear y lanzar el siguiente comando:\nng serve -o\n\n\nEste comando arranca un servidor web en forma local y abre el navegador para la ejecución de la aplicación.\nEn el navegador tenemos como resultado:\n\n\nEn este concepto no me interesa ver todos las carpetas y archivos generados. Solo efectuaremos un cambio para ver como se reflejan en el navegador.\nEn la carpeta 'proyecto001' hay una subcarpeta llamada 'src' y dentro de esta una llamada 'app', busquemos el archivo 'app.component.html' y procedamos a borrar todo menos la etiqueta <router-outlet />.\nSi leemos las primeras líneas nos informa que siempre debemos modificar el archivo con los algoritmos de nuestro proyecto (se genera a modo de ejemplo):\n\n\nDisponemos el siguiente código remplazando al generado en forma automática:\n<h1 style=\"text-align:center\">\n  Bienvenido a {{ title }}\n</h1>\n<router-outlet />\n\nUna vez que grabamos los cambios en este archivo podemos ver que automáticamente se ven reflejados en el navegador (recordemos de no cerrar la consola del Visual Studio Code donde ejecutamos el comando \"ng serve -o\"):\n\nA partir del próximo concepto comenzaremos a analizar un proyecto Angular, en este momento me interesa solo recordar los pasos que debemos dar para crear y ejecutar un proyecto."
  },
  {
    "title": "3 - Archivos y carpetas básicas de un proyecto en Angular",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=3&codigo=3&inicio=0",
    "content": "Vimos en el concepto anterior que para crear un proyecto en Angular utilizamos la herramienta Angular CLI y desde la línea de comandos escribimos:\nng new proyecto001\n\nNo haremos por el momento un estudio exhaustivo de todos los archivos y carpetas que se crean (más 25.900 archivos y 3300 carpetas en la versión de Angular 19.x), sino de aquellas que se requieren modificar según el concepto que estemos estudiando.\nEn Angular la pieza fundamental es la 'COMPONENTE'. Debemos pensar siempre que una aplicación se construye a base de un conjunto de componentes (por ejemplo pueden ser componentes: un menú, lista de usuarios, login, tabla de datos, calendario, formulario de búsqueda etc.)\nAngular CLI nos crea una única componente llamada 'AppComponent' que se distribuye en 4 archivos:\napp.component.ts\napp.component.html\napp.component.css\napp.component.spec.ts\n\nTodos estos archivos se localizan en la carpeta 'app' y esta carpeta se encuentra dentro de la carpeta 'src':\n\nEn Angular se programa utilizando el lenguaje TypeScript que vamos a ir aprendiéndolo a lo largo del curso. El archivo donde se declara la clase AppComponent es 'app.component.ts':\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  title = 'proyecto001';\n}\n\nLa Clase AppComponent define un atributo llamado 'title' y lo inicializa con el string 'proyecto001' que coincide con el nombre del proyecto que creamos:\n  title = 'proyecto001';\n\nDijimos anteriormente que la clase completa se distribuye en otros archivos y podemos ver que mediante la función decoradora @Component le indicamos los otros archivos que pertenecen a esta componente:\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\n\nEl archivo 'app.component.html' tiene la parte visual de nuestra componente 'AppComponent' y está constituido mayormente por código HTML (cada vez que realicemos un proyecto a este código lo borraremos para resolver nuestro problema, salvo la etiqueta <router-outlet />):\n<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->\n<!-- * * * * * * * * * * * The content below * * * * * * * * * * * -->\n<!-- * * * * * * * * * * is only a placeholder * * * * * * * * * * -->\n<!-- * * * * * * * * * * and can be replaced.  * * * * * * * * * * -->\n<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->\n<!-- * * * * * * * * * Delete the template below * * * * * * * * * -->\n<!-- * * * * * * * to get started with your project! * * * * * * * -->\n<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->\n\n<style>\n  :host {\n    --bright-blue: oklch(51.01% 0.274 263.83);\n    --electric-violet: oklch(53.18% 0.28 296.97);\n    --french-violet: oklch(47.66% 0.246 305.88);\n    --vivid-pink: oklch(69.02% 0.277 332.77);\n    --hot-red: oklch(61.42% 0.238 15.34);\n    --orange-red: oklch(63.32% 0.24 31.68);\n\n    --gray-900: oklch(19.37% 0.006 300.98);\n    --gray-700: oklch(36.98% 0.014 302.71);\n    --gray-400: oklch(70.9% 0.015 304.04);\n\n    --red-to-pink-to-purple-vertical-gradient: linear-gradient(\n      180deg,\n      var(--orange-red) 0%,\n      var(--vivid-pink) 50%,\n      var(--electric-violet) 100%\n    );\n\n    --red-to-pink-to-purple-horizontal-gradient: linear-gradient(\n      90deg,\n      var(--orange-red) 0%,\n      var(--vivid-pink) 50%,\n      var(--electric-violet) 100%\n    );\n\n    --pill-accent: var(--bright-blue);\n\n    font-family: \"Inter\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto,\n      Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\",\n      \"Segoe UI Symbol\";\n    box-sizing: border-box;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  h1 {\n    font-size: 3.125rem;\n    color: var(--gray-900);\n    font-weight: 500;\n    line-height: 100%;\n    letter-spacing: -0.125rem;\n    margin: 0;\n    font-family: \"Inter Tight\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto,\n      Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\",\n      \"Segoe UI Symbol\";\n  }\n\n  p {\n    margin: 0;\n    color: var(--gray-700);\n  }\n\n  main {\n    width: 100%;\n    min-height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    padding: 1rem;\n    box-sizing: inherit;\n    position: relative;\n  }\n\n  .angular-logo {\n    max-width: 9.2rem;\n  }\n\n  .content {\n    display: flex;\n    justify-content: space-around;\n    width: 100%;\n    max-width: 700px;\n    margin-bottom: 3rem;\n  }\n\n  .content h1 {\n    margin-top: 1.75rem;\n  }\n\n  .content p {\n    margin-top: 1.5rem;\n  }\n\n  .divider {\n    width: 1px;\n    background: var(--red-to-pink-to-purple-vertical-gradient);\n    margin-inline: 0.5rem;\n  }\n\n  .pill-group {\n    display: flex;\n    flex-direction: column;\n    align-items: start;\n    flex-wrap: wrap;\n    gap: 1.25rem;\n  }\n\n  .pill {\n    display: flex;\n    align-items: center;\n    --pill-accent: var(--bright-blue);\n    background: color-mix(in srgb, var(--pill-accent) 5%, transparent);\n    color: var(--pill-accent);\n    padding-inline: 0.75rem;\n    padding-block: 0.375rem;\n    border-radius: 2.75rem;\n    border: 0;\n    transition: background 0.3s ease;\n    font-family: var(--inter-font);\n    font-size: 0.875rem;\n    font-style: normal;\n    font-weight: 500;\n    line-height: 1.4rem;\n    letter-spacing: -0.00875rem;\n    text-decoration: none;\n  }\n\n  .pill:hover {\n    background: color-mix(in srgb, var(--pill-accent) 15%, transparent);\n  }\n\n  .pill-group .pill:nth-child(6n + 1) {\n    --pill-accent: var(--bright-blue);\n  }\n  .pill-group .pill:nth-child(6n + 2) {\n    --pill-accent: var(--french-violet);\n  }\n  .pill-group .pill:nth-child(6n + 3),\n  .pill-group .pill:nth-child(6n + 4),\n  .pill-group .pill:nth-child(6n + 5) {\n    --pill-accent: var(--hot-red);\n  }\n\n  .pill-group svg {\n    margin-inline-start: 0.25rem;\n  }\n\n  .social-links {\n    display: flex;\n    align-items: center;\n    gap: 0.73rem;\n    margin-top: 1.5rem;\n  }\n\n  .social-links path {\n    transition: fill 0.3s ease;\n    fill: var(--gray-400);\n  }\n\n  .social-links a:hover svg path {\n    fill: var(--gray-900);\n  }\n\n  @media screen and (max-width: 650px) {\n    .content {\n      flex-direction: column;\n      width: max-content;\n    }\n\n    .divider {\n      height: 1px;\n      width: 100%;\n      background: var(--red-to-pink-to-purple-horizontal-gradient);\n      margin-block: 1.5rem;\n    }\n  }\n</style>\n\n<main class=\"main\">\n  <div class=\"content\">\n    <div class=\"left-side\">\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        viewBox=\"0 0 982 239\"\n        fill=\"none\"\n        class=\"angular-logo\"\n      >\n        <g clip-path=\"url(#a)\">\n          <path\n            fill=\"url(#b)\"\n            d=\"M388.676 191.625h30.849L363.31 31.828h-35.758l-56.215 159.797h30.848l13.174-39.356h60.061l13.256 39.356Zm-65.461-62.675 21.602-64.311h1.227l21.602 64.311h-44.431Zm126.831-7.527v70.202h-28.23V71.839h27.002v20.374h1.392c2.782-6.71 7.2-12.028 13.255-15.956 6.056-3.927 13.584-5.89 22.503-5.89 8.264 0 15.465 1.8 21.684 5.318 6.137 3.518 10.964 8.673 14.319 15.382 3.437 6.71 5.074 14.81 4.992 24.383v76.175h-28.23v-71.92c0-8.019-2.046-14.237-6.219-18.819-4.173-4.5-9.819-6.791-17.102-6.791-4.91 0-9.328 1.063-13.174 3.272-3.846 2.128-6.792 5.237-9.001 9.328-2.046 4.009-3.191 8.918-3.191 14.728ZM589.233 239c-10.147 0-18.82-1.391-26.103-4.091-7.282-2.7-13.092-6.382-17.511-10.964-4.418-4.582-7.528-9.655-9.164-15.219l25.448-6.136c1.145 2.372 2.782 4.663 4.991 6.954 2.209 2.291 5.155 4.255 8.837 5.81 3.683 1.554 8.428 2.291 14.074 2.291 8.019 0 14.647-1.964 19.884-5.81 5.237-3.845 7.856-10.227 7.856-19.064v-22.665h-1.391c-1.473 2.946-3.601 5.892-6.383 9.001-2.782 3.109-6.464 5.645-10.965 7.691-4.582 2.046-10.228 3.109-17.101 3.109-9.165 0-17.511-2.209-25.039-6.545-7.446-4.337-13.42-10.883-17.757-19.474-4.418-8.673-6.628-19.473-6.628-32.565 0-13.091 2.21-24.301 6.628-33.383 4.419-9.082 10.311-15.955 17.839-20.7 7.528-4.746 15.874-7.037 25.039-7.037 7.037 0 12.846 1.145 17.347 3.518 4.582 2.373 8.182 5.236 10.883 8.51 2.7 3.272 4.746 6.382 6.137 9.327h1.554v-19.8h27.821v121.749c0 10.228-2.454 18.737-7.364 25.447-4.91 6.709-11.538 11.7-20.048 15.055-8.509 3.355-18.165 4.991-28.884 4.991Zm.245-71.266c5.974 0 11.047-1.473 15.302-4.337 4.173-2.945 7.446-7.118 9.573-12.519 2.21-5.482 3.274-12.027 3.274-19.637 0-7.609-1.064-14.155-3.274-19.8-2.127-5.646-5.318-10.064-9.491-13.255-4.174-3.11-9.329-4.746-15.384-4.746s-11.537 1.636-15.792 4.91c-4.173 3.272-7.365 7.772-9.492 13.418-2.128 5.727-3.191 12.191-3.191 19.392 0 7.2 1.063 13.745 3.273 19.228 2.127 5.482 5.318 9.736 9.573 12.764 4.174 3.027 9.41 4.582 15.629 4.582Zm141.56-26.51V71.839h28.23v119.786h-27.412v-21.273h-1.227c-2.7 6.709-7.119 12.191-13.338 16.446-6.137 4.255-13.747 6.382-22.748 6.382-7.855 0-14.81-1.718-20.783-5.237-5.974-3.518-10.72-8.591-14.075-15.382-3.355-6.709-5.073-14.891-5.073-24.464V71.839h28.312v71.921c0 7.609 2.046 13.664 6.219 18.083 4.173 4.5 9.655 6.709 16.365 6.709 4.173 0 8.183-.982 12.111-3.028 3.927-2.045 7.118-5.072 9.655-9.082 2.537-4.091 3.764-9.164 3.764-15.218Zm65.707-109.395v159.796h-28.23V31.828h28.23Zm44.841 162.169c-7.61 0-14.402-1.391-20.457-4.091-6.055-2.7-10.883-6.791-14.32-12.109-3.518-5.319-5.237-11.946-5.237-19.801 0-6.791 1.228-12.355 3.765-16.773 2.536-4.419 5.891-7.937 10.228-10.637 4.337-2.618 9.164-4.664 14.647-6.055 5.4-1.391 11.046-2.373 16.856-3.027 7.037-.737 12.683-1.391 17.102-1.964 4.337-.573 7.528-1.555 9.574-2.782 1.963-1.309 3.027-3.273 3.027-5.973v-.491c0-5.891-1.718-10.391-5.237-13.664-3.518-3.191-8.51-4.828-15.056-4.828-6.955 0-12.356 1.473-16.447 4.5-4.009 3.028-6.71 6.546-8.183 10.719l-26.348-3.764c2.046-7.282 5.483-13.336 10.31-18.328 4.746-4.909 10.638-8.59 17.511-11.045 6.955-2.455 14.565-3.682 22.912-3.682 5.809 0 11.537.654 17.265 2.045s10.965 3.6 15.711 6.71c4.746 3.109 8.51 7.282 11.455 12.6 2.864 5.318 4.337 11.946 4.337 19.883v80.184h-27.166v-16.446h-.9c-1.719 3.355-4.092 6.464-7.201 9.328-3.109 2.864-6.955 5.237-11.619 6.955-4.828 1.718-10.229 2.536-16.529 2.536Zm7.364-20.701c5.646 0 10.556-1.145 14.729-3.354 4.173-2.291 7.364-5.237 9.655-9.001 2.292-3.763 3.355-7.854 3.355-12.273v-14.155c-.9.737-2.373 1.391-4.5 2.046-2.128.654-4.419 1.145-7.037 1.636-2.619.491-5.155.9-7.692 1.227-2.537.328-4.746.655-6.628.901-4.173.572-8.019 1.472-11.292 2.781-3.355 1.31-5.973 3.11-7.855 5.401-1.964 2.291-2.864 5.318-2.864 8.918 0 5.237 1.882 9.164 5.728 11.782 3.682 2.782 8.51 4.091 14.401 4.091Zm64.643 18.328V71.839h27.412v19.965h1.227c2.21-6.955 5.974-12.274 11.292-16.038 5.319-3.763 11.456-5.645 18.329-5.645 1.555 0 3.355.082 5.237.163 1.964.164 3.601.328 4.91.573v25.938c-1.227-.41-3.109-.819-5.646-1.146a58.814 58.814 0 0 0-7.446-.49c-5.155 0-9.738 1.145-13.829 3.354-4.091 2.209-7.282 5.236-9.655 9.164-2.373 3.927-3.519 8.427-3.519 13.5v70.448h-28.312ZM222.077 39.192l-8.019 125.923L137.387 0l84.69 39.192Zm-53.105 162.825-57.933 33.056-57.934-33.056 11.783-28.556h92.301l11.783 28.556ZM111.039 62.675l30.357 73.803H80.681l30.358-73.803ZM7.937 165.115 0 39.192 84.69 0 7.937 165.115Z\"\n          />\n          <path\n            fill=\"url(#c)\"\n            d=\"M388.676 191.625h30.849L363.31 31.828h-35.758l-56.215 159.797h30.848l13.174-39.356h60.061l13.256 39.356Zm-65.461-62.675 21.602-64.311h1.227l21.602 64.311h-44.431Zm126.831-7.527v70.202h-28.23V71.839h27.002v20.374h1.392c2.782-6.71 7.2-12.028 13.255-15.956 6.056-3.927 13.584-5.89 22.503-5.89 8.264 0 15.465 1.8 21.684 5.318 6.137 3.518 10.964 8.673 14.319 15.382 3.437 6.71 5.074 14.81 4.992 24.383v76.175h-28.23v-71.92c0-8.019-2.046-14.237-6.219-18.819-4.173-4.5-9.819-6.791-17.102-6.791-4.91 0-9.328 1.063-13.174 3.272-3.846 2.128-6.792 5.237-9.001 9.328-2.046 4.009-3.191 8.918-3.191 14.728ZM589.233 239c-10.147 0-18.82-1.391-26.103-4.091-7.282-2.7-13.092-6.382-17.511-10.964-4.418-4.582-7.528-9.655-9.164-15.219l25.448-6.136c1.145 2.372 2.782 4.663 4.991 6.954 2.209 2.291 5.155 4.255 8.837 5.81 3.683 1.554 8.428 2.291 14.074 2.291 8.019 0 14.647-1.964 19.884-5.81 5.237-3.845 7.856-10.227 7.856-19.064v-22.665h-1.391c-1.473 2.946-3.601 5.892-6.383 9.001-2.782 3.109-6.464 5.645-10.965 7.691-4.582 2.046-10.228 3.109-17.101 3.109-9.165 0-17.511-2.209-25.039-6.545-7.446-4.337-13.42-10.883-17.757-19.474-4.418-8.673-6.628-19.473-6.628-32.565 0-13.091 2.21-24.301 6.628-33.383 4.419-9.082 10.311-15.955 17.839-20.7 7.528-4.746 15.874-7.037 25.039-7.037 7.037 0 12.846 1.145 17.347 3.518 4.582 2.373 8.182 5.236 10.883 8.51 2.7 3.272 4.746 6.382 6.137 9.327h1.554v-19.8h27.821v121.749c0 10.228-2.454 18.737-7.364 25.447-4.91 6.709-11.538 11.7-20.048 15.055-8.509 3.355-18.165 4.991-28.884 4.991Zm.245-71.266c5.974 0 11.047-1.473 15.302-4.337 4.173-2.945 7.446-7.118 9.573-12.519 2.21-5.482 3.274-12.027 3.274-19.637 0-7.609-1.064-14.155-3.274-19.8-2.127-5.646-5.318-10.064-9.491-13.255-4.174-3.11-9.329-4.746-15.384-4.746s-11.537 1.636-15.792 4.91c-4.173 3.272-7.365 7.772-9.492 13.418-2.128 5.727-3.191 12.191-3.191 19.392 0 7.2 1.063 13.745 3.273 19.228 2.127 5.482 5.318 9.736 9.573 12.764 4.174 3.027 9.41 4.582 15.629 4.582Zm141.56-26.51V71.839h28.23v119.786h-27.412v-21.273h-1.227c-2.7 6.709-7.119 12.191-13.338 16.446-6.137 4.255-13.747 6.382-22.748 6.382-7.855 0-14.81-1.718-20.783-5.237-5.974-3.518-10.72-8.591-14.075-15.382-3.355-6.709-5.073-14.891-5.073-24.464V71.839h28.312v71.921c0 7.609 2.046 13.664 6.219 18.083 4.173 4.5 9.655 6.709 16.365 6.709 4.173 0 8.183-.982 12.111-3.028 3.927-2.045 7.118-5.072 9.655-9.082 2.537-4.091 3.764-9.164 3.764-15.218Zm65.707-109.395v159.796h-28.23V31.828h28.23Zm44.841 162.169c-7.61 0-14.402-1.391-20.457-4.091-6.055-2.7-10.883-6.791-14.32-12.109-3.518-5.319-5.237-11.946-5.237-19.801 0-6.791 1.228-12.355 3.765-16.773 2.536-4.419 5.891-7.937 10.228-10.637 4.337-2.618 9.164-4.664 14.647-6.055 5.4-1.391 11.046-2.373 16.856-3.027 7.037-.737 12.683-1.391 17.102-1.964 4.337-.573 7.528-1.555 9.574-2.782 1.963-1.309 3.027-3.273 3.027-5.973v-.491c0-5.891-1.718-10.391-5.237-13.664-3.518-3.191-8.51-4.828-15.056-4.828-6.955 0-12.356 1.473-16.447 4.5-4.009 3.028-6.71 6.546-8.183 10.719l-26.348-3.764c2.046-7.282 5.483-13.336 10.31-18.328 4.746-4.909 10.638-8.59 17.511-11.045 6.955-2.455 14.565-3.682 22.912-3.682 5.809 0 11.537.654 17.265 2.045s10.965 3.6 15.711 6.71c4.746 3.109 8.51 7.282 11.455 12.6 2.864 5.318 4.337 11.946 4.337 19.883v80.184h-27.166v-16.446h-.9c-1.719 3.355-4.092 6.464-7.201 9.328-3.109 2.864-6.955 5.237-11.619 6.955-4.828 1.718-10.229 2.536-16.529 2.536Zm7.364-20.701c5.646 0 10.556-1.145 14.729-3.354 4.173-2.291 7.364-5.237 9.655-9.001 2.292-3.763 3.355-7.854 3.355-12.273v-14.155c-.9.737-2.373 1.391-4.5 2.046-2.128.654-4.419 1.145-7.037 1.636-2.619.491-5.155.9-7.692 1.227-2.537.328-4.746.655-6.628.901-4.173.572-8.019 1.472-11.292 2.781-3.355 1.31-5.973 3.11-7.855 5.401-1.964 2.291-2.864 5.318-2.864 8.918 0 5.237 1.882 9.164 5.728 11.782 3.682 2.782 8.51 4.091 14.401 4.091Zm64.643 18.328V71.839h27.412v19.965h1.227c2.21-6.955 5.974-12.274 11.292-16.038 5.319-3.763 11.456-5.645 18.329-5.645 1.555 0 3.355.082 5.237.163 1.964.164 3.601.328 4.91.573v25.938c-1.227-.41-3.109-.819-5.646-1.146a58.814 58.814 0 0 0-7.446-.49c-5.155 0-9.738 1.145-13.829 3.354-4.091 2.209-7.282 5.236-9.655 9.164-2.373 3.927-3.519 8.427-3.519 13.5v70.448h-28.312ZM222.077 39.192l-8.019 125.923L137.387 0l84.69 39.192Zm-53.105 162.825-57.933 33.056-57.934-33.056 11.783-28.556h92.301l11.783 28.556ZM111.039 62.675l30.357 73.803H80.681l30.358-73.803ZM7.937 165.115 0 39.192 84.69 0 7.937 165.115Z\"\n          />\n        </g>\n        <defs>\n          <radialGradient\n            id=\"c\"\n            cx=\"0\"\n            cy=\"0\"\n            r=\"1\"\n            gradientTransform=\"rotate(118.122 171.182 60.81) scale(205.794)\"\n            gradientUnits=\"userSpaceOnUse\"\n          >\n            <stop stop-color=\"#FF41F8\" />\n            <stop offset=\".707\" stop-color=\"#FF41F8\" stop-opacity=\".5\" />\n            <stop offset=\"1\" stop-color=\"#FF41F8\" stop-opacity=\"0\" />\n          </radialGradient>\n          <linearGradient\n            id=\"b\"\n            x1=\"0\"\n            x2=\"982\"\n            y1=\"192\"\n            y2=\"192\"\n            gradientUnits=\"userSpaceOnUse\"\n          >\n            <stop stop-color=\"#F0060B\" />\n            <stop offset=\"0\" stop-color=\"#F0070C\" />\n            <stop offset=\".526\" stop-color=\"#CC26D5\" />\n            <stop offset=\"1\" stop-color=\"#7702FF\" />\n          </linearGradient>\n          <clipPath id=\"a\"><path fill=\"#fff\" d=\"M0 0h982v239H0z\" /></clipPath>\n        </defs>\n      </svg>\n      <h1>Hello, {{ title }}</h1>\n      <p>Congratulations! Your app is running. ????</p>\n   </div>\n    <div class=\"divider\" role=\"separator\" aria-label=\"Divider\"></div>\n    <div class=\"right-side\">\n      <div class=\"pill-group\">\n        @for (item of [\n          { title: 'Explore the Docs', link: 'https://angular.dev' },\n          { title: 'Learn with Tutorials', link: 'https://angular.dev/tutorials' },\n          { title: 'CLI Docs', link: 'https://angular.dev/tools/cli' },\n          { title: 'Angular Language Service', link: 'https://angular.dev/tools/language-service' },\n          { title: 'Angular DevTools', link: 'https://angular.dev/tools/devtools' },\n        ]; track item.title) {\n          <a\n            class=\"pill\"\n            href=\"{{ item.link }}\"\n            target=\"_blank\"\n            rel=\"noopener\"\n          >\n            <span>{{ item.title }}</span>\n            <svg\n              xmlns=\"http://www.w3.org/2000/svg\"\n              height=\"14\"\n              viewBox=\"0 -960 960 960\"\n              width=\"14\"\n              fill=\"currentColor\"\n            >\n              <path\n                d=\"M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h560v-280h80v280q0 33-23.5 56.5T760-120H200Zm188-212-56-56 372-372H560v-80h280v280h-80v-144L388-332Z\"\n              />\n            </svg>\n          </a>\n        }\n      </div>\n      <div class=\"social-links\">\n        <a\n          href=\"https://github.com/angular/angular\"\n          aria-label=\"Github\"\n          target=\"_blank\"\n          rel=\"noopener\"\n        >\n          <svg\n            width=\"25\"\n            height=\"24\"\n            viewBox=\"0 0 25 24\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            alt=\"Github\"\n          >\n            <path\n              d=\"M12.3047 0C5.50634 0 0 5.50942 0 12.3047C0 17.7423 3.52529 22.3535 8.41332 23.9787C9.02856 24.0946 9.25414 23.7142 9.25414 23.3871C9.25414 23.0949 9.24389 22.3207 9.23876 21.2953C5.81601 22.0377 5.09414 19.6444 5.09414 19.6444C4.53427 18.2243 3.72524 17.8449 3.72524 17.8449C2.61064 17.082 3.81137 17.0973 3.81137 17.0973C5.04697 17.1835 5.69604 18.3647 5.69604 18.3647C6.79321 20.2463 8.57636 19.7029 9.27978 19.3881C9.39052 18.5924 9.70736 18.0499 10.0591 17.7423C7.32641 17.4347 4.45429 16.3765 4.45429 11.6618C4.45429 10.3185 4.9311 9.22133 5.72065 8.36C5.58222 8.04931 5.16694 6.79833 5.82831 5.10337C5.82831 5.10337 6.85883 4.77319 9.2121 6.36459C10.1965 6.09082 11.2424 5.95546 12.2883 5.94931C13.3342 5.95546 14.3801 6.09082 15.3644 6.36459C17.7023 4.77319 18.7328 5.10337 18.7328 5.10337C19.3942 6.79833 18.9789 8.04931 18.8559 8.36C19.6403 9.22133 20.1171 10.3185 20.1171 11.6618C20.1171 16.3888 17.2409 17.4296 14.5031 17.7321C14.9338 18.1012 15.3337 18.8559 15.3337 20.0084C15.3337 21.6552 15.3183 22.978 15.3183 23.3779C15.3183 23.7009 15.5336 24.0854 16.1642 23.9623C21.0871 22.3484 24.6094 17.7341 24.6094 12.3047C24.6094 5.50942 19.0999 0 12.3047 0Z\"\n            />\n          </svg>\n        </a>\n        <a\n          href=\"https://twitter.com/angular\"\n          aria-label=\"Twitter\"\n          target=\"_blank\"\n          rel=\"noopener\"\n        >\n          <svg\n            width=\"25\"\n            height=\"20\"\n            viewBox=\"0 0 25 20\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            alt=\"Twitter\"\n          >\n            <path\n              d=\"M8.04524 20C17.3335 20 22.4138 12.3047 22.4138 5.63144C22.4138 5.41287 22.4138 5.19529 22.399 4.97869C23.3874 4.26381 24.2405 3.37867 24.9185 2.3647C23.9969 2.77329 23.0192 3.04112 22.018 3.15923C23.0723 2.52818 23.8613 1.53552 24.2382 0.366057C23.2469 0.954335 22.1624 1.36889 21.0315 1.59182C20.2701 0.782212 19.2631 0.246107 18.1663 0.0664704C17.0695 -0.113166 15.9441 0.0736804 14.9642 0.598096C13.9843 1.12251 13.2046 1.95526 12.7457 2.96748C12.2868 3.9797 12.1742 5.11495 12.4255 6.19756C10.4178 6.09685 8.45366 5.57507 6.66064 4.66609C4.86763 3.75712 3.28579 2.48127 2.01781 0.921344C1.37203 2.03306 1.17424 3.34911 1.46472 4.60154C1.75519 5.85397 2.51208 6.9486 3.58128 7.66257C2.77759 7.63903 1.9914 7.42221 1.28924 7.03049V7.09449C1.28956 8.26041 1.69316 9.39034 2.4316 10.2926C3.17003 11.1949 4.19783 11.8139 5.34067 12.0448C4.59721 12.2476 3.81715 12.2772 3.06045 12.1315C3.38327 13.1348 4.01156 14.0122 4.85746 14.641C5.70337 15.2698 6.72461 15.6185 7.77842 15.6384C6.73139 16.4614 5.53237 17.0699 4.24995 17.4291C2.96753 17.7882 1.62687 17.891 0.304688 17.7316C2.61411 19.2136 5.30121 19.9997 8.04524 19.9961\"\n            />\n          </svg>\n        </a>\n        <a\n          href=\"https://www.youtube.com/channel/UCbn1OgGei-DV7aSRo_HaAiw\"\n          aria-label=\"Youtube\"\n          target=\"_blank\"\n          rel=\"noopener\"\n        >\n          <svg\n            width=\"29\"\n            height=\"20\"\n            viewBox=\"0 0 29 20\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            alt=\"Youtube\"\n          >\n            <path\n              fill-rule=\"evenodd\"\n              clip-rule=\"evenodd\"\n              d=\"M27.4896 1.52422C27.9301 1.96749 28.2463 2.51866 28.4068 3.12258C29.0004 5.35161 29.0004 10 29.0004 10C29.0004 10 29.0004 14.6484 28.4068 16.8774C28.2463 17.4813 27.9301 18.0325 27.4896 18.4758C27.0492 18.9191 26.5 19.2389 25.8972 19.4032C23.6778 20 14.8068 20 14.8068 20C14.8068 20 5.93586 20 3.71651 19.4032C3.11363 19.2389 2.56449 18.9191 2.12405 18.4758C1.68361 18.0325 1.36732 17.4813 1.20683 16.8774C0.613281 14.6484 0.613281 10 0.613281 10C0.613281 10 0.613281 5.35161 1.20683 3.12258C1.36732 2.51866 1.68361 1.96749 2.12405 1.52422C2.56449 1.08095 3.11363 0.76113 3.71651 0.596774C5.93586 0 14.8068 0 14.8068 0C14.8068 0 23.6778 0 25.8972 0.596774C26.5 0.76113 27.0492 1.08095 27.4896 1.52422ZM19.3229 10L11.9036 5.77905V14.221L19.3229 10Z\"\n            />\n          </svg>\n        </a>\n      </div>\n    </div>\n  </div>\n</main>\n\n<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->\n<!-- * * * * * * * * * * * The content above * * * * * * * * * * * * -->\n<!-- * * * * * * * * * * is only a placeholder * * * * * * * * * * * -->\n<!-- * * * * * * * * * * and can be replaced.  * * * * * * * * * * * -->\n<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->\n<!-- * * * * * * * * * * End of Placeholder  * * * * * * * * * * * * -->\n<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->\n\n\n<router-outlet />\n\n\n\nAnalizaremos ahora de este trozo de HTML donde aparece el atributo 'title' de la componente:\n<h1>Hello, {{ title }}</h1>\n\nCuando ejecutamos nuestra aplicación desde la línea de comandos de Node.js:\n\nEn el navegador aparece el contenido de la propiedad 'title':\n\nPodemos ver que aparece el string 'proyecto001' y no {{ title }}:\n  title = 'proyecto001';\n\nEste concepto de sustitución se llama interpolación y lo veremos en forma más profunda en el concepto siguiente.\nOtro archivo que se asocia a la componente 'AppComponent' es 'app.component.css' donde se almacenan todos los estilos que se van a aplicar solo a dicha componente, es decir que quedarán encapsulados en la componente 'AppComponent'.\nEn la carpeta src del proyecto hay un archivo llamado 'styles.css' donde podemos definir estilos que se aplicarán en forma global a todas las componentes de nuestra aplicación:\n\n\nYa hemos nombrado los tres archivos fundamentales que definen toda componente:\napp.component.ts\napp.component.html\napp.component.css\n\nQueda uno llamado 'app.component.spec.ts' que tiene por objetivo definir código de testing para medir el correcto funcionamiento de la componente (dejaremos para más adelante este concepto)\n\nPodemos acotar que en versiones anteriores a la 17 de Angular se creaba un archivo fundamental de módulos, pero ahora podemos crear aplicaciones sin la obligatoriedad de insertarlos en módulos.\n\nHay muchos más archivos y carpetas en el proyecto que nos crea Angular CLI pero iremos viendo su objetivo a medida que avancemos en el curso."
  },
  {
    "title": "4 - Interpolación en los archivos HTML de Angular",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=4&codigo=4&inicio=0",
    "content": "Una de las características fundamentales en Angular es separar la vista del modelo de datos. En el modelo de datos tenemos las variables y en la vista implementamos como se muestran dichos datos.\nModificaremos el proyecto001 para ver este concepto de interpolación.\nAbriremos el archivo que tiene la clase AppComponent (app.component.ts) y lo modificaremos con el siguiente código:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  nombre = 'Rodriguez Pablo';\n  edad = 40;\n  email = 'rpablo@gmail.com';\n  sueldos = [1700, 1600, 1900];\n  activo = true;\n\n  esActivo() {\n    if (this.activo)\n      return 'Trabajador Activo';\n    else\n      return 'Trabajador Inactivo';\n  }\n\n  ultimos3Sueldos() {\n    let suma = 0;\n    for (let x = 0; x < this.sueldos.length; x++)\n      suma += this.sueldos[x];\n    return suma;\n  }\n}\n\nLa clase 'AppComponent' representa los datos de un empleado. Definimos e inicializamos 5 propiedades:\n  nombre = 'Rodriguez Pablo';\n  edad = 40;\n  email = 'rpablo@gmail.com';\n  sueldos = [1700, 1600, 1900];\n  activo = true;\n\nDefinimos dos métodos, en el primero según el valor que almacena la propiedad 'activo' retornamos un string que informa si es un empleado activo o inactivo:\n  esActivo() {\n    if (this.activo)\n      return 'Trabajador Activo';\n    else\n      return 'Trabajador Inactivo';\n  }\n\nEl segundo método retorna la suma de sus últimos 3 meses de trabajo que se almacenan en la propiedad 'sueldos':\n  ultimos3Sueldos() {\n    let suma=0;\n    for(let x=0; x<this.sueldos.length; x++)\n      suma+=this.sueldos[x];\n    return suma;\n  }\n\n\nVeamos ahora el archivo html que muestra los datos, esto se encuentra en 'app.component.html':\n<div>\n  <p>Nombre del Empleado:{{nombre}}</p>\n  <p>Edad:{{edad}}</p>  \n  <p>Los últimos tres sueldos son: {{sueldos[0]}}, {{sueldos[1]}} y {{sueldos[2]}}</p>\n  <p>En los últimos 3 meses ha ganado: {{ultimos3Sueldos()}}</p>\n  <p>{{esActivo()}}</p>\n</div>\n<router-outlet />\n\nPara acceder a las propiedades del objeto dentro del template del HTML debemos disponer dos llaves abiertas y cerradas y dentro el nombre de la propiedad:\n  <p>Nombre del Empleado:{{nombre}}</p>\n\nCuando se tratan de vectores la primer forma que podemos acceder es mediante un subíndice:\n  <p>Los últimos tres sueldos son: {{sueldos[0]}}, {{sueldos[1]}} y {{sueldos[2]}}</p>\n\nFinalmente podemos llamar a métodos que tiene por objetivo consultar el valor de propiedades:\n  <p>En los últimos 3 meses ha ganado: {{ultimos3Sueldos()}}</p>\n  <p>{{esActivo()}}</p>\n\n\nCuando ejecutamos nuestra aplicación desde la línea de comandos de Node.js:\n\nEn el navegador aparece el contenido de la vista pero con los valores sustituidos donde dispusimos las llaves {{}}:\n\n\nEn principio podríamos decir que si los datos son siempre los mismos no tiene sentido definir propiedades en la clase y sustituirlos luego en el HTML, pero luego veremos que las propiedades las vamos a cargar mediante una petición a un servidor web, en esas circunstancias veremos la potencia que tiene modificar las propiedades y luego en forma inmediata se modifica la vista.\n\nAcotaciones\n\n\nDentro de las dos llaves abiertas y cerradas Angular nos permite efectuar una operación:\n<p>En los últimos 3 meses ha ganado: {{sueldos[0]+sueldos[1]+sueldos[2]}}</p>  \n\nPrimero se opera la expresión dispuesta dentro de las llaves previo a mostrarla.\nOtro ejemplo:\n<p>El empleado dentro de 5 años tendrá:{{edad+5}}</p>\n\n\n\nPodemos utilizar la interpolación como valor en propiedades de elementos HTML. Si en la clase tenemos definida la propiedad:\nsitio='http://www.google.com';\n\nLuego en la vista podemos interpolar la propiedad 'url' del elemento 'a' con la siguiente sintaxis:\n<p>Puede visitar el sitio ingresando <a href=\"{{sitio}}\">aquí</a></p>"
  },
  {
    "title": "5 - Sintaxis de Template para estructuras condicionales y repetitivas: @if / @else - @for - @switch/@case/@default",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=5&codigo=5&inicio=0",
    "content": "Angular usa @if para expresar visualizaciones condicionales en plantillas.\nLa plantilla o template @if nos permiten condicionar si se deben agregar o no bloques de código.\nLa plantilla @for nos permite generar muchos elementos HTML repetidos a partir del recorrido de un arreglo de datos.\nPara analizar con un ejemplo estas plantillas procederemos nuevamente a modificar el proyecto001.\nEn el archivo 'app.component.ts' procedemos a codificar la clase AppComponent con la definición de:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  nombre = 'Rodriguez Pablo';\n\n  edad = 40;\n\n  articulos = [{\n    codigo: 1,\n    descripcion: 'naranjas',\n    precio: 540\n  }, {\n    codigo: 2,\n    descripcion: 'manzanas',\n    precio: 900\n  }, {\n    codigo: 3,\n    descripcion: 'peras',\n    precio: 490\n  }];\n\n  generarNumero() {\n    return Math.floor(Math.random() * 3) + 1;\n  }\n}\n\nHemos definido las propiedades nombre, edad y articulos:\n  nombre = 'Rodriguez Pablo';\n\n  edad = 40;\n\n  articulos = [{\n    codigo: 1,\n    descripcion: 'naranjas',\n    precio: 540\n  },{\n    codigo: 2,\n    descripcion: 'manzanas',\n    precio: 900\n  },{\n    codigo: 3,\n    descripcion: 'peras',\n    precio: 490\n  }];\n\nPor otro lado un método que retorna un valor aleatorio comprendido entre 1 y 3:\n  generarNumero() {\n    return Math.floor(Math.random() * 3) + 1;\n  }\n\n\nAhora procedemos a modificar el archivo app.component.html:\n<div>\n  <h1>Empleado</h1>\n  <p>Nombre del Empleado:{{nombre}}</p>\n  <p>Edad:{{edad}}</p>\n  @if (edad>=18) {\n  <p>Es mayor de edad.</p>\n  } @else {\n  <p>Es menor de edad.</p>\n  }\n  <h1>Listado de articulos</h1>\n  <table>\n    @for(articulo of articulos; track articulo.codigo) {\n    <tr>\n      <td>{{articulo.codigo}}</td>\n      <td>{{articulo.descripcion}}</td>\n      <td>{{articulo.precio}}</td>\n    </tr>\n    }\n  </table>\n  <h1>Numero aleatorio entre 1 y 3</h1>\n  @switch (generarNumero()) {\n    @case (1) {\n      <p>Uno</p>\n    }\n    @case (2) {\n      <p>Dos</p>\n    }\n    @case (3) {\n      <p>Tres</p>\n    }\n  }\n</div>\n<router-outlet />\n\n\n\nEjecutemos nuestra aplicación desde la línea de comandos de Node.js:\n\nEn el navegador aparece el siguiente contenido:\n\nLa instrucción @if verifica la condición, en el caso de verificarse verdadero se inserta el bloque contenido entre las llaves:\n  @if (edad>=18) {\n  <p>Es mayor de edad.</p>\n  } @else {\n  <p>Es menor de edad.</p>\n  }\n\nLuego si la condición se verifica falsa se ejecuta el bloque definido en el @else. Podemos probar cambiando la edad por un valor menor a 18.\n\nLa instrucción @for nos genera posiblemente muchos elementos HTML repetidos, en este ejemplo una serie de filas de una tabla HTML:\n    @for(articulo of articulos; track articulo.codigo) {\n    <tr>\n      <td>{{articulo.codigo}}</td>\n      <td>{{articulo.descripcion}}</td>\n      <td>{{articulo.precio}}</td>\n    </tr>\n    }\n\nEn cada repetición en la variable 'articulo' se almacena un objeto del arreglo 'articulos'. De esta forma podemos mostrar los datos del objeto respectivo.\nEs importante agregar la sentencia track al @for indicando un valor único en cada vuelta del @for (es común utilizar un id o clave)\n\nPor último también disponemos la instrucción @switch donde llamamos al método 'generarNumero' y según el valor retornado entrará en el @case respectivo:\n  @switch (generarNumero()) {\n    @case (1) {\n      <p>Uno</p>\n    }\n    @case (2) {\n      <p>Dos</p>\n    }\n    @case (3) {\n      <p>Tres</p>\n    }\n  }"
  },
  {
    "title": "6 - Captura de eventos",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=6&codigo=6&inicio=0",
    "content": "Otra actividad muy común en una aplicación es la captura de eventos. La presión de un botón, la presión de una tecla, el desplazamiento de la flecha del mouse etc. son eventos que podemos capturar.\nEl evento más común que podemos encontrar en cualquier aplicación es la presión de un botón. Modificaremos nuevamente el proyecto001 para que la componente AppComponent muestre un etiqueta con un número 0 y luego dos botones que permitan incrementar o decrementar en uno el contenido de la etiqueta.\nNuevamente debemos modificar el archivo 'app.component.ts' con el siguiente código:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  contador = 1;\n\n  incrementar() {\n    this.contador++;\n  }\n\n  decrementar() {\n    this.contador--;\n  }\n}\n\nDefinimos en la clase la propiedad 'contador' y lo iniciamos con el valor '1':\nexport class AppComponent {\n  contador = 1;\n\nLuego otros dos métodos de la clase AppComponent, que serán llamados al presionar alguno de los botones, incrementan en uno o decrementan en uno el valor almacenado en la propiedad contador:\n  incrementar() {\n    this.contador++;\n  }\n\n  decrementar() {\n    this.contador--;\n  }\n\nRecordar que las propiedades dentro de los métodos debemos anteceder la palabra clave 'this'\n\nEl segundo archivo donde se encuentra la vista de la componente es app.component.html:\n<div>\n  <p>{{contador}}</p>\n  <button (click)=\"incrementar()\">Sumar 1</button>\n  <button (click)=\"decrementar()\">Restar 1</button>\n</div>\n<router-outlet />\n\nComo ya conocemos mostramos el contenido de la propiedad contador mediante interpolación de string:\n  <p>{{contador}}</p>\n\nLuego definimos dos elementos HTML de tipo 'button' y definimos los eventos click (deben ir entre paréntesis los nombres de los eventos) y luego entre comillas el nombre del método que se llama:\n  <button (click)=\"incrementar()\">Sumar 1</button>\n  <button (click)=\"decrementar()\">Restar 1</button>\n\n\nEjecutemos nuestra aplicación desde la línea de comandos de Node.js:\n\nEn el navegador aparece la siguiente interfaz:\n\nCuando se presiona el botón 'Sumar 1' se llama el método 'incrementar()', en dicho método si recordamos se modifica el contenido de la propiedad 'contador':\n  incrementar() {\n    this.contador++;\n  }\n\nLo más importante notar que Angular detecta cuando se modifican valores almacenados en propiedades y automáticamente se encarga de actualizar la interfaz visual sin tener que llamar a algún método.\nEste concepto se conoce como 'binding' en una dirección (cambio en atributos de la clase se actualizan en la vista)"
  },
  {
    "title": "7 - Enlace de propiedades (Property Binding)",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=7&codigo=7&inicio=0",
    "content": "El property binding es una herramienta poderosa en Angular que nos permite mantener sincronizadas las propiedades de una componente con las propiedades de elementos del DOM, facilitando así la creación de aplicaciones dinámicas e interactivas.\nVimos que para la captura de eventos en los elementos HTML disponemos entre paréntesis el evento y asociamos un método, para el enlace de propiedades debemos disponer entre corchetes el nombre de la propiedad y le asignamos un atributo definido en la clase.\n\nModifiquemos nuevamente el archivo 'app.component.ts' con el siguiente código:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  nombre = ''\n\n  fijarNombre1() {\n    this.nombre = 'Juan';\n  }\n\n  fijarNombre2() {\n    this.nombre = 'Ana';\n  }\n}\n\nDefinimos un atributo llamado nombre, el cual se modifica en dos métodos.\n\nEl segundo archivo donde se encuentra la vista de la componente y donde definimos el property binding es app.component.html:\n<div>\n  <input type=\"button\" (click)=\"fijarNombre1()\" value=\"Juan\">\n  <input type=\"button\" (click)=\"fijarNombre2()\" value=\"Ana\">\n</div>\n<input type=\"text\" [value]=\"nombre\">\n<router-outlet />\n\nDebemos disponer entre corchetes el nombre de la propiedad y asignarle el nombre del atributo definido en la clase:\n<input type=\"text\" [value]=\"nombre\">\n\nCuando el operador presione cualquiera de los dos botones, al modificarse el atributo \"nombre\" en la clase, automáticamente se actualiza la vista con el valor asignado al atributo.\nSi ejecutamos la aplicación y presionamos el primer botón:\n\nTener cuidado con la importancia de los corchetes que envuelven la propiedad:\n<input type=\"text\" [value]=\"nombre\">\n\nSi no disponemos los corchetes, recordemos que el navegador va a mostrar la cadena \"nombre\" dentro del control de entrada de datos:\n<input type=\"text\" value=\"nombre\">\n\nY tenemos como resultado en la página:"
  },
  {
    "title": "8 - Componentes: creación",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=8&codigo=8&inicio=0",
    "content": "Hasta ahora hemos desarrollado toda la lógica en la componente que se crea por defecto al crear un proyecto con Angular CLI.\nLa realidad es que en proyectos de mediano y gran tamaño no podemos disponer toda la lógica en una única componente.\nLas componentes son una de las características fundamentales de Angular. Ayudan a extender las características básicas de las etiquetas HTML y encapsular código.\nPara crear otras componentes la herramienta Angular CLI nos provee la posibilidad de crearlas desde la línea de comandos de Node.js\nProblema\nImplementar una aplicación que muestre tres dados. Crear una componente 'dado' además de la componente que crea por defecto Angular CLI\nSeguir los siguientes pasos para implementar el proyecto002:\n\n\n\nDesde la línea de comandos de Node.js o terminal de VS Code procedemos a crear el segundo proyecto (cuidado de crearlo desde la carpeta c:\\angujardevya\\):\n\nc:\\angujardevya>ng new proyecto002\n\n\n\n\nPrimero descendemos a la carpeta proyecto002 y nuevamente desde la línea de comandos procedemos a crear la componente 'dado' escribiendo:\nc:\\angularya> cd proyecto002\nc:\\angularya\\proyecto002> ng generate component dado\n\nAl ejecutar este comando se crean 4 archivos:\n\n\nAhora desde el VSCode ya podemos activar la carpeta donde se encuentra creado el segundo proyecto:\n\n\nAhora podemos comprobar que dentro de la carpeta 'app' se crea una carpeta llamada 'dado' y dentro de ella se localizan los cuatro archivos creados:\n\n\n\n\nEn nuestro tercer paso vamos a implementar la vista de la componente 'dado' y su modelo. Abrimos el archivo 'dado.component.ts' y codificamos:\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-dado',\n  imports: [],\n  templateUrl: './dado.component.html',\n  styleUrl: './dado.component.css'\n})\nexport class DadoComponent {\n  valor: number = Math.floor(Math.random() * 6) + 1;\n}\n\nLa propiedad valor se inicializa con un valor aleatorio comprendido entre 1 y 6.\n\n\n\nCodificamos ahora el archivo 'dado.component.html':\n<div class=\"forma\">\n  {{valor}}\n</div>\n\nComo podemos ver solo mostramos el valor almacenado en la propiedad 'valor' definido en el modelo.\n\n\n\nPara definir la hoja de estilo del 'dado' abrimos el archivo 'dado.component.css' y codificamos:\n.forma {\n  width: 5rem;  \n  height: 5rem;\n  font-size: 3rem;\n  color:white;\n  background-color: black;\n  border-radius: 1rem;\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  margin:10px;\n}\n\n\n\n\nFinamente nos falta definir tres objetos de nuestra clase 'DadoComponent', si volvemos a ver el archivo 'dado.component.ts' podemos identificar en la llamada a @Component que tiene una propiedad llamada 'selector' con el valor 'app-dado':\n\n@Component({\n  selector: 'app-dado',\n  imports: [],\n  templateUrl: './dado.component.html',\n  styleUrl: './dado.component.css'\n})\n\nEste es el selector que debemos utilizar para definir objetos de la clase DadoComponent en las vistas.\nAbrimos ahora el archivo 'app.component.html' y remplazamos su contenido con la definición de tres dados:\n<div style=\"text-align:center\">\n  <app-dado></app-dado>\n  <app-dado></app-dado>\n  <app-dado></app-dado>  \n</div>\n\n<router-outlet />\n\n\n\nTodavía podemos ver que nos muestra un error como que no existe la etiqueta 'app-dado', esto debido que la debemos importar a la clase en el archivo 'app.component.ts'.\nDebemos importar la clase e indicar que la utilizaremos:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { DadoComponent } from './dado/dado.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, DadoComponent],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  title = 'proyecto002';\n}\n\nEs decir que importamos la componente del dado:\nimport { DadoComponent } from './dado/dado.component';\n\n\nY también indicamos el nombre de la clase en la propiedad 'imports':\nimports: [RouterOutlet, DadoComponent]\n\n\n\nSi ejecutamos ahora el proyecto:\nng serve -o\n\nPodemos ver que tenemos los tres dados en pantalla:\n\n\n\nEs importante notar la relación de colaboración entre la clase 'DadoComponent' y la clase 'AppComponent':\n\nLa clase AppComponent se crea en forma automática cuando creamos un proyecto en Angular utilizando la herramienta 'Angular CLI'.\n\n\n\nAcotaciones\nLa división de un proyecto en componentes en Angular nos permite crear piezas independientes y reutilizables.\nSiempre debe haber una primer componente donde arranca la aplicación, si utilizamos la herramienta Angular CLI se llama 'AppComponent'. Luego podemos crear otras componentes como en nuestro caso de 'DadoComponent'.\nTenemos que toda componente tiene un nombre de clase, por ejemplo 'DadoComponent' y luego un nombre de selector definida para dicha componente 'app-dado'. En las vistas para definir objetos de una determinada componente debemos hacer referencia al nombre del selector:\n  <app-dado></app-dado>\n\nLa componente 'AppComponent' si vemos su nombre de selector es 'app-root', luego si queremos ver donde se crea un objeto de este tipo de selector debemos abrir el archivo 'index.html' que lo generó automáticamente Angular CLI:\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Proyecto002</title>\n  <base href=\"/\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n</head>\n<body>\n  <app-root></app-root>\n</body>\n</html>\n\nComo podemos ver en el 'body' se define una etiqueta de tipo 'app-root':\n<body>\n  <app-root></app-root>\n</body>\n\nGracias a esto siempre se crea un objeto de la clase AppComponent. Si borramos ésta etiqueta y corremos la aplicación luego tendremos una página web vacía."
  },
  {
    "title": "9 - \tComponentes: pasar datos de la componente padre a la componente hija",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=9&codigo=9&inicio=0",
    "content": "Vimos en el concepto anterior que una aplicación con Angular está conformada por componentes. Siempre hay una componente padre y esta puede tener una o más componentes hijas, a su vez las componentes hijas pueden tener componentes hijas de ellas y así sucesivamente.\nEn este concepto veremos una técnica para pasar datos de la componente padre a la componente hija.\nPodemos pasar datos a una componente en el momento que definimos una etiqueta de la misma:\n<app-dado valor=\"3\"></app-dado>\n\nCuando declaramos la etiqueta app-dado definimos una propiedad llamada 'valor' y le pasamos el dato a dicha componente. Es idéntico a lo que hacemos a cuando definimos etiquetas HTML con sus propiedades.\nProblema\nImplementar una aplicación que muestre tres dados (crear una componente llamada 'dado') y un botón. Cuando se presione el botón generar tres valores aleatorios y pasarlos a las componentes respectivas para que se muestren. La clase principal debe mostrar un mensaje que el usuario ganó si los tres dados tienen el mismo valor.\nRepetiremos los mismos pasos del concepto anterior para practicar la creación de una nueva componente y veremos lo nuevo de recibir datos en la componente creada.\n\n\n\n\nDesde la línea de comandos de Node.js procedemos a crear el proyecto003:\nc:\\angulardevya> ng new proyecto003\n\n\n\n\nPrimero descendemos a la carpeta proyecto003 y nuevamente desde la línea de comandos procedemos a crear la componente 'dado' escribiendo:\nc:\\angulardevya\\proyecto003> ng generate component dado\n\nRecordemos que al ejecutar este comando se crean 4 archivos, todos relacionados a la componente que acabamos de crear.\nAdemás dentro de la carpeta 'app' se crea una carpeta llamada 'dado' y dentro de ella se localizan los cuatro archivos creados.\n\n\n\nEn nuestro tercer paso vamos a implementar la vista de la componente 'dado' y su modelo. Abrimos el archivo 'dado.component.ts' y codificamos:\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-dado',\n  imports: [],\n  templateUrl: './dado.component.html',\n  styleUrl: './dado.component.css'\n})\nexport class DadoComponent {\n  @Input() valor: string = \"\";\n}\n\nEn la clase DadoComponent podemos identificar la sintaxis para definir una propiedad que llega como parámetro de la componente padre:\n  @Input() valor: string=\"\";\n\nAsignamos un string vacío a la propiedad valor y luego se cargará un valor cuando creemos un objeto de esta clase.\nPara definir el decorador @Input() debemos importar la clase Input:\nimport { Component, Input } from '@angular/core';\n\n\n\n\nCodificamos ahora el archivo 'dado.component.html':\n<div class=\"forma\">\n  {{valor}}\n</div>\n\nComo podemos ver solo mostramos el valor almacenado en la propiedad 'valor' definido en el modelo (no hay cambios con el ejemplo anterior)\n\n\n\nPara definir la hoja de estilo del 'dado' abrimos el archivo 'dado.component.css' y codificamos:\n.forma {\n  width: 5rem;  \n  height: 5rem;\n  font-size: 3rem;\n  color:white;\n  background-color: black;\n  border-radius: 1rem;\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  margin:10px;\n}\n\n\n\n\nFinamente nos falta definir tres objetos de nuestra clase 'DadoComponent' y pasar los valores que queremos que se muestren, si volvemos a ver el archivo 'dado.component.ts' podemos identificar en la llamada a @Component que tiene una propiedad llamada 'selector' con el valor 'app-dado':\n\n@Component({\n  selector: 'app-dado',\n  imports: [],\n  templateUrl: './dado.component.html',\n  styleUrl: './dado.component.css'\n})\n\nEste es el selector que debemos utilizar para definir objetos de la clase DadoComponent en las vistas.\nAbrimos ahora el archivo 'app.component.html' y remplazamos su contenido con la definición de tres dados y mediante interpolación pasamos el valor para cada dado:\n<div style=\"text-align:center\">\n  <app-dado valor=\"{{valor1}}\"></app-dado>\n  <app-dado valor=\"{{valor2}}\"></app-dado>\n  <app-dado valor=\"{{valor3}}\"></app-dado>\n  <hr>\n  <button (click)=\"tirar()\">Tirar</button>\n  <hr>\n  <p>Resultado:{{resultado}}</p>\n</div>\n\n<router-outlet />\n\n\n\n\nAhora codificamos la clase AppComponent donde generamos los tres valores aleatorios que mostrarán las componentes, implementamos además el método que captura el click del botón:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { DadoComponent } from './dado/dado.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, DadoComponent],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  valor1: number = this.retornarAleatorio()\n  valor2: number = this.retornarAleatorio()\n  valor3: number = this.retornarAleatorio()\n  resultado: string = \"\";\n\n  retornarAleatorio() {\n    return Math.floor(Math.random() * 6) + 1;\n  }\n\n  tirar() {\n    this.valor1 = this.retornarAleatorio();\n    this.valor2 = this.retornarAleatorio();\n    this.valor3 = this.retornarAleatorio();\n    if (this.valor1 == this.valor2 && this.valor1 == this.valor3)\n      this.resultado = 'Ganó';\n    else\n      this.resultado = 'Perdió';\n  }\n}\n\n\nVeamos las partes importantes de la componente 'AppComponent', primero importamos la clase 'DadoComponent':\nimport { DadoComponent } from './dado/dado.component';\n\nAgregamos a la propiedad imports la referencia a la clase 'DadoComponent':\n  imports: [RouterOutlet, DadoComponent],\n\nDefinimos 4 atributos y los inicializamos a los tres primeros con valores aleatorios y al cuarto con un string vacío:\n  valor1: number = this.retornarAleatorio()\n  valor2: number = this.retornarAleatorio()\n  valor3: number = this.retornarAleatorio()\n  resultado: string=\"\";\n\nEl método tirar, vuelve a generar 3 valores aleatorios para cada dado y según sus valores fija el valor del atributo 'resultado':\n  tirar() {\n    this.valor1 = this.retornarAleatorio();\n    this.valor2 = this.retornarAleatorio();\n    this.valor3 = this.retornarAleatorio();\n    if (this.valor1 == this.valor2 && this.valor1 == this.valor3)\n      this.resultado = 'Ganó';\n    else\n      this.resultado = 'Perdió';\n  }\n\nRecordemos que el archivo HTML mediante interpolación actualiza los valores en forma automática:\n<div style=\"text-align:center\">\n  <app-dado valor=\"{{valor1}}\"></app-dado>\n  <app-dado valor=\"{{valor2}}\"></app-dado>\n  <app-dado valor=\"{{valor3}}\"></app-dado>\n  <hr>\n  <button (click)=\"tirar()\">Tirar</button>\n  <hr>\n  <p>Resultado:{{resultado}}</p>\n</div>\n\n<router-outlet />\n\n\nSi ejecutamos ahora el proyecto:\nng server -o\n\nPodemos ver que tenemos los tres dados en pantalla, el botón de 'tirar' y el mensaje que se actualiza cada vez que jugamos:\n\n\n\n\nAcotaciones\nDependiendo del problema nos conviene definir propiedades privadas a una componente o definir propiedades que lleguen los datos desde la componente padre. En éste problema como tenemos que controlar si los tres dados tienen el mismo valor es más conveniente que el dado tenga solo la responsabilidad de mostrar un valor y que el control de los tres números se debe hacer en la componente principal 'AppComponent'\n\nProperty binding (enlace de propiedades)\nVimos que podemos modificar el valor de un propiedad en el archivo HTML mediante interpolación:\n  <app-dado valor=\"{{valor1}}\"></app-dado>\n  <app-dado valor=\"{{valor2}}\"></app-dado>\n  <app-dado valor=\"{{valor3}}\"></app-dado>\n\nLa segundo forma de resolver el problema en lugar de interpolación es mediante el enlace de propiedades, también llamado 'property binding' que vimos en conceptos previos.\nDebemos encerrar entre corchetes el nombre de la propiedad y luego asignar un atributo definido en el modelo de datos:\n  <app-dado [valor]=\"valor1\"></app-dado>\n  <app-dado [valor]=\"valor2\"></app-dado>\n  <app-dado [valor]=\"valor3\"></app-dado>\n\nCon property binding debemos definir en la componente el tipo de dato number:\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-dado',\n  imports: [],\n  templateUrl: './dado.component.html',\n  styleUrl: './dado.component.css'\n})\nexport class DadoComponent {\n  @Input() valor: number=1;\n}\n\n\nPodemos probar esta aplicación en la web aquí.\n\nA medida que hagamos ejercicios veremos cuando conviene más emplear interpolación o definir property binding."
  },
  {
    "title": "10 - Componentes: disparo de eventos de la componente hija a la componente padre",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=10&codigo=10&inicio=0",
    "content": "En el concepto anterior vimos al final como podemos pasar un dato mediante el 'property binding' (la variable 'valor1' se encuentra definida en la clase):\n<app-dado [valor]=\"valor1\"></app-dado>\n\nAhora veremos como podemos captura un evento en la componente padre que emite la componente hija:\n  <app-cronometro [inicio]=\"15\" (multiplo10)=\"actualizar($event)\"></app-cronometro>\n\nEn esta componente tenemos una propiedad llamada inicio que le enviamos un dato y capturamos un evento llamado 'multiplo10' que emite la componente app-cronometro.\nProblema\nConfeccionar una aplicación con dos componentes llamadas 'AppComponent' y 'CronometroComponent'. La componente 'CronometroComponent' muestra un cronómetro que se actualiza cada un segundo, cada vez que su valor es múltiplo de 10 informa a la componente padre de dicha situación informando el segundo actual.\nLa componente 'AppComponent' define un cronómetro e informa cada vez que el cronómetro tiene un valor múltiplo de 10.\n\n\n\n\n\nDesde la línea de comandos de Node.js procedemos a crear el proyecto004:\nc:\\angulardevya> ng new proyecto004\n\n\n\n\nPrimero descendemos a la carpeta proyecto004 y nuevamente desde la línea de comandos procedemos a crear la componente 'cronometro' escribiendo:\nc:\\angulardevya\\proyecto004> ng generate component cronometro\n\nRecordemos que al ejecutar este comando se crean 4 archivos.\nAdemás dentro de la carpeta 'app' se crea una carpeta llamada 'cronometro' y dentro de ella se localizan los cuatro archivos creados.\n\n\n\nEn nuestro tercer paso vamos a implementar la vista de la componente 'cronometro' y su modelo. Abrimos el archivo 'cronometro.component.ts' y codificamos:\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'app-cronometro',\n  imports: [],\n  templateUrl: './cronometro.component.html',\n  styleUrl: './cronometro.component.css'\n})\nexport class CronometroComponent {\n  segundo = 0;\n  @Input() inicio: number = 0;\n  @Output() multiplo10 = new EventEmitter<number>();\n\n  ngOnInit() {\n    this.segundo = this.inicio;\n    setInterval(() => {\n      this.segundo++;\n      if (this.segundo % 10 == 0)\n        this.multiplo10.emit(this.segundo);\n    }, 1000);\n  }\n}\n\nEn la clase CronometroComponent podemos identificar la sintaxis para definir un evento que dispara un valor de tipo 'number':\n  @Output() multiplo10 = new EventEmitter<number>();\n\nPara definir los decoradores @Input(), @Output() debemos importar:\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\n\nTambién hay que importar la clase EventEmitter.\nAparece algo nuevo que es el método 'ngOnInit' que se ejecuta una vez que se han inicializado todos los atributos. En el mismo,\ninicializamos el atributo 'segundo' con el valor del decorador 'inicio'.\nMediante la función setInterval, especificamos que cada 1 segundo (1000 milisegundos), se ejecute la arrow function donde incrementamos el atributo 'segundo' y si el mismo es múltiplo de 10 procedemos a llamar a la función de la otra clase.\n\n\n\nCodificamos ahora el archivo 'cronometro.component.html':\n<div class=\"cronometro\">\n  {{segundo}} Seg.\n</div>\n\n\n\n\nPara definir la hoja de estilo del 'cronometro' abrimos el archivo 'cronometro.component.css' y codificamos:\n.cronometro {\n  width: 8rem;  \n  height: 3rem;\n  font-size: 2rem;\n  color:white;\n  background-color: black;\n  border-radius: 10px;\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  margin:10px;\n}\n\n\n\n\nAbrimos ahora el archivo 'app.component.html' y remplazamos su contenido con la definición de un cronometro y un mensaje que se muestra mediante interpolación:\n<div style=\"text-align:center\">\n  <h1>Prueba de la componente cronometro</h1>\n  <app-cronometro [inicio]=\"15\" (multiplo10)=\"actualizar($event)\"></app-cronometro>\n  <h2>Evento</h2>\n  <h3>{{mensaje}}</h3>\n</div>\n\n<router-outlet />\n\nEs importante entender la sintaxis del evento 'multiplo10' donde se llama al método actualizar.\nEl $event es una variable especial en Angular que representa el objeto del evento que se está produciendo, en nuestro caso es el valor que se pasa desde el cronómetro del segundo actual:\n        this.multiplo10.emit(this.segundo);\n\n\n\nAhora codificamos la clase AppComponent donde definimos el método que captura el evento emitido por el cronómetro:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { CronometroComponent } from './cronometro/cronometro.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, CronometroComponent],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  mensaje = '';\n\n  actualizar(t: number) {\n    this.mensaje = t + '(se actualiza cada 10 segundos)';\n  }\n}\n\nEl método 'actualizar' se llama cuando se dispara el evento 'multiplo10':\n  <app-cronometro [inicio]=\"15\" (multiplo10)=\"actualizar($event)\"></app-cronometro>\n\nEl parámetro 't' del método recibe el valor de la variable especial de Angular llamada $event.\n\nSi ejecutamos ahora el proyecto:\nng server -o\n\nPodemos ver que cada vez que el cronómetro tiene un valor múltiplo de 10 la componente principal actualiza un mensaje gracias al evento que emite la componente 'cronometro':\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "11 - Componentes: llamar a métodos de la componente hija desde el template del padre",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=11&codigo=11&inicio=0",
    "content": "Otra forma de comunicarnos de la componente padre a la componente hija es la posibilidad de llamar a métodos de la componente hija definiendo una variable en el template HTML donde declaramos la componente hija.\nPara llamar a los métodos la componente debe definir una variable en el template del HTML:\n<app-dado #dado1></app-dado>\n<button (click)=\"dado1.tirar()\">Tirar</button>\n\nPara definir una variable local le antecedemos el caracter # al nombre. Luego podemos llamar a métodos indicando el nombre de la variable y el método a llamar.\nProblema\nCrear una componente llamada 'selectornumerico' que le pasemos el mínimo y el máximo valor que puede mostrar. Dentro de la componente definir dos botones que puedan incrementar o decrementar en 1 el valor actual.\nEn el template HTML de la componente padre definir un selectornumerico y una variable local para poder llamar luego a un método del selectornumerico para fijar cualquier valor.\nLa componente selectornumerico debe ser algo similar a esta interfaz:\n\n\n\n\n\nDesde la línea de comandos de Node.js procedemos a crear el proyecto005:\nc:\\angulardevya> ng new proyecto005\n\n\n\n\nPrimero descendemos a la carpeta proyecto005 y nuevamente desde la línea de comandos procedemos a crear la componente 'selectornumerico' escribiendo:\nc:\\angulardevya\\proyecto005> ng generate component selectornumerico\n\nRecordemos que al ejecutar este comando se crean 4 archivos.\nAdemás dentro de la carpeta 'app' se crea una carpeta llamada 'selectornumerico' y dentro de ella se localizan los cuatro archivos creados.\n\n\n\nEn nuestro tercer paso vamos a implementar la vista de la componente 'selectornumerico' y su modelo. Abrimos el archivo 'selectornumerico.component.ts' y codificamos:\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-selectornumerico',\n  imports: [],\n  templateUrl: './selectornumerico.component.html',\n  styleUrl: './selectornumerico.component.css'\n})\nexport class SelectornumericoComponent {\n  @Input() minimo: number = 1;\n  @Input() maximo: number = 1;\n  actual: number = 1;\n\n  ngOnInit() {\n    this.actual = this.minimo;\n  }\n\n  incrementar() {\n    if (this.actual < this.maximo)\n      this.actual++;\n  }\n\n  decrementar() {\n    if (this.actual > this.minimo)\n      this.actual--;\n  }\n\n  fijar(v: number) {\n    if (v >= this.minimo && v <= this.maximo)\n      this.actual = v;\n  }\n}\n\n\nEn la clase SelectornumericoComponent podemos identificar el método que llamaremos desde el HTML template de la componente AppComponent:\n  fijar(v: number) {\n    if (v >= this.minimo && v <= this.maximo)\n      this.actual = v;\n  }\n\n\n\n\nCodificamos ahora el archivo 'selectornumerico.component.html':\n<div class=\"selector\">\n  <button (click)=\"decrementar()\">-</button>  \n  <div class=\"valor\">{{actual}}</div>\n  <button (click)=\"incrementar()\">+</button>\n</div>\n\n\n\n\nPara definir la hoja de estilo del 'selectornumerico' abrimos el archivo 'selectornumerico.component.css' y codificamos:\n.selector {\n  display:inline-flex;\n  margin:0.2rem;\n}\n.valor {\n  display:inline-flex;\n  justify-content: center;\n  align-items: center;\n  width: 3rem;\n  height: 3rem;\n  background:#ff0;\n  font-size:2rem;  \n}\n\nbutton {\n  height: 3rem;\n}\n\n\n\n\nAbrimos ahora el archivo 'app.component.html' y remplazamos su contenido con la definición de un selectornumerico que define una variable local y tres botones que llaman a partir de esa variable al método definido dentro del selectornumerico:\n<div>\n  <app-selectornumerico [minimo]=\"1\" [maximo]=\"10\" #selector1></app-selectornumerico>\n  <br>\n  <button (click)=\"selector1.fijar(1)\">Fijar en 1</button><br>\n  <button (click)=\"selector1.fijar(5)\">Fijar en 5</button><br>\n  <button (click)=\"selector1.fijar(10)\">Fijar en 10</button>\n</div>\n\n<router-outlet />\n\n\n\n\nEn la clase AppComponent nos queda importar la clase 'SelectornumericoComponent' que se encuentra en el archivo 'selectornumerico.component':\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { SelectornumericoComponent } from './selectornumerico/selectornumerico.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, SelectornumericoComponent],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n}\n\n\nSi ejecutamos ahora el proyecto:\nng server -o\n\n\nEs decir que mediante dos botones definidos en la componente AppComponent podemos llamar al método fijar de la clase SelectornumericoComponent gracias a que definimos la variable #selector1:\n  <app-selectornumerico [minimo]=\"1\" [maximo]=\"10\"  #selector1></app-selectornumerico>\n  <br>\n  <button (click)=\"selector1.fijar(1)\">Fijar en 1</button><br>\n  <button (click)=\"selector1.fijar(5)\">Fijar en 5</button><br>\n  <button (click)=\"selector1.fijar(10)\">Fijar en 10</button>\n\n\n\n\nLo que debe quedar claro que debemos definir una variable en la etiqueta que define la componente y a partir de esta podemos llamar a métodos o inclusive acceder a propiedades de la componente.\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "12 - Componentes: llamar a métodos de la componente hija desde la clase padre",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=12&codigo=12&inicio=0",
    "content": "En muchas situaciones podemos resolver un problema definiendo una variable local en el template HTML del padre y mediante ésta llamar a sus métodos.\nSi necesitamos acceder a la componente hija pero desde la clase (es decir el archivo .ts) tenemos un poco mayor de complejidad que pasaremos a ver en este concepto.\n\nProblema\nCrear una componente llamada 'selectornumerico' que le pasemos el mínimo y el máximo valor que puede mostrar. Dentro de la componente definir dos botones que puedan incrementar o decrementar en 1 el valor actual (no modificaremos nada la del ejercicio anterior)\nEn el template HTML de la componente padre definir dos selectores numéricos y tres botones que afectarán a cada selector numérico para fijar los valores 1, 5 y 10.\nLa aplicación completa se debe mostrar con una interfaz similar a:\n\n\n\n\n\n\nDesde la línea de comandos de Node.js procedemos a crear el proyecto006:\nc:\\angulardevya> ng new proyecto006\n\n\n\n\nPrimero descendemos a la carpeta proyecto006 y nuevamente desde la línea de comandos procedemos a crear la componente 'selectornumerico' escribiendo:\nc:\\angulardevya\\proyecto006> ng generate component selectornumerico\n\n\nEn nuestro tercer paso vamos a implementar la vista de la componente 'selectornumerico' y su modelo. Abrimos el archivo 'selectornumerico.component.ts' y codificamos:\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-selectornumerico',\n  imports: [],\n  templateUrl: './selectornumerico.component.html',\n  styleUrl: './selectornumerico.component.css'\n})\nexport class SelectornumericoComponent {\n  @Input() minimo: number = 1;\n  @Input() maximo: number = 1;\n  actual: number = 1;\n\n  ngOnInit() {\n    this.actual = this.minimo;\n  }\n\n  incrementar() {\n    if (this.actual < this.maximo)\n      this.actual++;\n  }\n\n  decrementar() {\n    if (this.actual > this.minimo)\n      this.actual--;\n  }\n\n  fijar(v: number) {\n    if (v >= this.minimo && v <= this.maximo)\n      this.actual = v;\n  }\n}\n\nEn la clase SelectornumericoComponent podemos identificar el método que llamaremos desde la clase AppComponent:\n  fijar(v: number) {\n    if (v >= this.minimo && v <= this.maximo)\n      this.actual = v;\n  }\n\n\n\n\nCodificamos ahora el archivo 'selectornumerico.component.html':\n<div class=\"selector\">\n  <button (click)=\"decrementar()\">-</button>  \n  <div class=\"valor\">{{actual}}</div>\n  <button (click)=\"incrementar()\">+</button>\n</div>\n\n\n\n\nPara definir la hoja de estilo del 'selectornumerico' abrimos el archivo 'selectornumerico.component.css' y codificamos:\n.selector {\n  display:inline-flex;\n  margin:0.2rem;\n}\n.valor {\n  display:inline-flex;\n  justify-content: center;\n  align-items: center;\n  width: 3rem;\n  height: 3rem;\n  background:#ff0;\n  font-size:2rem;  \n}\n\nbutton {\n  height: 3rem;\n}\n\n\n\n\nAbrimos ahora el archivo 'app.component.html' y remplazamos su contenido con la definición de dos selectores numericos que definen una variable local y tres botones para cada uno:\n<div>\n  <app-selectornumerico [minimo]=\"1\" [maximo]=\"10\" #selector1></app-selectornumerico>\n  <br>  \n  <button (click)=\"fijarSelector1(1)\">Fijar en 1</button><br>\n  <button (click)=\"fijarSelector1(5)\">Fijar en 5</button><br>\n  <button (click)=\"fijarSelector1(10)\">Fijar en 10</button>\n  <hr>\n  <app-selectornumerico [minimo]=\"1\" [maximo]=\"10\" #selector2></app-selectornumerico>    \n  <br>\n  <button (click)=\"fijarSelector2(1)\">Fijar en 1</button><br>\n  <button (click)=\"fijarSelector2(5)\">Fijar en 5</button><br>\n  <button (click)=\"fijarSelector2(10)\">Fijar en 10</button>  \n</div>\n\n<router-outlet />\n\n\n\n\nLa clase AppComponent es la que presenta la mayor cantidad de cambios:\nimport { Component, ViewChild } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { SelectornumericoComponent } from './selectornumerico/selectornumerico.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  @ViewChild('selector1') selector1!: SelectornumericoComponent;\n  @ViewChild('selector2') selector2!: SelectornumericoComponent;\n\n  fijarSelector1(valor:number) {\n    this.selector1.fijar(valor);\n  }\n\n  fijarSelector2(valor:number) {\n    this.selector2.fijar(valor);\n  }\n}\n\n\nDebemos definir una propiedad llamada selector1 y mediante el decorador @ViewChild hacemos referencia a la variable definida en el template HTML que también se llama 'selector1':\n  @ViewChild('selector1') selector1!: SelectornumericoComponent;\n\nIndicamos que sabemos que la propiedad no será nula con el operador \"!\" en la declaración de la propiedad. Esto se llama \"assertion\" o \"no nulo\" y le dice al compilador de TypeScript que confíe en nosotros.\nMediante las propiedades selector1 y selector2 tenemos las referencias de las dos componentes hijas, luego podemos llamar a sus métodos o acceder a sus propiedades:\n  fijarSelector1(valor:number) {\n    this.selector1.fijar(valor);\n  }\n\n  fijarSelector2(valor:number) {\n    this.selector2.fijar(valor);\n  }\n\n\n\nSi ejecutamos ahora el proyecto:\nng server -o\n\n\n\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "13 - Formularios : formulario basado en plantillas",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=13&codigo=13&inicio=0",
    "content": "Angular proporciona dos enfoques diferentes para manejar formularios:\n\n\nFormularios basados en plantillas\n\n\nFormularios reactivos\n\n\nAmbos capturan los eventos de entrada del usuario desde la vista, crean un modelo de formulario y un modelo de datos para actualizar y proporcionan una forma de rastrear los cambios.\nLos formularios basados en plantillas son útiles para agregar un formulario simple a una aplicación. Son más fáciles de agregar que los formularios reactivos, pero no escalan tan bien como los formularios reactivos. Si tiene requisitos de formulario y lógica muy básica podemos utilizar sin problemas formularios basados en plantillas.\nVeremos en este concepto como implementar en Angular formularios basados en plantillas.\n\nFormulario reactivo (directiva ngModel)\n\nPor ejemplo si en la clase AppComponent tenemos la propiedad 'nombre' con el valor 'juan':\nnombre='juan';\n\nLuego en la vista definimos la directiva ngModel entre corchetes y le asignamos el nombre de la propiedad definida en la clase:\n  <input type=\"text\" [ngModel]=\"nombre\">\n\nCuando arrancamos la aplicación podemos observar que el control input aparece automáticamente con el valor 'juan':\n\n\nPara utilizar la directiva ngModel debemos importar el módulo 'FormsModule':\n\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [RouterOutlet, FormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  nombre = 'juan';\n}\n\n\n\nLo que hay que tener en cuenta que es un enlace en una única dirección: el valor de la propiedad de la clase se refleja en la interfaz visual. Si el operador cambia el contenido del control 'input' por ejemplo por el nombre 'ana' luego la propiedad 'nombre' de la clase sigue almacenando el valor 'juan'.\nSi queremos que el enlace sea en las dos direcciones debemos utilizar la siguiente sintaxis:\n<input type=\"text\" [(ngModel)]=\"nombre\">\n\n\n\nUn primer ejemplo muy corto que podemos hacer es crear un proyecto (proyecto007) para que se ingrese el nombre y apellido de una persona y se muestre inmediatamente en la parte inferior.\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, FormsModule],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  nombre = '';\n  apellido = '';\n}\n\n\nEl archivo app.component.html donde definimos las directiva ngModel para cada control es:\n<div>\n  <p>Ingrese nombre<input type=\"text\" [(ngModel)]=\"nombre\"></p>\n  <p>Ingrese apellido<input type=\"text\" [(ngModel)]=\"apellido\"></p>  \n  <p>Nombre completo:{{nombre}},{{apellido}}</p>\n</div>\n\n<router-outlet />\n\n\nEjecutemos nuestra aplicación desde la línea de comandos de Node.js.\nEn el navegador nos muestra como se actualizan las propiedades cada vez que ingresamos un caracter en los controles 'input':\n\n\nEs importante entender que hay un enlace en ambas direcciones. Si cambiamos el valor mediante el ingreso de datos por teclado en el control input, luego se ven reflejados en forma automática en las propiedades de la clase. De la misma forma si cambiamos el valor de la propiedad en la clase, luego se refleja en forma automática el valor en el formulario.\nPodemos probar esta aplicación en la web aquí.\n\n\n\n\n\nProblema\nConfeccionar una aplicación que permita administrar un vector de objetos que almacena en cada elemento el código, descripción y precio de un artículo. Se debe poder agregar, borrar y modificar los datos de un artículo.\nLa interfaz visual de la aplicación debe ser similar a esta:\n\nPodemos probar esta aplicación en la web aquí.\n\nCrearemos el proyecto008 para resolver este problema.\n\n\nLo primero que debemos hacer es desde la línea de comandos de Node.js proceder a crear el proyecto008:\nng new proyecto008\n\n\n\n\nPara facilidad por el momento crearemos todo en una única componente, es decir en la que se crea automáticamente al crear el proyecto.\nEn el archivo app.component.css implementamos la hoja de estilo para la tabla HTML:\n/* Estilo para la tabla */\ntable {\n  width: 100%;\n  border-collapse: collapse;\n  margin-bottom: 20px;\n}\n\n/* Estilo para las celdas de encabezado */\nth, td {\n  border: 1px solid #dddddd;\n  padding: 8px;\n  text-align: left;\n}\n\n/* Estilo alternado para filas */\ntr:nth-child(even) {\n  background-color: #f2f2f2;\n}\n\n/* Estilo para el encabezado de la tabla */\nth {\n  background-color: #4CAF50;\n  color: white;\n}\n\n\n\nEn el archivo app.component.html es donde mostramos una tabla HTML y un formulario para ingresar datos:\n<div>\n  <h1>Administración de artículos</h1>\n  @if (hayRegistros()) {\n  <table>\n    <thead>\n      <tr>\n        <th>Codigo</th>\n        <th>Descripcion</th>\n        <th>Precio</th>\n        <th>Borrar</th>\n        <th>Seleccionar</th>\n      </tr>\n    </thead>\n    <tbody>\n      @for(art of articulos; track art.codigo) {\n      <tr>\n        <td>{{art.codigo}}</td>\n        <td>{{art.descripcion}}</td>\n        <td>{{art.precio}}</td>\n        <td><button (click)=\"borrar(art.codigo)\">Borrar?</button></td>\n        <td><button (click)=\"seleccionar(art)\">Seleccionar</button></td>\n      </tr>\n      }\n    </tbody>\n  </table>\n  } @else {\n  <p>No hay articulos.</p>\n  }\n\n  <div>\n    <p>\n      Codigo:<input type=\"number\" [(ngModel)]=\"art.codigo\" />\n    </p>\n    <p>\n      descripcion:<input type=\"text\" [(ngModel)]=\"art.descripcion\" />\n    </p>\n    <p>\n      precio:<input type=\"number\" [(ngModel)]=\"art.precio\" />\n    </p>\n    <p>\n      <button (click)=\"agregar()\">Agregar</button>\n      <button (click)=\"modificar()\">Modificar</button>\n    </p>\n  </div>\n</div>\n\n<router-outlet />\n\n\n\n\nLa clase app.component.ts tenemos:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, FormsModule],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  art = {\n    codigo: 0,\n    descripcion: \"\",\n    precio: 0\n  }\n\n  articulos = [{ codigo: 1, descripcion: 'papas', precio: 10.55 },\n  { codigo: 2, descripcion: 'manzanas', precio: 12.10 },\n  { codigo: 3, descripcion: 'melon', precio: 52.30 },\n  { codigo: 4, descripcion: 'cebollas', precio: 17 },\n  { codigo: 5, descripcion: 'calabaza', precio: 20 },\n  ];\n\n  hayRegistros() {\n    return this.articulos.length > 0;\n  }\n\n  borrar(codigo: number) {\n    for (let x = 0; x < this.articulos.length; x++)\n      if (this.articulos[x].codigo == codigo) {\n        this.articulos.splice(x, 1);\n        return;\n      }\n  }\n\n  agregar() {\n    if (this.art.codigo == 0) {\n      alert('Debe ingresar un código de articulo distinto a cero');\n      return;\n    }\n    for (let x = 0; x < this.articulos.length; x++)\n      if (this.articulos[x].codigo == this.art.codigo) {\n        alert('ya existe un articulo con dicho codigo');\n        return;\n      }\n    this.articulos.push({\n      codigo: this.art.codigo,\n      descripcion: this.art.descripcion,\n      precio: this.art.precio\n    });\n    this.art.codigo = 0;\n    this.art.descripcion = \"\";\n    this.art.precio = 0;\n  }\n\n  seleccionar(art: { codigo: number; descripcion: string; precio: number; }) {\n    this.art.codigo = art.codigo;\n    this.art.descripcion = art.descripcion;\n    this.art.precio = art.precio;\n  }\n\n  modificar() {\n    for (let x = 0; x < this.articulos.length; x++)\n      if (this.articulos[x].codigo == this.art.codigo) {\n        this.articulos[x].descripcion = this.art.descripcion;\n        this.articulos[x].precio = this.art.precio;\n        return;\n      }\n    alert('No existe el código de articulo ingresado');\n  }\n}\n\n\n\n\n\nEjecutemos la aplicación desde la ventana de Node.js mediante el comando:\nng serve -o\n\n\n\n\nListado\nPasemos a analizar las distintas partes de nuestra aplicación. Los archivos app.component.ts y app.component.html están totalmente integrados y con objetivos bien definidos cada uno. El archivo '.html' almacena la vista y el archivo '.ts' almacena el modelo de datos.\nDefinimos en el modelo (app.component.ts) un vector de objetos llamado 'articulos' y almacenamos 5 elementos:\n  articulos = [{ codigo: 1, descripcion: 'papas', precio: 10.55 },\n  { codigo: 2, descripcion: 'manzanas', precio: 12.10 },\n  { codigo: 3, descripcion: 'melon', precio: 52.30 },\n  { codigo: 4, descripcion: 'cebollas', precio: 17 },\n  { codigo: 5, descripcion: 'calabaza', precio: 20 },\n  ];\n\nEn la vista (app.component.html) verificamos con un if si el vector tienen elementos:\n  @if (hayRegistros()) {\n\nComo vemos llamamos al método 'hayRegistros()' que se encuentra implementado en el archivo *.ts:\n  hayRegistros() {\n    return this.articulos.length > 0;\n  }\n\nSi retorna true luego generamos una tabla HTML que muestre los datos del modelo y lo recorremos mediante un @for:\n<table>\n    <thead>\n      <tr>\n        <th>Codigo</th>\n        <th>Descripcion</th>\n        <th>Precio</th>\n        <th>Borrar</th>\n        <th>Seleccionar</th>\n      </tr>\n    </thead>\n    <tbody>\n      @for(art of articulos; track art.codigo) {\n      <tr>\n        <td>{{art.codigo}}</td>\n        <td>{{art.descripcion}}</td>\n        <td>{{art.precio}}</td>\n        <td><button (click)=\"borrar(art.codigo)\">Borrar?</button></td>\n        <td><button (click)=\"seleccionar(art)\">Seleccionar</button></td>\n      </tr>\n      }\n    </tbody>\n  </table>\n\n\nDisponemos en cada fila dos botones y definimos sus respectivos eventos 'click' para que al ser presionados llamen a métodos del modelo para borrar o seleccionar el artículo respectivo. Los métodos envían como parámetro el artículo para saber cual borrar o seleccionar.\nEn la vista disponemos una serie de 'input' que nos permiten ingresar el código, descripción y precio de un artículo:\n  <div>\n    <p>\n      Codigo:<input type=\"number\" [(ngModel)]=\"art.codigo\" />\n    </p>\n    <p>\n      descripcion:<input type=\"text\" [(ngModel)]=\"art.descripcion\" />\n    </p>\n    <p>\n      precio:<input type=\"number\" [(ngModel)]=\"art.precio\" />\n    </p>\n    <p>\n      <button (click)=\"agregar()\">Agregar</button>\n      <button (click)=\"modificar()\">Modificar</button>\n    </p>\n  </div>\n\n\n\nAgregado\nPodemos comprobar que los controles HTML tienen la directiva 'ngModel' bidireccional, es decir que cuando el operador carga un dato en el primer 'input' se actualiza automáticamente en el modelo el dato cargado en 'art.codigo':\nPodemos comprobar que en el modelo tenemos definido un objeto llamado art con tres propiedes:\n  art={\n    codigo:0 ,\n    descripcion:\"\",\n    precio:0\n  }\n\n\nAl presionar el botón agregar se ejecuta el método 'agregar':\n  agregar() {\n    if (this.art.codigo == 0) {\n      alert('Debe ingresar un código de articulo distinto a cero');\n      return;\n    }\n    for (let x = 0; x < this.articulos.length; x++)\n      if (this.articulos[x].codigo == this.art.codigo) {\n        alert('ya existe un articulo con dicho codigo');\n        return;\n      }\n    this.articulos.push({\n      codigo: this.art.codigo,\n      descripcion: this.art.descripcion,\n      precio: this.art.precio\n    });\n    this.art.codigo = 0;\n    this.art.descripcion = \"\";\n    this.art.precio = 0;\n  }\n\nEn este método primero recorremos el vector articulos para comprobar si hay algún otro artículo con el mismo código. En el caso que no exista procedemos a añadir un nuevo elemento llamando al método push y pasando un objeto que creamos en dicho momento con los datos almacenados en el objeto 'art' que se encuentra enlazado con el formulario.\nLuego asignamos cero y cadena vacía a todas las propiedades del objeto art con el objetivo de borrar todos los 'input' del formulario.\nAl agregar un elemento al vector 'Angular' se encarga de actualizar la vista sin tener que indicar nada en nuestro código.\n\nBorrado\nCuando se presiona el botón de borrar se ejecuta el método 'borrar':\n  borrar(codigo: number) {\n    for (let x = 0; x < this.articulos.length; x++)\n      if (this.articulos[x].codigo == codigo) {\n        this.articulos.splice(x, 1);\n        return;\n      }\n  }\n\nRecorremos el vector y controlamos uno a uno el código del artículo seleccionado con cada uno de los elementos del vector. El que coincide lo eliminamos del vector llamando al método splice indicando la posición y cuantas componentes borrar a partir de ese.\n\nSelección\nCuando se presiona el botón de seleccionar se ejecuta el método 'seleccionar':\n  seleccionar(art: { codigo: number; descripcion: string; precio: number; }) {\n    this.art.codigo=art.codigo;\n    this.art.descripcion=art.descripcion;\n    this.art.precio=art.precio;\n  }\n\nLo único que hacemos es actualizar el objeto art del modelo con el artículo que acaba de seleccionar el operador (llega como parámetro el artículo seleccionado)\n\nModificación\nCuando presiona el botón de modificación se ejecuta el método:\n  modificar() {\n    for(let x=0;x<this.articulos.length;x++)\n      if (this.articulos[x].codigo==this.art.codigo)\n      {\n        this.articulos[x].descripcion=this.art.descripcion;\n        this.articulos[x].precio=this.art.precio;\n        return;\n      }        \n    alert('No existe el código de articulo ingresado');\n  }\n\nBuscamos el código de articulo del control 'input' dentro del vector, en caso de encontrarlo procedemos a modificar la descripción y precio.\n\nTener en cuenta que por ahora estamos haciendo aplicaciones que almacenan sus datos en forma local y no estamos enviando los mismos a un servidor, luego veremos distintas alternativas de enviar y recuperar datos de un servidor.\n\nRecordar que podemos probar esta aplicación en la web aquí."
  },
  {
    "title": "14 - Formularios reactivos : ReactiveFormsModule, FormControl",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=14&codigo=14&inicio=0",
    "content": "Hemos dicho que Angular proporciona dos enfoques diferentes para manejar formularios:\n\n\nBasado en plantillas (visto en el concepto anterior)\n\n\nReactivos\n\n\nAmbos capturan los eventos de entrada del usuario desde la vista, crean un modelo de formulario y un modelo de datos para actualizar y proporcionan una forma de rastrear los cambios. Hasta ahora nosotros hemos trabajado con el modelo basado en plantillas.\n\nEl enfoque reactivo es más robusto, son más escalables, reutilizables y comprobables. Si los formularios son una parte clave de su aplicación, conviene utilizar el modelo reactivo.\nDiferencias entre ambos modelos\n\n\nLa configuración con el modelo de plantilla se hace mediante directivas y es menos explícito que el modelo reactivo que debe configurarse en la clase mediante código. \n\n\n\nEn el formulario basado en plantillas el modelo de datos es más desestructurado.\n\n\n\n\nEn el formulario basado en plantilla la validación se hace mediante directivas, en cambio en el modelo reactivo se hace mediante funciones.\n\n\n\n\nLas pruebas unitarias son más fácil de implementar en los formularios reactivos. \n\n\n\nManeja cualquier escenario complejo es más fácil implementarlo con formularios reactivos.\n\n\n\n\n\nPara trabajar con formularios reactivos necesitamos importar la clase 'ReactiveFormsModule' y crear un objeto de la clase FormControl por cada control visual que contendrá nuestro formulario.\nNuestro primer problema con formularios reactivos será el más elemental, ya que contendrá un solo control 'input' para el ingreso de una cadena.\n\n\nProblema\nConfeccionar una aplicación que permita ingresar actividades pendientes mediante un control 'input' de tipo 'text'.\nSe deben listar todas las actividades ingresadas hasta el momento, además de poder borrar una en particular o todas a la vez.\nAlmacenar en forma local en el navegador las actividades mediante el API localStorage para evitar que se pierdan las actividades cuando se cierre el navegador.\n\n\nCrearemos primero el proyecto:\nng new proyecto009 \n\n\n\n\n\nTrabajaremos con la componente que generar automáticamente Angular CLI cuando creamos el proyecto, pasamos a modificar la vista (app.component.html):\n<p> Actividad:\n  <input type=\"text\" [formControl]=\"actividad\">\n</p>\n<p><button (click)=\"agregar()\">Agregar</button></p>\n<ol>\n  @for(acti of lista;track $index) {\n  <li>\n    {{acti}} <a (click)=\"borrar($index)\" href=\"#\">Borra?</a>\n  </li>\n  }\n</ol>\n<p><button (click)=\"borrarTodas()\">Borrar todas las actividades</button></p>\n\n<router-outlet />\n\nAnalizaremos este archivo en conjunto luego de presentar 'app.component.ts'\n\n\n\nLa clase asociada a la vista 'app.component.html' es el archivo 'app.component.ts' donde implementamos la siguiente lógica:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ReactiveFormsModule, FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  imports: [ RouterOutlet, ReactiveFormsModule,],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n\n  actividad = new FormControl();\n\n  lista: string[];\n\n  constructor() {\n    this.lista = [];\n    let datos = localStorage.getItem(\"actividades\");\n    if (datos != null) {\n      let arreglo = JSON.parse(datos);\n      if (arreglo != null)\n        for (let actividad of arreglo)\n          this.lista.push(actividad);\n    }\n  }\n\n  agregar() {\n    this.lista.push(this.actividad.value);\n    localStorage.setItem('actividades', JSON.stringify(this.lista));\n    this.actividad.setValue('');\n  }\n\n  borrar(pos: number) {\n    this.lista.splice(pos, 1);\n    localStorage.clear();\n    localStorage.setItem('actividades', JSON.stringify(this.lista));\n  }\n\n  borrarTodas() {\n    localStorage.clear();\n    this.lista = [];\n  }\n}\n\n\n\n\nLo primero que hacemos es importar la clase 'ReactiveFormsModule' y la interface 'FormControl':\nimport { ReactiveFormsModule, FormControl } from '@angular/forms';\n\nDebemos importar en la componente la clase 'ReactiveFormsModule':\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, ReactiveFormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\n\n\nDentro de la clase 'AppComponent' creamos un objeto de tipo 'FormControl' llamado 'actividad' (uno solo ya que solo tenemos un control de entrada de datos):\n  actividad = new FormControl();\n\nEste atributo 'actividad' se asocia con la vista mediante la sintaxis:\n  <input type=\"text\" [formControl]=\"actividad\">\n\nLa cadena que carga el operador en el control visual luego se la puede acceder mediante la propiedad 'value' y si queremos cambiar su contenido disponemos del método 'setValue'.\nEl problema requiere que se almacenen todas las actividades que ingresa el usuario por teclado, esto sucede en el arreglo 'lista'. La definimos dentro de la clase:\n  lista: string[];\n\nCuando el operador presiona el botón de 'Agregar' se llama el método 'agregar' y procedemos a recuperar el dato del control visual mediante la propiedad value y la agregamos al arreglo:\n    this.lista.push(this.actividad.value);    \n\nInmediatamente procedemos a borrar el contenido del control visual llamando al método 'setValue':\n    this.actividad.setValue('');\n\n\nNuestro problema requiere almacenar cada una de las actividades en un arreglo que se pasa a mostrar en la vista mediante la estructura  @for:\n<ol>\n  @for(acti of lista;track $index) {\n  <li>\n    {{acti}} <a (click)=\"borrar($index)\" href=\"#\">Borra?</a>\n  </li>\n  }\n</ol>\n\nDebemos especificar la variable especial $index que se numera de 0 en adelante. Dicho valor se pasa al método borrar: (click)=\"borrar($index)\"\n\n\n\nVimos hasta ahora todo lo relacionado con el control FormControl, pero nuestro problema requiere que la lista de actividades no se borre al cerrar el navegador, para ello utilizamos el API localStorage que proporciona HTML5.\nCuando se presiona el botón 'agregar', luego de guardar la actividad del formulario procedemos a almacenar mediante el método 'setItem' del objeto 'localStorage' los datos de la lista pero en formato JSON:\n  agregar() {\n    this.lista.push(this.actividad.value);    \n    localStorage.setItem('actividades', JSON.stringify(this.lista));\n    this.actividad.setValue('');\n  }\n\nSi se presiona el botón de borrar todas las actividades procedemos por un lado a borrar los elementos del arreglo y además a borrar los datos almacenados en 'localStorage':\n  borrarTodas() {\n    localStorage.clear();\n    this.lista=[];\n  }\n\nOtro punto importante es que cuando se ejecuta el método constructor al cargar la componente, verificamos si hay datos almacenados en el 'localStorage' para leerlos y cargar el arreglo 'lista' con los datos previos de ejecuciones anteriores de la aplicación Angular:\n  constructor() {\n    this.lista = [];\n    let datos = localStorage.getItem(\"actividades\");\n    if (datos != null) {\n      let arreglo = JSON.parse(datos);\n      if (arreglo != null)\n        for (let actividad of arreglo)\n          this.lista.push(actividad);\n    }\n  }\n\n\n\n\nSi ejecutamos la aplicación tenemos una interfaz similar a:\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "15 - Formularios reactivos : FormGroup",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=15&codigo=15&inicio=0",
    "content": "Si tenemos un solo control de entrada de datos podemos como en el concepto anterior definir únicamente un objeto de la clase FormControl, pero un formulario que contiene un conjunto de controles la manera más efectiva es agruparlos definiendo un objeto de tipo FormGroup.\n\n\nProblema\nConfeccionar un formulario de contacto que permita cargar el nombre, mail y un mensaje. Cuando se presiona un botón mostrar mediante interpolación los datos cargados.\n\n\nCrearemos primero el proyecto:\nng new proyecto010\n\n\n\n\n\nModificamos la vista de la componente que muestra el formulario reactivo (app.component.html):\n<form [formGroup]=\"formularioContacto\" (ngSubmit)=\"submit()\">\n  <p>Nombre:\n    <input type=\"text\" formControlName=\"nombre\">\n  </p>\n  <p>Mail:\n    <input type=\"text\" formControlName=\"mail\">\n  </p>\n  <p>Mensaje<br>\n    <textarea rows=\"10\" cols=\"70\" formControlName=\"mensaje\"></textarea>\n  </p>\n  <button type=\"submit\">Confirmar</button>\n</form>\n<div>{{datos}}</div>\n<router-outlet />\n\nAnalizaremos este archivo en conjunto luego de presentar 'app.component.ts'\n\n\n\nLa clase asociada a la vista es (app.component.ts):\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ReactiveFormsModule, FormControl, FormGroup } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, ReactiveFormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  datos='';\n\n  formularioContacto = new FormGroup({\n    nombre: new FormControl(''),\n    mail: new FormControl(''),\n    mensaje: new FormControl('')\n  });\n\n  submit() {\n    this.datos = `Nombre=${this.formularioContacto.value.nombre}\n                Mail=${this.formularioContacto.value.mail}\n                Mensaje=${this.formularioContacto.value.mensaje}\n                `;\n  }\n}\n\nImportamos ahora:\nimport { ReactiveFormsModule, FormControl, FormGroup } from '@angular/forms';\nCreamos un objeto de la clase FormGroup y le pasamos al constructor del mismo un objeto literal con la creación de un objeto de la clase FormControl por cada control visual de la vista:\n  formularioContacto = new FormGroup({\n    nombre: new FormControl(''),\n    mail: new FormControl(''),\n    mensaje: new FormControl('')\n  });\n\nPodemos pasar a cada constructor el valor inicial que tenga el control visual, en nuestro caso hemos pasado string vacíos.\nEn la vista agrupamos todos los controles mediante la etiqueta 'form' y definimos la directiva [formGroup] asignando la variable de tipo FormGroup definida en la clase:\n<form [formGroup]=\"formularioContacto\" (ngSubmit)=\"submit()\">\n\nAsociamos el evento (ngSubmit) con el método de la clase que captura el clic del botón del formulario.\nCada uno de los controles requiere definir la propiedad 'formControlName' con los nombres asignados en la clase cuando creamos cada FormControl:\n  <p>Nombre:\n    <input type=\"text\" formControlName=\"nombre\">\n  </p>\n  <p>Mail:\n    <input type=\"text\" formControlName=\"mail\">\n  </p>\n  <p>Mensaje<br>\n    <textarea rows=\"10\" cols=\"70\" formControlName=\"mensaje\"></textarea>\n  </p>\n\nEl método 'submit' procede a recuperar cada valor ingresado en el formulario y lo almacena en el atributo 'datos':\n  submit() {\n    this.datos=`Nombre=${this.formularioContacto.value.nombre}\n                Mail=${this.formularioContacto.value.mail}\n                Mensaje=${this.formularioContacto.value.mensaje}\n                `;\n\nEl atributo datos se muestra en la vista mediante interpolación:\n<div>{{datos}}</div>\n\n\n\n\n\n\nSi ejecutamos la aplicación tenemos una interfaz similar a:\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "16 - Formularios reactivos : controles checkbox, radio y select",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=16&codigo=16&inicio=0",
    "content": "Vimos en los conceptos anteriores como trabajar con formularios reactivos en Angular, pero siempre utilizando un input de tipo text o un textarea. Ahora veremos como configurar los controles checkbox, radio y select.\n\n\nProblema\nConfeccionar un formulario que permita al usuario ingresar un valor decimal y luego pueda seleccionar:\n\nMediante dos controles radio puede indicar si quiere la conversión a hexadecimal u octal.\nMediante un control select indica si quiere calcular el valor ingresado elevado a la potencia 2, 3 o 4.\nFinalmente con un control checkbox puede indicar que muestre la cantidad de dígitos del valor ingresado.\n\n\n\nCrearemos primero el proyecto:\nng new proyecto011\n\n\n\n\n\nModificamos la vista de la componente que muestra el formulario reactivo (app.component.html):\n<form [formGroup]=\"formularioConversion\" (ngSubmit)=\"submit()\">\n  <p>Ingrese número decimal:\n    <input type=\"text\" formControlName=\"numerodecimal\">\n  </p>\n  <p>Convertir a:<br>\n    <input type=\"radio\" formControlName=\"base\" value=\"octal\">Octal\n    <input type=\"radio\" formControlName=\"base\" value=\"hexadecimal\">Hexadecimal\n  </p>\n  <p>Elevar a:<br>\n    <select formControlName=\"potencia\">\n      <option>2</option>\n      <option>3</option>\n      <option>4</option>\n    </select>\n  </p>  \n  <p><input type=\"checkbox\" formControlName=\"largo\">Mostrar cantidad de dígitos\n  </p>\n  <p><button type=\"submit\">Confirmar</button></p>\n</form>\n<div>\n  <p>Conversion:{{conversion}}</p>\n  <p>Potencia:{{potenciaNumero}}</p>\n  <p>Cantidad de dígitos:{{cantidad}}</p>  \n</div>\n<router-outlet />\n\nAnalizaremos este archivo en conjunto luego de presentar 'app.component.ts'\n\n\n\nLa clase asociada a la vista es (app.component.ts):\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ReactiveFormsModule, FormControl, FormGroup } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, ReactiveFormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  conversion = '';\n  potenciaNumero = '';\n  cantidad = '';\n\n  formularioConversion = new FormGroup({\n    numerodecimal: new FormControl(''),\n    base: new FormControl('octal'),\n    potencia: new FormControl('2'),\n    largo: new FormControl(true)\n  });\n\n  submit() {\n    if (this.formularioConversion.value.numerodecimal) {\n      if (this.formularioConversion.value.base == \"hexadecimal\")\n        this.conversion = parseInt(this.formularioConversion.value.numerodecimal).toString(16);\n      if (this.formularioConversion.value.base == \"octal\")\n        this.conversion = parseInt(this.formularioConversion.value.numerodecimal).toString(8);\n      if (this.formularioConversion.value.numerodecimal && this.formularioConversion.value.potencia)\n        this.potenciaNumero = Math.pow(parseInt(this.formularioConversion.value.numerodecimal), parseInt(this.formularioConversion.value.potencia)).toString();\n      if (this.formularioConversion.value.largo)\n        this.cantidad = this.formularioConversion.value.numerodecimal.length.toString();\n    }\n  }\n\n}\n\n\nCreamos un objeto de la clase FormGroup y le pasamos un objeto literal con la referencia a los 4 controles de formulario que necesitamos:\n  formularioConversion = new FormGroup({\n    numerodecimal: new FormControl(''),\n    base: new FormControl('octal'),\n    potencia: new FormControl('2'),\n    largo: new FormControl(true)\n  });\n\nEl atributo base se asocia a los controles 'radio' de la vista, he indicamos que aparezca seleccionado por defecto aquel que almacena en value el valor 'octal':\n  <p>Convertir a:<br>\n    <input type=\"radio\" formControlName=\"base\" value=\"octal\">Octal\n    <input type=\"radio\" formControlName=\"base\" value=\"hexadecimal\">Hexadecimal\n  </p>\n\nEl control HTML select se asocia al atributo 'potencia', indicando que se muestre seleccionada la opción con valor '2':\n    potencia: new FormControl('2'),\n\nLa vista para este FormControl es:\n  <p>Elevar a:<br>\n    <select formControlName=\"potencia\">\n      <option>2</option>\n      <option>3</option>\n      <option>4</option>\n    </select>\n  </p>  \n\nFinalmente para el control checkbox indicamos que se muestre seleccionado por defecto al cargar el formulario:\n    largo: new FormControl(true)\n\nCuando se presiona el botón se ejecuta el método 'submit', donde efectuamos las distintas operaciones según los valores seleccionados en el formulario:\n  submit() {\n    if (this.formularioConversion.value.numerodecimal) {\n      if (this.formularioConversion.value.base == \"hexadecimal\")\n        this.conversion = parseInt(this.formularioConversion.value.numerodecimal).toString(16);\n      if (this.formularioConversion.value.base == \"octal\")\n        this.conversion = parseInt(this.formularioConversion.value.numerodecimal).toString(8);\n      if (this.formularioConversion.value.numerodecimal && this.formularioConversion.value.potencia)\n        this.potenciaNumero = Math.pow(parseInt(this.formularioConversion.value.numerodecimal), parseInt(this.formularioConversion.value.potencia)).toString();\n      if (this.formularioConversion.value.largo)\n        this.cantidad = this.formularioConversion.value.numerodecimal.length.toString();\n    }\n  }\n\n\n\n\n\n\n\n\n\nSi ejecutamos la aplicación tenemos una interfaz similar a:\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "17 - Formularios reactivos : FormGroup anidados",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=17&codigo=17&inicio=0",
    "content": "Cuando trabajamos con formularios reactivos en Angular normalmente creamos un FormGroup para agrupar los controles visuales que se les asocian un objeto de la clase FormControl a cada uno.\nPodemos crear dentro de un FormGroup otro FormGroup que agrupe un conjunto de controles relacionados.\n\n\nProblema\nConfeccionar un formulario que permita cargar los siguientes datos de un alumno: dni, nombre, materia y sus tres notas. Agrupar las tres notas dentro de un FormGroup anidado al principal.\nAl presionar un botón mostrar un mensaje si se encuentra aprobado (todas las notas mayores o iguales a 4)\n\n\n\nCrearemos primero el proyecto:\nng new proyecto012\n\n\n\n\n\nModificamos la vista de la componente que muestra el formulario reactivo (app.component.html):\n<form [formGroup]=\"formAlumno\" (ngSubmit)=\"submit()\">\n  <p>Dni:\n    <input type=\"text\" formControlName=\"dni\">\n  </p>\n  <p>Nombre:\n    <input type=\"text\" formControlName=\"nombre\">\n  </p>\n  <div formGroupName=\"notas\">\n    <p>Primer nota:\n      <input type=\"text\" formControlName=\"nota1\">\n    </p>\n    <p>Segunda nota:\n      <input type=\"text\" formControlName=\"nota2\">\n    </p>\n    <p>Tercer nota:\n      <input type=\"text\" formControlName=\"nota3\">\n    </p>\n  </div>\n  <p><button type=\"submit\">Confirmar</button></p>\n</form>\n<div>\n  <p>Resultado:{{resultado}}</p>\n</div>\n<router-outlet />\n\nAnalizaremos este archivo en conjunto luego de presentar 'app.component.ts'\n\n\n\nLa clase asociada a la vista es (app.component.ts):\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ReactiveFormsModule, FormControl, FormGroup } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, ReactiveFormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  resultado = '';\n\n  formAlumno = new FormGroup({\n    dni: new FormControl(''),\n    nombre: new FormControl(''),\n    notas: new FormGroup({\n      nota1: new FormControl(''),\n      nota2: new FormControl(''),\n      nota3: new FormControl('')\n    })\n  });\n\n  submit() {\n    if (this.formAlumno.value.notas) {\n      if (this.formAlumno.value.notas.nota1 &&\n        this.formAlumno.value.notas.nota2 &&\n        this.formAlumno.value.notas.nota3) {\n        let nota1 = parseInt(this.formAlumno.value.notas.nota1);\n        let nota2 = parseInt(this.formAlumno.value.notas.nota2);\n        let nota3 = parseInt(this.formAlumno.value.notas.nota3);\n        if (nota1 >= 4 && nota2 >= 4 && nota3 >= 4)\n          this.resultado = \"El alumno queda aprobado por esas notas\";\n        else\n          this.resultado = \"El alumno no aprueba por esas notas\";\n      }\n    }\n  }\n}\n\n\nCreamos un objeto de la clase FormGroup y dentro de este otro objeto de la clase FormGroup que agrupa las tres notas:\n  formAlumno = new FormGroup({\n    dni: new FormControl(''),\n    nombre: new FormControl(''),\n    notas: new FormGroup({\n      nota1: new FormControl(''),\n      nota2: new FormControl(''),\n      nota3: new FormControl('')\n    })\n  });\n\nEsto provoca en la vista que cuando asociemos las tres notas debemos agruparlas dentro de un etiqueta HTML que defina una propiedad 'formGroupName':\n  <div formGroupName=\"notas\">\n    <p>Primer nota:\n      <input type=\"text\" formControlName=\"nota1\">\n    </p>\n    <p>Segunda nota:\n      <input type=\"text\" formControlName=\"nota2\">\n    </p>\n    <p>Tercer nota:\n      <input type=\"text\" formControlName=\"nota3\">\n    </p>\n  </div>\n\n\nCuando se presiona el botón se verifica si las tres notas ingresadas son mayores o iguales a 4 para mostrar por pantalla si el alumno se encuentra aprobado o no (mediante los if verificamos que se hayan cargado valores en los controles input):\n  submit() {\n    if (this.formAlumno.value.notas) {\n      if (this.formAlumno.value.notas.nota1 &&\n        this.formAlumno.value.notas.nota2 &&\n        this.formAlumno.value.notas.nota3) {\n        let nota1 = parseInt(this.formAlumno.value.notas.nota1);\n        let nota2 = parseInt(this.formAlumno.value.notas.nota2);\n        let nota3 = parseInt(this.formAlumno.value.notas.nota3);\n        if (nota1 >= 4 && nota2 >= 4 && nota3 >= 4)\n          this.resultado = \"El alumno queda aprobado por esas notas\";\n        else\n          this.resultado = \"El alumno no aprueba por esas notas\";\n      }\n    }\n  }\n\n\n\n\n\n\nSi ejecutamos la aplicación tenemos una interfaz similar a:\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "18 - Formularios reactivos : validaciones estándares de Angular",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=18&codigo=18&inicio=0",
    "content": "Una funcionalidad muy importante de un formulario es la validación de las entradas de datos del usuario y la información que se le provee al mismo indicando los datos mal cargados.\nCuando utilizamos formularios reactivos la lógica de la validación se encuentra en la clase (archivo *.js) y no en la vista (archivo *.html)\nEl framework de Angular provee una clase llamada 'Validators' que contiene una serie de métodos estáticos para validar entradas de datos muy comunes como la estructura de un email, valores numéricos máximos y mínimos, cantidad mínima y máxima de caracteres etc.\nLa asignación de los métodos de validación se hace cuando se crea el objeto de la clase FormControl. Veremos con un ejemplo como configuramos distintos métodos de validación a los controles de un formulario.\n\n\n\nProblema\nConfeccionar un formulario de contacto que permita cargar el nombre, mail y un mensaje. Implementar las siguientes validaciones a los controles del formulario:\n\nLos tres controles no pueden quedar vacíos.\nEl nombre debe tener como mínimo 10 caracteres.\nEl email ingresado debe ser correcto.\nEl mensaje no puede superar los 500 caracteres.\n\nCuando se presione un botón mostrar un mensaje indicando si todos los controles se encuentran correctamente cargados.\n\n\nCrearemos primero el proyecto:\nng new proyecto013\n\n\n\n\nModificamos la vista de la componente que muestra el formulario reactivo  y eventualmente los mensajes de error de entrada de datos (app.component.html):\n<form [formGroup]=\"formularioContacto\" (ngSubmit)=\"submit()\">\n  <p>Nombre:\n    <input type=\"text\" formControlName=\"nombre\" required>\n    @if(this.formularioContacto.get('nombre')?.errors?.['required']) {\n    <span>(El nombre no puede quedar vacío)</span>\n    }\n    @if(this.formularioContacto.get('nombre')?.errors?.['minlength']) {\n    <span>(Debe tener como mínimo 10 caracteres)</span>\n    }\n  </p>\n  <p>Mail:\n    <input type=\"text\" formControlName=\"mail\">\n    @if(this.formularioContacto.get('mail')?.errors?.['required']) {\n    <span>(El mail no puede quedar vacío)</span>\n    }\n    @if(this.formularioContacto.get('mail')?.errors?.['email']) {\n    <span>(El mail no es válido)</span>\n    }\n  </p>\n  <p>Mensaje<br>\n    <textarea rows=\"10\" cols=\"70\" formControlName=\"mensaje\"></textarea>\n  </p>\n  @if(this.formularioContacto.get('mensaje')?.errors?.['required']) {\n  <div>(El mensaje no puede quedar vacío)</div>\n  }\n  @if(this.formularioContacto.get('mensaje')?.errors?.['maxlength']) {\n  <div>(Debe tener como máximo 500 caracteres)</div>\n  }\n  <button type=\"submit\">Confirmar</button>\n</form>\n<div>{{resultado}}</div>\n<router-outlet />\n\nAnalizaremos este archivo en conjunto luego de presentar 'app.component.ts'\n\n\n\nLa clase asociada a la vista es (app.component.ts):\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ReactiveFormsModule, FormControl, FormGroup, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, ReactiveFormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  resultado='';\n\n  formularioContacto = new FormGroup({\n    nombre: new FormControl('', [Validators.required, Validators.minLength(10)]),\n    mail: new FormControl('', [Validators.required, Validators.email]),\n    mensaje: new FormControl('', [Validators.required, Validators.maxLength(500)])\n  });\n\n  submit() {\n    if (this.formularioContacto.valid)\n      this.resultado = \"Todos los datos son válidos\";\n    else\n      this.resultado = \"Hay datos inválidos en el formulario\";\n  }\n}\n\n\nLo primero que debemos hacer es importar la clase 'Validators' y las otras que ya conocemos:\nimport { ReactiveFormsModule, FormControl, FormGroup, Validators } from '@angular/forms';\n\nCuando creamos los objetos de la clase FormControl debemos pasar como segundo parámetro del constructor los nombres de métodos que se le aplicarán a cada control de formulario:\n  formularioContacto = new FormGroup({\n    nombre: new FormControl('', [Validators.required, Validators.minLength(10)]),\n    mail: new FormControl('', [Validators.required, Validators.email]),\n    mensaje: new FormControl('', [Validators.required, Validators.maxLength(500)])\n  });\n\nPor ejemplo para el 'nombre' configuramos que se apliquen las validaciones: [Validators.required, Validators.minLength(10)], luego en la vista podemos verificar que validaciones se cumplen y cuales no:\n  <p>Nombre:\n    <input type=\"text\" formControlName=\"nombre\" required>\n    @if(this.formularioContacto.get('nombre')?.errors?.['required']) {\n    <span>(El nombre no puede quedar vacío)</span>\n    }\n    @if(this.formularioContacto.get('nombre')?.errors?.['minlength']) {\n    <span>(Debe tener como mínimo 10 caracteres)</span>\n    }\n  </p>\n\nMediante comandos @if validamos si se debe mostrar el mensaje de error dependiendo si el atributo this.formularioContacto.get('nombre')?.errors? existe o no.\nDe forma similar se hacen las validaciones para los otros controles.\nCuando se presiona el botón analizamos la propiedad 'valid' del objeto FormGroup, si almacena true significa que todos los controles de validación del formulario se verifican correctos:\n  submit() {\n    if (this.formularioContacto.valid)\n      this.resultado = \"Todos los datos son válidos\";\n    else\n      this.resultado = \"Hay datos inválidos en el formulario\";\n  }\n\n\n\n\n\n\n\nSi ejecutamos la aplicación tenemos una interfaz similar a:\n\n\nPodemos probar esta aplicación en la web aquí.\n\nAcotaciones\nPara conocer todos los métodos de validación que nos provee Angular podemos visitar su documentación oficial y analizar la clase Validators."
  },
  {
    "title": "19 - Formularios reactivos : validaciones personalizadas",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=19&codigo=19&inicio=0",
    "content": "Hemos visto que Angular provee una serie de funcionalidades para validar si un email es correcto, cantidad de caracteres máximos o mínimos ingresados, patrones de cadenas ingresados etc.\nHay situaciones particulares en nuestros proyectos que no se adaptan a ninguna de esas funcionalidades, para esas situaciones podemos codificar nuestras propias funciones de validación.\nVeremos los pasos a dar para crear nuestra propia función de validación.\n\n\n\n\nProblema\nConfeccionar un formulario que solicite el ingreso de un número múltiplo de 5. Validar que el valor ingresado sea múltiplo de 5 para que se active el botón de envío.\n\n\nCrearemos primero el proyecto:\nng new proyecto014\n\n\n\n\nLa función de validación se la podría definir en el mismo archivo de la componente, pero si la misma se empleará en más de un formulario, lo más conveniente es separarla en una clase independiente.\nCrearemos la clase 'ValidacionesPropias':\nng generate class ValidacionesPropias\n\nSe genera el archivo 'validaciones-propias.ts' donde debemos implementar el algoritmo de validación y también se genera el archivo 'validaciones-propias.spec.ts' para implementar pruebas unitarias.\n\n\n\n\nCodificaremos ahora el método 'multiplo5' en la clase 'ValidacionesPropias':\nimport { AbstractControl, ValidationErrors } from '@angular/forms';\n\nexport class ValidacionesPropias {\n    static multiplo5(control: AbstractControl): ValidationErrors| null {\n        let nro = parseInt(control.value);\n        if (nro % 5 == 0)\n            return null;\n        else\n            return { multiplo5: true }\n    }\n\n}\n\nEl método debe retornar null si el dato es correcto, en nuestro caso si el valor ingresado en el 'FormControl' el resto de dividirlo por 5 genera un cero luego retornamos null, en caso contrario retornamos un tipo de dato ValidationErrors, definiendo un atributo con el nombre del método y como valor true.\n\n\n\nModificamos la vista de la componente que muestra el formulario reactivo y eventualmente el mensaje de error de entrada de datos (app.component.html):\n<form [formGroup]=\"formularioContacto\" (ngSubmit)=\"submit()\">\n  <p>Ingrese un múltiplo de 5:\n    <input type=\"number\" formControlName=\"numero\">\n    @if(this.formularioContacto.get('numero')?.errors?.['multiplo5']) {\n    <span>(El valor debe ser multiplo de 5)</span>\n    }\n  </p>\n  <button type=\"submit\" [disabled]=\"formularioContacto.invalid\">Confirmar</button>\n</form>\n<router-outlet />\n\n\n\n\nLa clase asociada a la vista es (app.component.ts):\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ReactiveFormsModule, FormControl, FormGroup} from '@angular/forms';\nimport { ValidacionesPropias } from './validaciones-propias';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, ReactiveFormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  formularioContacto = new FormGroup({\n    numero: new FormControl('', [ValidacionesPropias.multiplo5])\n  });\n\n  submit() {\n    alert('dato correcto');\n  }\n}\n\nImportamos la clase que acabamos de crear:\nimport { ValidacionesPropias } from './validaciones-propias';\n\nPasamos al constructor de la clase FormControl la referencia del método que se encargará de validar el dato ingresado, de forma similar a las validaciones estándares:\n  formularioContacto = new FormGroup({\n    numero: new FormControl('', [ValidacionesPropias.multiplo5])\n  });\n\n\nEn la vista mostramos el mensaje de error si existe el atributo, recordemos que si nuestra función de validación retorna null luego no existe en 'errors' el valor 'multiplo5':\n    @if(this.formularioContacto.get('numero')?.errors?.['multiplo5']) {\n    <span>(El valor debe ser multiplo de 5)</span>\n    }\n\nPara que el botón del formulario permanezca desactivado mientras alguno de los datos del formulario no pase el test de validación disponemos:\n  <button type=\"submit\" [disabled]=\"formularioContacto.invalid\">Confirmar</button>\n\n'invalid' almacena true si alguno de los controles que estamos validando no es válido.\n\n\n\n\n\n\nSi ejecutamos la aplicación tenemos una interfaz similar a:\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "20 - Formularios reactivos : FormBuilder",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=20&codigo=20&inicio=0",
    "content": "La clase FormBuilder nos permite crear objetos de la clase FormGroup y FormControl con una sintaxis más corta. Es decir que el resultado final será el mismo al que obtenemos con la sintaxis vista anteriormente.\nQueda en decisión del desarrollador utilizar una u otra sintaxis.\nResolveremos un ejercicio de conceptos anteriores pero ahora con la sintaxis propuesta con la clase FormBuilder.\n\n\n\n\nProblema\nConfeccionar un formulario de contacto que permita cargar el nombre, mail y un mensaje. Implementar las siguientes validaciones a los controles del formulario:\n\nLos tres controles no pueden quedar vacíos.\nEl nombre debe tener como mínimo 10 caracteres.\nEl email ingresado debe ser correcto.\nEl mensaje no puede superar los 500 caracteres.\n\nCuando se presione un botón mostrar un mensaje indicando si todos los controles se encuentran correctamente cargados.\n\n\nCrearemos primero el proyecto:\nng new proyecto015\n\n\n\n\nModificamos la vista de la componente que muestra el formulario reactivo  y eventualmente los mensajes de error de entrada de datos (app.component.html):\n<form [formGroup]=\"formularioContacto\" (ngSubmit)=\"submit()\">\n  <p>Nombre:\n    <input type=\"text\" formControlName=\"nombre\" required>\n    @if(this.formularioContacto.get('nombre')?.errors?.['required']) {\n    <span>(El nombre no puede quedar vacío)</span>\n    }\n    @if(this.formularioContacto.get('nombre')?.errors?.['minlength']) {\n    <span>(Debe tener como mínimo 10 caracteres)</span>\n    }\n  </p>\n  <p>Mail:\n    <input type=\"text\" formControlName=\"mail\">\n    @if(this.formularioContacto.get('mail')?.errors?.['required']) {\n    <span>(El mail no puede quedar vacío)</span>\n    }\n    @if(this.formularioContacto.get('mail')?.errors?.['email']) {\n    <span>(El mail no es válido)</span>\n    }\n  </p>\n  <p>Mensaje<br>\n    <textarea rows=\"10\" cols=\"70\" formControlName=\"mensaje\"></textarea>\n  </p>\n  @if(this.formularioContacto.get('mensaje')?.errors?.['required']) {\n  <div>(El mensaje no puede quedar vacío)</div>\n  }\n  @if(this.formularioContacto.get('mensaje')?.errors?.['maxlength']) {\n  <div>(Debe tener como máximo 500 caracteres)</div>\n  }\n  <button type=\"submit\">Confirmar</button>\n</form>\n<div>{{resultado}}</div>\n<router-outlet />\n\nAnalizaremos este archivo en conjunto luego de presentar 'app.component.ts'\n\n\n\nLa clase asociada a la vista es (app.component.ts):\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ReactiveFormsModule, Validators, FormBuilder, FormGroup } from '@angular/forms';\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, ReactiveFormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  resultado!: string;\n  formularioContacto: FormGroup;\n\n  constructor(private fb: FormBuilder) {\n    this.formularioContacto = this.fb.group({\n      nombre: ['', [Validators.required, Validators.minLength(10)]],\n      mail: ['', [Validators.required, Validators.email]],\n      mensaje: ['', [Validators.required, Validators.maxLength(500)]]\n    });\n  }\n\n  submit() {\n    if (this.formularioContacto.valid)\n      this.resultado = \"Todos los datos son válidos\";\n    else\n      this.resultado = \"Hay datos inválidos en el formulario\";\n  }\n\n}\n\n\nLo primero que debemos hacer es importar la clase FormBuilder (ya no requerimos importar las clases FormGroup y FormControl):\nimport { ReactiveFormsModule, Validators, FormBuilder, FormGroup } from '@angular/forms';\n\nSe inyecta al constructor un objeto de la clase FormBuilder:\n  constructor(private fb: FormBuilder) {\n  }\n\n\nLlamamos al método 'group' de la clase FormBuilder y le pasamos un objeto literal indicando como atributos los nombres de los controles visuales definidos en HTML y como valor se le pasa un arreglo, cuyo primer elemento es el valor inicial del control y en el segundo elemento del arreglo pasamos otro arreglo con las funciones de validación que se le aplican a dicho campo:\n    this.formularioContacto = this.fb.group({\n      nombre: ['', [Validators.required, Validators.minLength(10)]],\n      mail: ['', [Validators.required, Validators.email]],\n      mensaje: ['', [Validators.required, Validators.maxLength(500)]]\n    });\n\nTener que el resultado es exactamente el mismo si utilizamos la sintaxis vista anteriormente (debemos importar la clase FormControl en dicho caso):\n  this.formularioContacto = new FormGroup({\n    nombre: new FormControl('', [Validators.required, Validators.minLength(10)]),\n    mail: new FormControl('', [Validators.required, Validators.email]),\n    mensaje: new FormControl('', [Validators.required, Validators.maxLength(500)])\n  });\n\n\n\n\nSi ejecutamos la aplicación tenemos una interfaz similar a:\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "21 - Router : definición de rutas",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=21&codigo=21&inicio=20",
    "content": "Angular incluye un módulo especial si queremos administrar nuestra aplicación mediante rutas.\nLas rutas están dadas por la url, ejemplos de rutas pueden ser:\nhttp://localhost:4200/contacto\nhttp://localhost:4200/acercade\nhttp://localhost:4200/proveedores\n\nLuego según la ruta especificada mostramos una vista distinta, generalmente indicando un nombre de componente.\nCuando creamos la aplicación con Angular CLI nos genera los archivos básicos para trabajar con rutas (Router).\nProblema\nImplementar una aplicación que muestre dos enlaces en la parte superior de la página que acceda el primero a un formulario de contacto y el segundo una página de Acerca de.\nEs decir que tenemos las siguientes pantallas:\nCuando se inicia:\n\nCuando se selecciona el enlace de contacto:\n\nCuando se selecciona el enlace de Acerca de...:\n\n\n\n\nDesde la línea de comandos de Node.js procedemos a crear el proyecto016:\nng new proyecto016\n\nLo primero que vamos a hacer es crear las dos componentes que a posteriori configuraremos una ruta para cada uno.\n\nCreamos la componente contacto:\nng generate component contacto\n\nImplementamos el siguiente código para los tres archivos:\ncontacto.component.html\n<form [formGroup]=\"formularioContacto\" (ngSubmit)=\"submit()\">\n  <p>Nombre:\n    <input type=\"text\" formControlName=\"nombre\">\n  </p>\n  <p>Mail:\n    <input type=\"text\" formControlName=\"mail\">\n  </p>\n  <p>Mensaje<br>\n    <textarea rows=\"10\" cols=\"70\" formControlName=\"mensaje\"></textarea>\n  </p>\n  <button type=\"submit\">Confirmar</button>\n</form>\n<div>{{datos}}</div>\n\n\ncontacto.component.ts\nimport { Component } from '@angular/core';\nimport { ReactiveFormsModule, FormControl, FormGroup } from '@angular/forms';\n\n@Component({\n  selector: 'app-contacto',\n  imports: [ReactiveFormsModule],\n  templateUrl: './contacto.component.html',\n  styleUrl: './contacto.component.css'\n})\nexport class ContactoComponent {\n  datos = '';\n\n  formularioContacto = new FormGroup({\n    nombre: new FormControl(''),\n    mail: new FormControl(''),\n    mensaje: new FormControl('')\n  });\n\n  submit() {\n    this.datos = `Nombre=${this.formularioContacto.value.nombre}\n                Mail=${this.formularioContacto.value.mail}\n                Mensaje=${this.formularioContacto.value.mensaje}\n                `;\n  }\n}\n\n\n\ncontacto.component.css\n/* Estilos para el formulario */\nform {\n  max-width: 400px;\n  margin: 0 auto;\n  font-family: 'Arial', sans-serif;\n}\n\np {\n  margin-bottom: 15px;\n}\n\ninput,\ntextarea {\n  width: 100%;\n  padding: 8px;\n  margin: 5px 0 15px 0;\n  box-sizing: border-box;\n}\n\nbutton {\n  background-color: #4caf50;\n  color: #fff;\n  padding: 10px 15px;\n  border: none;\n  border-radius: 3px;\n  cursor: pointer;\n}\n\nbutton:hover {\n  background-color: #45a049;\n}\n\n/* Estilos para el resultado */\ndiv {\n  margin-top: 20px;\n  padding: 10px;\n  border: 1px solid #ccc;\n  border-radius: 3px;\n  font-weight: bold;\n}\n\n\n\n\n\n\nCreamos la componente acercade:\nng generate component acercade\n\nImplementamos el siguiente código para los tres archivos:\nacercade.component.html\n<h1>Programa: xxxxxxxxx</h1>\n<p>Desarrollado: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</p>\n<p>Fecha: xxxxxxxx</p>\n\n\nLos otros dos archivos los dejamos sin cambios: 'acercade.component.css' y 'acercade.component.ts'\n\n\n\n\n\nAhora si vamos a lo nuevo, abrimos y modificamos el archivo 'app.routes.ts':\nimport { Routes } from '@angular/router';\nimport { ContactoComponent } from './contacto/contacto.component';\nimport { AcercadeComponent } from './acercade/acercade.component';\n\nexport const routes: Routes = [\n  {\n    path: 'contacto',\n    component: ContactoComponent\n  },\n  {\n    path: 'acercade',\n    component: AcercadeComponent\n  }\n];\n\nModificamos el arreglo 'routes' con una serie de objetos que especifican las rutas. La propiedad path indica el nombre de la ruta y la propiedad component indica el nombre de la componente que se debe dibujar para dicha ruta.\nEs importante importar las componentes:\nimport { ContactoComponent } from './contacto/contacto.component';\nimport { AcercadeComponent } from './acercade/acercade.component';\n\n\n\n\n\n\n\nNos queda modificar la componente principal, por un lado el archivo 'app.component.html':\n<div style=\"text-align:center\">\n  <a routerLink=\"/contacto\">Contacto</a> -\n  <a routerLink=\"/acercade\">Acerca de ...</a>\n  <router-outlet />\n</div>\n\n\nMediante la etiqueta 'router-outlet' indicamos el lugar que debe mostrar la componente especificada por la ruta configurada en el archivo 'app.routes.ts' (ahora vemos el objetivo de la etiqueta <router-outlet /> que la dispone Angular por defecto cada vez que creamos un proyecto, en proyectos medianos o grandes es obligatorio el empleo de rutas)\nPara cambiar de ruta mediante hipervínculos debemos iniciar la propiedad 'routerLink' asignando la ruta respectiva.\nFinalmente el archivo 'app.component.ts':\nimport { Component } from '@angular/core';\nimport { RouterOutlet, RouterLink } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, RouterLink],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n}\n\nImportamos la clase 'RouterLink'.\n\nCuando ejecutemos si accedemos al primer hipervínculo (tener en cuenta que no se recarga la página, no hay una petición al servidor, sino se resuelve la ruta con aplicación Angular en el navegador):\n\nPor otro lado si accedemos a la otra ruta:\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "22 - Router : parámetros en una ruta",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=22&codigo=22&inicio=20",
    "content": "Angular se base en el concepto de SPA (Single Page Applications - Aplicaciones de una sola página), lo cual no significa que la URL del navegador sea siempre la misma.\nEl objetivo de Angular es que cuando cambiamos de URL no se recupere la estructura de la página del servidor, sino que se recree en forma local (salvo que se tengan que hacer peticiones de datos dinámicos al servidor)\nVimos que las rutas están dadas por las URL:\nhttp://localhost:4200/\nhttp://localhost:4200/presentacion\nhttp://localhost:4200/articulos\nhttp://localhost:4200/contacto\nhttp://localhost:4200/acercade\n\nTenemos la ruta raiz '/', otra ruta es 'acercade' etc.\nAhora veremos como trabajar en Angular si una ruta tiene uno o más parámetros. Un ejemplo de ruta con parámetros podría ser pasar el número de artículo en la ruta:\nhttp://localhost:4200/articulos/323\n\nEstamos pasando a la ruta 'articulos' el parámetro '323'. Como vimos anteriormente es obligatorio definir exactamente las rutas que puede procesar la aplicación Angular.\nCon un ejemplo analizaremos como declaramos las rutas, pasamos parámetros y como los recuperamos.\n\nProblema\nDefinir en la componente principal de la aplicación 10 hipervínculos con los números del 1 al 10, que llamen a otra ruta de la aplicación que tenga por objetivo mostrar la tabla de multiplicar de dicho valor.\nCrear una segunda componente que reciba el parámetro y proceda a mostrar la tabla de multiplicar.\nLos enlaces de los números del 1 al 10 siempre deben quedar visibles, lo que debe actualizarse es la componente que calcula la tabla de multiplicar:\n\n\n\nCrearemos primero el proyecto :\nng new proyecto017\n\n\n\n\nProcedemos a crear la componente 'TablanroComponent':\nng generate component tablanro\n\nModificamos el archivo 'tablanro.component.ts':\nimport { Component } from '@angular/core';\nimport { ActivatedRoute, ParamMap } from '@angular/router';\n\n@Component({\n  selector: 'app-tablanro',\n  imports: [],\n  templateUrl: './tablanro.component.html',\n  styleUrl: './tablanro.component.css'\n})\nexport class TablanroComponent {\n  nro=0;\n  tabla='';\n\n  constructor(private activatedRoute: ActivatedRoute) {\n    this.activatedRoute.paramMap.subscribe((parametros: ParamMap) => {\n      this.nro = parseInt(parametros.get(\"nro\")!);\n      this.tabla = '';\n      for (let x = 1; x <= 10; x++) {\n        let t = x * this.nro;\n        this.tabla += t + '-';\n      }\n    })\n  }\n}\n\n\n\nImportamos la clase ActivedRoute y la interface ParamMap:\nimport { ActivatedRoute, ParamMap } from '@angular/router';\n\nAl constructor inyectamos un objeto de tipo ActivedRoute:\n  constructor(private activatedRoute: ActivatedRoute) { \n\nDefinimos dos atributos 'nro' y 'tabla' que luego mediante interpolación mostraremos en la vista de la componente:\n  nro=0;\n  tabla='';\n\n\nEl método constructor se ejecutará una única vez cuando se crea la componente, luego como el usuario puede presionar sucesivas veces los enlaces con la misma ruta pero con distintos valores en su parámetro, debemos tener alguna forma para que dichos valores se refresquen en la vista. La clase 'ActivatedRoute' dispone de un método llamado 'paramMap' que llamando a suscribe logramos que cada vez que cambia el valor del parámetro de la ruta se ejecute la función anónima que le pasamos como parámetro.\nLa función anónima recibe como parámetro un objeto de la clase ParamMap que contiene entre otros un método llamado 'get' que nos permite recuperar el parámetro 'nro' de nuestro problema:\n    this.activatedRoute.paramMap.subscribe((parametros: ParamMap) => {\n      this.nro = parseInt(parametros.get(\"nro\")!);\n      this.tabla = '';\n      for (let x = 1; x <= 10; x++) {\n        let t = x * this.nro;\n        this.tabla += t + '-';\n      }\n    })\n\nModificamos el archivo 'tablanro.component.html':\n<p>Tabla del {{nro}}</p>\n<p>{{tabla}}</p>\n\nEn la vista mostramos el atributo 'nro' y el string con la tabla de multiplicar que lo recuperamos del atributo 'tabla'. Recordar que estos dos atributos se modifican en la función anónima que le pasamos al método 'suscribe' del objeto paramMap que almacena el objeto de la clase 'ActivadedRouter' que se le inyectó en el constructor.\n\n\n\n\nCodificamos la componente principal 'app.component.html':\n@for(numero of [2,3,4,5,6,7,8,9,10];track $index) {\n<span style=\"margin-right: 2rem;\">\n  <a routerLink=\"tabla/{{numero}}\">Tabla del {{numero}}</a>\n</span>\n}\n<div>\n  <router-outlet />\n</div>\n\nEl template de la componente principal siempre está visible, mediante el @for generamos los enlaces:\n@for(numero of [2,3,4,5,6,7,8,9,10];track $index) {\n<span style=\"margin-right: 2rem;\">\n  <a routerLink=\"tabla/{{numero}}\">Tabla del {{numero}}</a>\n</span>\n}\n\nEs importante notar que mediante la propiedad 'routerLink' indicamos la ruta que debemos cargar y el parámetro a pasar:\nrouterLink=\"tabla/{{numero}}\"\n\nLuego es fundamental la etiqueta 'router-outlet', que es el lugar donde se sustituye con el contenido de la ruta seleccionada de un enlace de la página:\n  <router-outlet />\n\nDe esta forma logramos que siempre se muestren los enlaces y lo que cambia es la ruta que cargamos y se hace en el lugar que especificamos la etiqueta 'router-outlet'.\n\n\nEn la componente principal debemos importar la clase RouterLink:\nimport { Component } from '@angular/core';\nimport { RouterOutlet,  RouterLink } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, RouterLink],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n}\n\n\n\n\nTambién debemos modificar el archivo 'app.routes.ts':\nimport { Routes } from '@angular/router';\nimport { TablanroComponent } from './tablanro/tablanro.component';\n\nexport const routes: Routes = [{\n  path: \"tabla/:nro\",\n  component: TablanroComponent\n}];\n\nImportamos la clase 'TablanroComponent' :\nimport { TablanroComponent } from './tablanro/tablanro.component';\n\nAgregamos un objeto al arreglo 'routes' iniciando dos atributos: 'path' que indica el nombre de la ruta y en este caso el parámetro 'nro', y en 'component' indicamos el nombre de la componente que se debe mostrar:\nexport const routes: Routes = [{\n  path: \"tabla/:nro\",\n  component: TablanroComponent\n}];\n\n\n\nPodemos probar esta aplicación en la web aquí.\n\n\n\nAcotaciones\nUna ruta puede tener más de un parámetro, por ejemplo si necesitamos pasar un segundo parámetro en el ejercicio anterior que indique la cantidad de términos de la tabla de multiplicar que se va a mostrar, deberíamos hacer los siguientes cambios:\n\n\nEn el archivo 'app.routes.ts' cambiar el atributo path de la ruta:\nexport const routes: Routes = [{\n  path: \"tabla/:nro/:terminos\",\n  component: TablanroComponent\n}];\n\n\n\nEn la componente 'tablanro.component.ts' cambiar el for con el parámetro recibido:\n  constructor(private activatedRoute: ActivatedRoute) {\n    this.activatedRoute.paramMap.subscribe((parametros: ParamMap) => {\n      this.nro = parseInt(parametros.get(\"nro\")!);\n      this.tabla = '';\n      for (let x = 1; x <= parseInt(parametros.get(\"terminos\")!); x++) {\n        let t = x * this.nro;\n        this.tabla += t + '-';\n      }\n    })\n  }\n\n\n\nFinalmente los enlaces en el archivo 'app.component.html' requieren dos parámetros, por ejemplo si queremos mostrar 20 términos de la tabla de multiplicar, el código debe ser:\n  <a routerLink=\"tabla/{{numero}}/20\">Tabla del {{numero}}</a>"
  },
  {
    "title": "23 - Router : captura de ruta no existente",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=23&codigo=23&inicio=20",
    "content": "Como vimos en el concepto anterior en el archivo 'app.routes.ts' configuramos en el arreglo 'routes' todas las rutas que dispone nuestra aplicación, ahora veremos que cambios debemos hacer en el archivo para capturar una ruta inexistente e informar de tal situación al usuario.\n\n\n\nProblema\nConfeccionar una página que muestre una barra de navegación con 4 enlaces: 'Inicio', 'Mapa', 'Contacto' y 'Acerca de..'.\nDefinir una ruta para cada sección de la página y en el caso de ingresar el usuario una ruta inexistente mostrar tal situación.\n\n\n\nCrearemos primero el proyecto:\nng new proyecto018\n\n\n\n\n\nCreamos 5 componentes, 4 que representan cada una de las secciones del sitio web y una quinta de ruta inexistente (lo que conocemos \"404 page not found\", tener en cuenta que Angular no hace realmente una petición al servidor, sino que tiene toda la información ya cargada en el navegador)\nCreación de las componentes:\nng generate component Inicio\nng generate component Mapa\nng generate component Contacto\nng generate component AcercaDe\nng generate component Pagina404\n\n\n\n\n\nModificamos el archivo 'app.routes.ts' especificando las rutas de nuestra aplicación:\nimport { Routes } from '@angular/router';\nimport { InicioComponent } from './inicio/inicio.component';\nimport { MapaComponent } from './mapa/mapa.component';\nimport { ContactoComponent } from './contacto/contacto.component';\nimport { AcercaDeComponent } from './acerca-de/acerca-de.component';\nimport { Pagina404Component } from './pagina404/pagina404.component';\n\nexport const routes: Routes = [{\n  path: '',\n  component: InicioComponent\n},\n{\n  path: 'inicio',\n  component: InicioComponent\n},\n{\n  path: 'mapa',\n  component: MapaComponent\n},\n{\n  path: 'contacto',\n  component: ContactoComponent\n},\n{\n  path: 'acercade',\n  component: AcercaDeComponent\n},\n{\n  path: 'pagina404',\n  component: Pagina404Component\n},\n{\n  path: '**',\n  redirectTo: 'pagina404'\n}];\n\nLa última componente del arreglo es la que indicamos en path la cadena '**' y mediante el atributo 'redirectTo' especificamos a que otro path redireccionar:\n  {\n    path: '**',\n    redirectTo: 'pagina404'\n  }\n\nEs indispensable para el funcionamiento que la captura de ruta inexistente con los \"**\" sea la última del arreglo.\nSi el usuario no carga ninguna ruta, sino directamente el nombre del dominio, luego tenemos que se muestra la componente 'InicioComponent':\n  {\n    path: '',\n    component: InicioComponent\n  },\n\n\n\n\nProcedemos a modificar la vista de la componente que crea Angular 'app.component.html' donde creamos la barra de navegación con los enlaces a las distintas rutas de nuestra aplicación:\n<div class=\"menu\">\n  <a routerLink=\"inicio\">Inicio</a>\n  <a routerLink=\"mapa\">Mapa</a>\n  <a routerLink=\"contacto\">Contacto</a>\n  <a routerLink=\"acercade\">Acerca de...</a>\n</div>\n\n<div>\n  <router-outlet />\n</div>\n\nEs importante utilizar la propiedad 'routerLink' para indicar cada una de las rutas.\nDisponemos la etiqueta 'router-outlet', que sabemos que es el espacio que será sustituido por la componente respectiva definida en el arreglo 'router'.\n\n\nEl archivo 'app.component.ts' queda con el siguiente código (importamos RouterLink):\nimport { Component } from '@angular/core';\nimport { RouterOutlet, RouterLink } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, RouterLink],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'proyecto018';\n}\n\n\nLa hoja de estilo para la componente la especificamos en el archivo 'app.component.css' :\n.menu {\n  display: flex;\n  justify-content: space-around;\n  background-color: #333;\n  padding: 10px;\n}\n\n.menu a {\n  color: #fff;\n  text-decoration: none;\n  padding: 5px 10px;\n}\n\n.menu a:hover {\n  background-color: #555;\n}\n\n\n\n\n\n\n\n\n\nFinalmente agregamos algunos datos a cada una de las 5 componentes que representas las secciones de nuestro sitio web:\ninicio.component.html\n<h1>Contenido de página de inicio.</h1>\n\n\nmapa.component.html\n<h1>Contenido de página de mapa.</h1>\n\n\ncontacto.component.html\n<h1>Contenido de página de contacto.</h1>\n\n\nacercade.component.html\n<h1>Contenido de página de acerca de.</h1>\n\n\npagina404.component.html\n<h1>Página no encontrada.</h1>\n\n\n\n\nCon los pasos dados ya tenemos nuestro sitio que muestra correctamente cada una de las rutas definidas para nuestro sitio web:\n\nSi ingresa una ruta no válida, por ejemplo \"http://localhost:4200/noticias\", se procede a redireccionar y mostrar la componente que hemos estipulado nosotros:\n\nEs nuestra decisión a que página redireccionar, podemos inclusive no informar nada y redireccionarlo a la página principal del sitio.\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "24 - Router : rutas anidadas",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=24&codigo=24&inicio=20",
    "content": "En un comienzo trabajamos el desarrollo de aplicaciones Angular componiendo la misma como un conjunto de componentes todas en la misma ruta, por ejemplo:\nhttps://www.sitio.com/\n\nLuego vimos que cuando la aplicación comienza a ser más compleja es más conveniente agrupar sus funcionalidades en distintas rutas, con o sin parámetros:\nhttps://www.sitio.com/inicio\nhttps://www.sitio.com/clientes\nhttps://www.sitio.com/contacto\nhttps://www.sitio.com/articulos\n\nEsta forma de organizar las rutas nos permite crear un sitio más grande, pero ahora veremos que podemos crear rutas anidadas, por ejemplo:\nhttps://www.sitio.com/inicio\nhttps://www.sitio.com/clientes/mayoristas\nhttps://www.sitio.com/clientes/minoristas\n\nVeremos que Angular requiere una sintaxis específica cuando definimos el arreglo Routes para indicar que se trata de una ruta anidada.\n\n\n\nProblema\nConfeccionar una aplicación que muestre una barra de navegación con 2 rutas: 'America' y 'Europa'.\nCuando se selecciona 'America', mostrar el mapa de 'América' y una barra de navegación con 3 paises americanos, hacer lo mismo si se elije Europa, emplear rutas anidadas para cada país, de tal forma que se acceda a cada país con la siguiente sintaxis:\nhttps://www.sitio.com\nhttps://www.sitio.com/america\nhttps://www.sitio.com/america/chile\nhttps://www.sitio.com/america/argentina\nhttps://www.sitio.com/america/uruguay\nhttps://www.sitio.com/europa\nhttps://www.sitio.com/europa/espana\nhttps://www.sitio.com/europa/francia\nhttps://www.sitio.com/europa/italia\n\n\n\n\nCrearemos primero el proyecto:\nng new proyecto019\n\n\n\n\nCrearemos 2 componentes para cada continente y 6 componentes más para cada país (si copiamos y pegamos en la consola de VSCode podemos rápidamente crear las 8 componentes):\nng generate component america\nng generate component america/chile\nng generate component america/argentina\nng generate component america/uruguay\nng generate component europa\nng generate component europa/espana\nng generate component europa/francia\nng generate component europa/italia\n\nPodíamos crear todas las componentes en la misma altura y no crear subcarpetas para cada país, pero queda mucho más ordenada nuestra aplicación si comenzamos a agrupar las componentes en distintas carpetas y subcarpetas en forma jerárquica. Angular CLI crea automáticamente una subcarpeta cuando no existe al utilizar la sintaxis:\nng generate component america/chile\n\nSe crea la carpeta 'america' y dentro de la misma se guardan los cuatro archivos asociados a la componente 'chile'.\nPodemos ver en el editor de texto las 8 componentes creadas:\n\nEl caracter 'ñ' no se puede utilizar como selector: Selector (app-españa) is invalid.\n\n\n\n\nProcedemos a modificar el archivo 'app.routes.ts' definiendo las rutas principales y las anidadas:\nimport { Routes } from '@angular/router';\nimport { AmericaComponent } from './america/america.component';\nimport { ChileComponent } from './america/chile/chile.component';\nimport { ArgentinaComponent } from './america/argentina/argentina.component';\nimport { UruguayComponent } from './america/uruguay/uruguay.component';\nimport { EuropaComponent } from './europa/europa.component';\nimport { EspanaComponent } from './europa/espana/espana.component';\nimport { FranciaComponent } from './europa/francia/francia.component';\nimport { ItaliaComponent } from './europa/italia/italia.component';\nexport const routes: Routes = [\n  {\n    path: 'america',\n    component: AmericaComponent,\n    children: [\n      {\n        path: 'chile',\n        component: ChileComponent\n      },\n      {\n        path: 'argentina',\n        component: ArgentinaComponent\n      },\n      {\n        path: 'uruguay',\n        component: UruguayComponent\n      }\n    ]\n  },\n  {\n    path: 'europa',\n    component: EuropaComponent,\n    children: [\n      {\n        path: 'espana',\n        component: EspanaComponent\n      },\n      {\n        path: 'francia',\n        component: FranciaComponent\n      },\n      {\n        path: 'italia',\n        component: ItaliaComponent\n      }\n    ]\n  }\n];\n\nAgregamos en cada objeto que tiene rutas anidadas la propiedad 'children', la cual es un arreglo de objetos donde definimos todas las rutas anidadas.\nLuego podemos indicar en el navegador una ruta principal:\nhttps://www.sitio.com/america\n\nPero también podemos acceder a una ruta anidada con la sintaxis:\nhttps://www.sitio.com/america/chile\n\n\n\n\n\n\n\nProcedemos a modificar la componente principal que nos genera Angular 'app.component.html':\n<div class=\"menu\">\n  <a routerLink=\"america\">America</a>\n  <a routerLink=\"europa\">Europa</a>\n</div>\n\n<div>\n  <router-outlet />\n</div>\n\nLa directiva 'router-outlet' es indispensable para que se muestren alguna de las dos componentes 'AmericaComponent' o 'EuropaComponent' según que enlace se seleccione.\n\nTambién modificamos el archivo app.component.ts:\nimport { Component } from '@angular/core';\nimport { RouterOutlet, RouterLink } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, RouterLink],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  title = 'proyecto019';\n}\n\n\n\n\n\nCuando se selecciona la ruta 'america' se carga la componentes 'AmericaComponent', modificamos la vista de dicha componente 'america.component.html'\n<iframe\n  src=\"https://www.google.com/maps/embed?pb=!1m14!1m12!1m3!1d31536306.714862086!2d-54.01447990393665!3d-20.38062741924525!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!5e0!3m2!1ses!2sar!4v1583676893900!5m2!1ses!2sar\"\n  width=\"600\" height=\"450\" frameborder=\"0\" style=\"border:0;\" allowfullscreen=\"\"></iframe>\n<div class=\"menu\">\n  <a routerLink=\"chile\">Chile</a>\n  <a routerLink=\"argentina\">Argentina</a>\n  <a routerLink=\"uruguay\">Uruguay</a>\n</div>\n<router-outlet />\n\nDisponemos tres enlaces hacia las rutas anidadas, recordemos que esta componente se activa cuando se seleccionó la ruta 'america'.\nTambién esta componente dispone la etiqueta 'router-outlet' donde deben visualizarse las componentes 'ArgentinaComponent', 'ChileComponent' o 'UruguayComponent'.\n\n\n\nTambién debemos modificar el archivo 'america.component.ts' agregando los import respectivos\nimport { Component } from '@angular/core';\nimport { RouterOutlet, RouterLink } from '@angular/router';\n@Component({\n  selector: 'app-america',\n  imports: [RouterOutlet, RouterLink],\n  templateUrl: './america.component.html',\n  styleUrl: './america.component.css'\n})\nexport class AmericaComponent {\n\n}\n\n\n\n\n\n\nExactamente lo mismo hacemos para crear la componente 'europa.component.html':\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m14!1m12!1m3!1d9880418.608500127!2d2.640727530399596!3d45.69187171781666!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!5e0!3m2!1ses!2sar!4v1583677509059!5m2!1ses!2sar\" width=\"600\" height=\"450\" frameborder=\"0\" style=\"border:0;\" allowfullscreen=\"\"></iframe>\n<div class=\"menu\">\n  <a routerLink=\"espana\">España</a>\n  <a routerLink=\"francia\">Francia</a>\n  <a routerLink=\"italia\">Italia</a>\n</div>\n<router-outlet />\n\n\n\n\nTambién debemos modificar el archivo 'europa.component.ts' agregando los import respectivos\nimport { Component } from '@angular/core';\nimport { RouterOutlet, RouterLink } from '@angular/router';\n\n@Component({\n  selector: 'app-europa',\n  imports: [RouterOutlet, RouterLink],\n  templateUrl: './europa.component.html',\n  styleUrl: './europa.component.css'\n})\nexport class EuropaComponent {\n\n}\n\n\n\n\n\n\nYa tenemos prácticamente finalizado el ejemplo de rutas anidadas con Angular, podemos modificar las vistas de las componentes de cada país:\nchile.component.html\nargentina.component.html\nuruguay.component.html\nespana.component.html\nfrancia.component.html\nitalia.component.html\n\n\n\n\nVamos a disponer una serie de estilos comunes a todos los menúes de la aplicación, para ello modificamos el archivo 'styles.css' que se encuentra en la raiz del proyecto:\n\n/* You can add global styles to this file, and also import other style files */\n\n.menu {\n  display: flex;\n  justify-content: space-around;\n  background-color: #333;\n  padding: 10px;\n}\n\n.menu a {\n  color: #fff;\n  text-decoration: none;\n  padding: 5px 10px;\n}\n\n.menu a:hover {\n  background-color: #555;\n}\n\n\n\n\nSi seleccionamos la opción de América:\n\nFinalmente si ingresamos a una ruta anidada por ejemplo Argentina:\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "25 - Servicios : concepto y pasos para crearlos",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=25&codigo=25&inicio=20",
    "content": "El pilar fundamental cuando creamos una aplicación en Angular es la correcta definición de sus componentes y relaciones entre ellas.\nLa propuesta del framework de Angular es delegar todas las responsabilidades de acceso a datos (peticiones y envío de datos) y lógica de negocios en otras clases que colaboran con las componentes. Estas clases en Angular se las llama servicios.\nTal es la importancia de los servicios en Angular que la herramienta Angular CLI nos provee la capacidad de crearlos.\nVeremos con un ejemplo los pasos que debemos dar para crear un servicio y luego consumirlo desde una componente.\nProblema\nConfeccionar una aplicación Angular que muestre una lista de artículos. Los artículos almacenarlos en un vector localizado en un servicio. Desde la componente acceder al servicio para pedir los artículos a ser mostrados.\n\n\n\n\nDesde la línea de comandos de Node.js procedemos a crear el proyecto020:\nng new proyecto020\n\n\n\n\nCrearemos el servicio que contiene en memoria la lista de artículos (en muchos casos como veremos más adelante el servicio tiene la responsabilidad de recuperar los datos de un servidor web):\nng generate service articulos\n\nCon el comando anterior estamos creando la clase 'ArticulosService'.\nSe crean dos archivos:\n\n\nEl código generado de la clase 'ArticulosService' es:\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ArticulosService {\n\n  constructor() { }\n}\n\n\nLo modificamos por el siguiente código que permita recuperar desde la componente el vector de artículos:\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ArticulosService {\n\n  constructor() { }\n\n  retornar() {\n    return [\n      {\n        codigo: 1,\n        descripcion: \"papas\",\n        precio: 12.33\n      },\n      {\n        codigo: 2,\n        descripcion: \"manzanas\",\n        precio: 54\n      },\n      {\n        codigo: 3,\n        descripcion: \"sandía\",\n        precio: 14\n      }\n    ];\n  }\n}\n\n\nEl decorador @Injectable() será de suma importancia para poder acceder a esta clase desde la componente.\n\n\n\nAhora veremos como consumimos el servicio desde nuestra componente. Procedemos a modificar la componente que se crea por defecto 'AppComponent' que tiene por responsabilidad mostrar en la página el listado de artículos:\n\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ArticulosService } from './articulos.service';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  articulos :any;\n\n  constructor(private articulosServicio: ArticulosService) {\n    this.articulos=this.articulosServicio.retornar();\n  }\n\n}\n\n\nPrimero importamos el servicio llamado ArticulosService que se almacena en el archivo 'articulos.service.ts':\nimport { ArticulosService } from './articulos.service';\n\n\nPara inyectar el objeto de la clase 'ArticulosService' que crea Angular en forma automática lo hacemos en el parámetro del constructor::\n  constructor(private articulosServicio: ArticulosService) {\n    this.articulos=this.articulosServicio.retornar();\n  }\n\nEsta asignación dispara la actualización de la página HTML.\n\n\n\nFalta que codifiquemos la vista con los datos  recuperados:\napp.component.html\n<table>\n  @for(articulo of articulos;track $index) {\n  <tr>\n    <td>{{articulo.codigo}}</td>\n    <td>{{articulo.descripcion}}</td>\n    <td>{{articulo.precio}}</td>\n  </tr>\n  }\n</table>\n<router-outlet />\n\n\n\n\n\nPor último la hoja de estilo de la componente:\napp.component.css\n/* Estilo para la tabla */\ntable {\n  border-collapse: collapse;\n  width: 100%;\n}\n\n/* Estilo para las celdas de la tabla */\ntd {\n  border: 1px solid #dddddd;\n  text-align: left;\n  padding: 8px;\n}\n\n/* Estilo para las filas impares  */\ntr:nth-child(odd) {\n  background-color: #f2f2f2;\n}\n\n/* Estilo para las filas al pasar el ratón sobre ellas */\ntr:hover {\n  background-color: #e6e6e6;\n}\n\n\n\n\n\n\n\nSi ejecutamos ahora el proyecto020 veremos en el navegador el listado de artículos:\nng server -o\n\n\nPodemos probar esta aplicación en la web aquí.\n\n\n\n\nAl principio y con problemas muy sencillos parece que solo agregamos complejidad a nuestra aplicación.\nVeremos que esta forma de desacoplar el acceso a datos de las componentes y delegarla en otras clases llamadas servicios facilita el mantenimiento de nuestras aplicaciones.\nTambién hay que hacer notar que la forma de consumir dichas clases se hace por medio del patrón de inyección de dependencias."
  },
  {
    "title": "26 - Servicios : recuperación de datos de un servidor web",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=26&codigo=26&inicio=20",
    "content": "Hemos dicho en el concepto anterior que en Angular se delega todas las responsabilidades de acceso a datos (peticiones y envío de datos) y lógica de negocios en otras clases que colaboran con las componentes y son llamados servicios.\nVeremos ahora como recuperar datos de un servidor web implementando dicha actividad en un servicio.\nProblema\nConfeccionar una aplicación que recupere una respuesta en JSON de la dirección:\nhttps://ejerciciostutorialesya.com/vue/datos.php\n\nLa estructura del archivo JSON es:\n[\n  {\n    \"codigo\": 1,\n    \"descripcion\": \"papas\",\n    \"precio\": 12.33\n  },\n  {\n    \"codigo\": 2,\n    \"descripcion\": \"manzanas\",\n    \"precio\": 54\n  },\n  {\n    \"codigo\": 3,\n    \"descripcion\": \"sandia\",\n    \"precio\": 31\n  }\n]\n\nMostrar en una tabla HTML todos los artículos recuperados.\nLa recuperación de datos se debe hacer en un servicio.\n\n\n\n\n\n\nDesde la línea de comandos de Node.js procedemos a crear el proyecto021:\nng new proyecto021\n\n\n\n\nCrearemos el servicio que recuperará desde un servidor la lista de artículos\nng generate service articulos\n\nCon el comando anterior estamos creando la clase 'ArticulosService'\nSe crean dos archivos.\n\n\nEl código generado de la clase 'ArticulosService' es:\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ArticulosService {\n\n  constructor() { }\n}\n\n\nLo modificamos por el siguiente código que permita recuperar desde un servidor web el archivo JSON:\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ArticulosService {\n\n  constructor(private http: HttpClient) { }\n\n  retornar() {\n    return this.http.get(\"https://ejerciciostutorialesya.com/vue/datos.php\");\n  }  \n}\n\n\nDebemos ahora modificar el archivo 'app.config.ts' para poder utilizar la función provideHttpClient:\nimport { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';\nimport { provideRouter } from '@angular/router';\nimport { routes } from './app.routes';\nimport { provideHttpClient } from '@angular/common/http';\nimport { withFetch } from '@angular/common/http';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes), provideHttpClient(withFetch())]\n};\n\n\n\n\n\n\nAhora veremos como consumimos el servicio desde nuestra componente. Procedemos a modificar la componente que se crea por defecto 'AppComponent' que tiene por responsabilidad mostrar en la página el listado de artículos:\n\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ArticulosService } from './articulos.service';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n\n  articulos: any;\n\n  constructor(private articulosService: ArticulosService) {\n    this.articulosService.retornar()\n      .subscribe(result => this.articulos = result)\n  }\n\n}\n\n\nPrimero importamos el servicio llamado ArticulosService que se almacena en el archivo 'articulos.service.ts':\nimport { ArticulosService } from './articulos.service';\n\nPara inyectar el objeto de la clase 'ArticulosService' que crea Angular en forma automática lo hacemos en el parámetro del constructor:\n  constructor(private articulosService: ArticulosService) {\n    this.articulosService.retornar()\n      .subscribe(result => this.articulos = result)\n  }\n\nSe almacena en el atributo 'articulosServicio' la referencia del objeto de la clase 'ArticulosService' que crea Angular.\nEsta asignación dispara la actualización de la página HTML.\n\n\n\nFalta que codifiquemos la vista con los datos  recuperados:\napp.component.html\n  <table>\n    <tr>\n      <td>Codigo</td><td>Descripcion</td><td>Precio</td>\n    </tr>\n    @for(art of articulos;track art.codigo) {\n    <tr>\n      <td>{{art.codigo}}</td>\n      <td>{{art.descripcion}}</td>\n      <td>{{art.precio}}</td>\n    </tr>\n  }\n  </table>\n  <router-outlet />\n\n\n\n\n\nSi ejecutamos ahora el proyecto021 veremos en el navegador el listado de artículos, pero ahora recuperados de un servidor y no extraidos de un vector como en el concepto anterior:\nng server -o\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "27 - Comunicación entre Angular y PHP",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=27&codigo=27&inicio=20",
    "content": "Hemos dicho que Angular es un framework para el desarrollo de aplicaciones web de una sola página. Una situación muy común es tener que almacenar en un servidor de internet los datos que se ingresan en la aplicación Angular.\nExisten muchas tecnologías para procesar los datos que envía y recibe la aplicación Angular, una de la más extendidas en el lenguaje PHP y mediante este acceder a una base de datos MySql.\nEn este concepto dejaremos en forma muy clara todos los pasos que debemos desarrollar tanto en el cliente (aplicación angular) como en el servidor (aplicación PHP y MySql)\nProblema\nConfeccionar una aplicación que permita administrar una lista de artículos, cada artículo almacena el código, descripción y precio . Se debe poder agregar, borrar y modificar los datos de un artículo almacenados en una base de datos MySQL y accedida con una programa en PHP.\n\n\nDesde la línea de comandos de Node.js procedemos a crear el proyecto022:\nf:\\angulardevya> ng new proyecto022\n\n\n\n\nRecordemos que la propuesta del framework de Angular es delegar todas las responsabilidades de acceso a datos (peticiones y envío de datos) y lógica de negocios en otras clases que colaboran con las componentes. Estas clases en Angular se las llama servicios.\nCrearemos el servicio 'articulos' para ello utilizamos Angular CLI:\nf:\\angulardevya\\proyecto022\\> ng generate service articulos\n\nCon el comando anterior estamos creando la clase 'ArticulosService'\nEl código que debemos guardar en el archivo 'articulos.service.ts' es:\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ArticulosService {\n\n  url='https://ejerciciostutorialesya.com/angular/proyecto016/'; // disponer url de su servidor que tiene las páginas PHP\n\n  constructor(private http: HttpClient) { }\n\n  recuperarTodos() {\n    return this.http.get(`${this.url}recuperartodos.php`);\n  }\n\n  alta(articulo:any) {\n    return this.http.post(`${this.url}alta.php`, JSON.stringify(articulo));    \n  }\n\n  baja(codigo:number) {\n    return this.http.get(`${this.url}baja.php?codigo=${codigo}`);\n  }\n  \n  seleccionar(codigo:number) {\n    return this.http.get(`${this.url}seleccionar.php?codigo=${codigo}`);\n  }\n\n  modificacion(articulo:any) {\n    return this.http.post(`${this.url}modificacion.php`, JSON.stringify(articulo));    \n  } \n}\n\n\nPresentaremos primero todos los archivos y luego explicaremos como se relacionan.\n\n\n\nDebemos ahora modificar el archivo 'app.config.ts' para poder utilizar la función provideHttpClient:\nimport { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';\nimport { provideRouter } from '@angular/router';\nimport { routes } from './app.routes';\nimport { provideHttpClient } from '@angular/common/http';\nimport { withFetch } from '@angular/common/http';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes), provideHttpClient(withFetch())]\n};\n\n\n\n\nNuestra única componente debe implementar el siguiente código en el archivo 'app.component.ts':\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ArticulosService } from './articulos.service';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, FormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  articulos:any;\n\n  art={\n    codigo:0,\n    descripcion:\"\",\n    precio:0\n  }\n\n  constructor(private articulosServicio: ArticulosService) {\n    this.recuperarTodos();\n  }\n\n\n  recuperarTodos() {\n    this.articulosServicio.recuperarTodos().subscribe((result:any) => this.articulos = result);\n  }\n\n  alta() {\n    this.articulosServicio.alta(this.art).subscribe((datos:any) => {\n      if (datos['resultado']=='OK') {\n        alert(datos['mensaje']);\n        this.recuperarTodos();\n      }\n    });\n  }\n\n  baja(codigo:number) {\n    this.articulosServicio.baja(codigo).subscribe((datos:any) => {\n      if (datos['resultado']=='OK') {\n        alert(datos['mensaje']);\n        this.recuperarTodos();\n      }\n    });\n  }\n\n  modificacion() {\n    this.articulosServicio.modificacion(this.art).subscribe((datos:any) => {\n      if (datos['resultado']=='OK') {\n        alert(datos['mensaje']);\n        this.recuperarTodos();\n      }\n    });\n  }\n\n  seleccionar(codigo:number) {\n    this.articulosServicio.seleccionar(codigo).subscribe((result:any) => this.art = result[0]);\n  }\n\n}\n\n\n\n\nY el archivo 'app.component.html' con:\n<div>\n  <h1>Administración de artículos</h1>\n    <table border=\"1\">\n      <tr>\n        <td>Codigo</td><td>Descripcion</td><td>Precio</td><td>Borrar</td><td>Seleccionar</td>\n      </tr>\n      @for(art of articulos;track art.codigo) {\n      <tr>\n        <td>{{art.codigo}}</td>\n        <td>{{art.descripcion}}</td>\n        <td>{{art.precio}}</td>\n        <td><button (click)=\"baja(art.codigo)\">Borrar?</button></td>\n        <td><button (click)=\"seleccionar(art.codigo)\">Seleccionar</button></td>\n      </tr>\n    }\n    </table>\n    <div>\n      <p>\n        descripcion:<input type=\"text\" [(ngModel)]=\"art.descripcion\" />\n      </p>\n      <p>\n        precio:<input type=\"number\" [(ngModel)]=\"art.precio\" />\n      </p>\n      <p><button (click)=\"alta()\">Agregar</button>\n      <button (click)=\"modificacion()\">Modificar</button></p>\n    </div>\n</div>\n<router-outlet />\n\nTodos los archivos presentados son los necesarios en Angular 19, veamos ahora que tenemos en PHP y MySQL.\n\n\n\nPrimero debemos crear una base de datos en MySQL llamada 'bd1' y crear la siguiente tabla:\nCREATE TABLE articulos (\n  codigo int AUTO_INCREMENT,\n  descripcion varchar(50),\n  precio float,\n  PRIMARY KEY (codigo)\n)\n\n\n\n\nTenemos una serie de archivos PHP que reciben datos en formato JSON y retornan también un JSON.\nEl archivo 'recuperartodos.php' retorna en formato JSON todos los artículos:\n<?php \n  header('Access-Control-Allow-Origin: *'); \n  header(\"Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept\");\n  \n  require(\"conexion.php\");\n  $con=retornarConexion();\n\n  $registros=mysqli_query($con,\"select codigo, descripcion, precio from articulos\");\n  $vec=[];  \n  while ($reg=mysqli_fetch_array($registros))  \n  {\n    $vec[]=$reg;\n  }\n  \n  $cad=json_encode($vec);\n  echo $cad;\n  header('Content-Type: application/json');\n?>\n\n\n\n\nEl archivo 'alta.php' recibe los datos en formato JSON y los almacena en la tabla:\n<?php \n  header('Access-Control-Allow-Origin: *'); \n  header(\"Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept\");\n  \n  $json = file_get_contents('php://input');\n \n  $params = json_decode($json);\n  \n  require(\"conexion.php\");\n  $con=retornarConexion();\n  \n\n  mysqli_query($con,\"insert into articulos(descripcion,precio) values\n                  ('$params->descripcion',$params->precio)\");\n    \n  \n  class Result {}\n\n  $response = new Result();\n  $response->resultado = 'OK';\n  $response->mensaje = 'datos grabados';\n\n  header('Content-Type: application/json');\n  echo json_encode($response);  \n?>\n\n\n\n\nEl archivo 'baja.php':\n<?php \n  header('Access-Control-Allow-Origin: *'); \n  header(\"Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept\");\n  \n  require(\"conexion.php\");\n  $con=retornarConexion();\n  \n  mysqli_query($con,\"delete from articulos where codigo=$_GET[codigo]\");\n    \n  \n  class Result {}\n\n  $response = new Result();\n  $response->resultado = 'OK';\n  $response->mensaje = 'articulo borrado';\n\n  header('Content-Type: application/json');\n  echo json_encode($response);  \n?>\n\n\n\n\nEl archivo 'modificacion.php':\n<?php \n  header('Access-Control-Allow-Origin: *'); \n  header(\"Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept\");\n  \n  $json = file_get_contents('php://input');\n \n  $params = json_decode($json);\n  \n  require(\"conexion.php\");\n  $con=retornarConexion();\n  \n\n  mysqli_query($con,\"update articulos set descripcion='$params->descripcion',\n                                          precio=$params->precio\n                                          where codigo=$params->codigo\");\n    \n  \n  class Result {}\n\n  $response = new Result();\n  $response->resultado = 'OK';\n  $response->mensaje = 'datos modificados';\n\n  header('Content-Type: application/json');\n  echo json_encode($response);  \n?>\n\n\n\n\nEl archivo 'seleccionar.php':\n<?php \n  header('Access-Control-Allow-Origin: *'); \n  header(\"Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept\");\n  \n  require(\"conexion.php\");\n  $con=retornarConexion();\n\n  $registros=mysqli_query($con,\"select codigo, descripcion, precio from articulos where codigo=$_GET[codigo]\");\n    \n  if ($reg=mysqli_fetch_array($registros))  \n  {\n    $vec[]=$reg;\n  }\n  \n  $cad=json_encode($vec);\n  echo $cad;\n  header('Content-Type: application/json');\n?>\n\n\n\n\nEl archivo 'conexion.php':\n<?php\nfunction retornarConexion() {\n  $con=mysqli_connect(\"localhost\",\"root\",\"\",\"bd1\");\n  return $con;\n}\n?>\n\n\n\n\n\nEl resultado de ejecutar esta aplicación en el navegador, teniendo en funcionamiento el servidor con PHP y MySQL es:\n\n\nExplicación\nAhora veremos como funciona esta aplicación cliente/servidor implementada con Angular en el cliente y PHP en el servidor.\n\nRecuperación de todos los registros\nInmediatamente se inicia la aplicación Angular se crea el objeto de la clase 'AppComponent' (nuestra única componente), en esta clase debe llegar al constructor el objeto de la clase 'ArticulosService' y procedemos a llamar al método 'recuperarTodos':\n  constructor(private articulosServicio: ArticulosService) {\n    this.recuperarTodos();\n  }\n\nLa clase ArticulosService está creada en el archivo 'articulos.service.ts':\nexport class ArticulosService {\n  ...  \n}\n\nrecuperarTodos tiene por objetivo utilizar el 'servicio' que llega al constructor para llamar al método 'recuperarTodos' del servicio propiamente dicho:\n  recuperarTodos() {\n    this.articulosServicio.recuperarTodos().subscribe((result:any) => this.articulos = result);\n  }\n\nSi vemos ahora el método 'recuperarTodos' de la clase 'ArticulosService', es el que tiene la responsabilidad de hacer una petición al servidor:\n  recuperarTodos() {\n    return this.http.get(`${this.url}recuperartodos.php`);\n  }\n\n\nEl método 'recuperarTodos' de la clase 'ArticulosService' retorna un objeto de la clase 'HttpClient'.\nAhora debemos entender porque podemos llamar al método 'suscribe':\n  recuperarTodos() {\n    this.articulosServicio.recuperarTodos().subscribe((result:any) => this.articulos = result);\n  }\n\nEl método 'suscribe' recibe los resultados y procedemos a asignar a la propiedad 'articulos', con esto, Angular se encarga de actualizar la página con todos los artículos recuperados. El proceso de actualizar la página sucede en el archivo 'app.component.html':\n<div>\n  <h1>Administración de artículos</h1>\n    <table border=\"1\">\n      <tr>\n        <td>Codigo</td><td>Descripcion</td><td>Precio</td><td>Borrar</td><td>Seleccionar</td>\n      </tr>\n      @for(art of articulos;track art.codigo) {\n      <tr>\n        <td>{{art.codigo}}</td>\n        <td>{{art.descripcion}}</td>\n        <td>{{art.precio}}</td>\n        <td><button (click)=\"baja(art.codigo)\">Borrar?</button></td>\n        <td><button (click)=\"seleccionar(art.codigo)\">Seleccionar</button></td>\n      </tr>\n    }\n    </table>\n    <div>\n      <p>\n        descripcion:<input type=\"text\" [(ngModel)]=\"art.descripcion\" />\n      </p>\n      <p>\n        precio:<input type=\"number\" [(ngModel)]=\"art.precio\" />\n      </p>\n      <p><button (click)=\"alta()\">Agregar</button>\n      <button (click)=\"modificacion()\">Modificar</button></p>\n    </div>\n</div>\n<router-outlet />\n\n\nEl flujo de la información lo podemos representar con el siguiente esquema:\n\n\n\nAlta\nVeamos ahora los pasos cuando se agrega una fila en la tabla 'articulos'.\nTodo comienza cuando el operador presiona el botón de 'Agregar':\n\n\nLa etiqueta button tiene enlazado la llamada al método 'alta':\n      <p><button (click)=\"alta()\">Agregar</button>\n\nEl método 'alta' se encuentra codificado en el archivo 'app.component.ts' dentro de la clase 'AppComponent':\n  alta() {\n    this.articulosServicio.alta(this.art).subscribe((datos:any) => {\n      if (datos['resultado']=='OK') {\n        alert(datos['mensaje']);\n        this.recuperarTodos();\n      }\n    });\n  }\nEn este método procedemos a llamar al método 'alta' de la clase 'ArticulosService' y se le pasa como parámetro la propiedad 'art' que almacena la descripción y precio del artículo que el operador acaba de ingresar por teclado.\nEl método 'alta' de la clase 'ArticulosService' hace la llamada al servidor mediante el objeto 'http' de la clase 'HttpClient'. Se utiliza el método 'post' ya que se enviarán datos al servidor:\n alta(articulo:any) {\n    return this.http.post(`${this.url}alta.php`, JSON.stringify(articulo));    \n }\n\nAhora se ejecuta el programa PHP definido en el archivo 'alta.php' donde procedemos a efectuar el insert en la tabla de MySQL:\n<?php \n  header('Access-Control-Allow-Origin: *'); \n  header(\"Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept\");\n  \n  $json = file_get_contents('php://input');\n \n  $params = json_decode($json);\n  \n  require(\"conexion.php\");\n  $con=retornarConexion();\n  \n\n  mysqli_query($con,\"insert into articulos(descripcion,precio) values\n                  ('$params->descripcion',$params->precio)\");\n    \n  \n  class Result {}\n\n  $response = new Result();\n  $response->resultado = 'OK';\n  $response->mensaje = 'datos grabados';\n\n  header('Content-Type: application/json');\n  echo json_encode($response);  \n?>\n\nTambién dentro del programa PHP procedemos a retornar en formato JSON que la operación se efectuó en forma correcta.\nEn el método 'alta' de la clase 'AppComponent' que ya vimos, recibe los datos de la respuesta JSon, mostrando un mensaje si la carga se efectuó correctamente:\n  alta() {\n    this.articulosServicio.alta(this.art).subscribe((datos:any) => {\n      if (datos['resultado']=='OK') {\n        alert(datos['mensaje']);\n        this.recuperarTodos();\n      }\n    });\n  }\n\nTambién llamamos al método 'recuperarTodos' con el objetivo que se actualice la pantalla con los datos actuales de la tabla 'articulos'.\nEl flujo de la información para efectuar el 'alta' de un articulo en la base de datos es::\n\nLa actualización de la página HTML la logramos llamando al método 'recuperarTodos'.\n\n\nBaja\nEl borrado de un artículo se efectúa cuando el operador presiona el botón con la etiqueta 'Borra?':\n        <td><button (click)=\"baja(art.codigo)\">Borrar?</button></td>\n\nSe llama al método 'baja' de la clase 'AppComponent' y se le pasa como parámetro el código de artículo a borrar.\nEl método baja:\n  baja(codigo:number) {\n    this.articulosServicio.baja(codigo).subscribe((datos:any) => {\n      if (datos['resultado']=='OK') {\n        alert(datos['mensaje']);\n        this.recuperarTodos();\n      }\n    });\n  }\n\nLlmamos al método 'baja' de la clase 'ArticulosService' y le pasamos como parámetro el código de artículo que queremos borrar.\nEl método 'baja' de la clase 'ArticulosService' procede a llamar al archivo baja.php y le pasa como parámetro el código de artículo que se debe borrar:\n  baja(codigo:number) {\n    return this.http.get(`${this.url}baja.php?codigo=${codigo}`);\n  }\n\nAhora en el servidor se ejecuta la aplicación PHP baja.php:\n<?php \n  header('Access-Control-Allow-Origin: *'); \n  header(\"Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept\");\n  \n  require(\"conexion.php\");\n  $con=retornarConexion();\n  \n  mysqli_query($con,\"delete from articulos where codigo=$_GET[codigo]\");\n    \n  \n  class Result {}\n\n  $response = new Result();\n  $response->resultado = 'OK';\n  $response->mensaje = 'articulo borrado';\n\n  header('Content-Type: application/json');\n  echo json_encode($response);  \n?>\n\n\nLuego en el método 'baja' de la clase 'AppComponent' podemos mostrar un mensaje si la baja se ejecutó con éxito:\n  baja(codigo:number) {\n    this.articulosServicio.baja(codigo).subscribe((datos:any) => {\n      if (datos['resultado']=='OK') {\n        alert(datos['mensaje']);\n        this.recuperarTodos();\n      }\n    });\n  }\nComo podemos ver para actualizar la pantalla procedemos a llamar al método 'recuperarTodos'.\n\n\n\nConsulta\nLa consulta o selección se dispara cuando el operador presiona el botón que tiene la etiqueta 'Seleccionar' y tiene por objetivo mostrar en los dos controles 'text' la descripción y precio del artículo:\n        <td><button (click)=\"seleccionar(art.codigo)\">Seleccionar</button></td>        \n\nAl presionar el botón se llama el método 'seleccionar' de la clase 'AppComponent':\n  seleccionar(codigo:number) {\n    this.articulosServicio.seleccionar(codigo).subscribe((result:any) => this.art = result[0]);\n  }\n\nAhora llamamos al método 'seleccionar' de la clase 'ArticulosService':\n  seleccionar(codigo:number) {\n    return this.http.get(`${this.url}seleccionar.php?codigo=${codigo}`);\n  }\n\nRecuperamos del servidor llamando a la página 'seleccionar.php' los datos del artículo cuyo código pasamos como parámetro :\n<?php \n  header('Access-Control-Allow-Origin: *'); \n  header(\"Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept\");\n  \n  require(\"conexion.php\");\n  $con=retornarConexion();\n\n  $registros=mysqli_query($con,\"select codigo, descripcion, precio from articulos where codigo=$_GET[codigo]\");\n    \n  if ($reg=mysqli_fetch_array($registros))  \n  {\n    $vec[]=$reg;\n  }\n  \n  $cad=json_encode($vec);\n  echo $cad;\n  header('Content-Type: application/json');\n?>\n\n\nLa ejecución del programa en PHP procede a recuperar la fila de la tabla que coincide con el código enviado y lo retorna con formato JSON.\nEn el método 'seleccionar' de la clase AppComponent al ejecutarse el método subscribe almacena en la propiedad 'art' el resultado devuelto por el servidor (con esta asignación se actualizan los dos controles 'input' del HTML):\n  seleccionar(codigo:number) {\n    this.articulosServicio.seleccionar(codigo).subscribe((result:any) => this.art = result[0]);\n  }\n\n\nModificación\nEl último algoritmo que implementa nuestra aplicación es la modificación de la descripción y precio de un artículo que seleccionemos primeramente.\nCuando presionamos el botón que tiene la etiqueta 'Modificar' se ejecuta el método 'modificación':\n      <button (click)=\"modificacion()\">Modificar</button></p>\n\nEl método 'modificación' se implementa en la clase 'AppComponent':\n  modificacion() {\n    this.articulosServicio.modificacion(this.art).subscribe((datos:any) => {\n      if (datos['resultado']=='OK') {\n        alert(datos['mensaje']);\n        this.recuperarTodos();\n      }\n    });    \n  }\n\nLo primero que hacemos en este método es llamar al método 'modificación' de la clase 'ArticulosService' y pasar como dato todos los datos del artículo seleccionado y las posibles modificaciones efectuadas.\nEl método 'modificacion' de la clase 'ArticulosService':\n  modificacion(articulo:any) {\n    return this.http.post(`${this.url}modificacion.php`, JSON.stringify(articulo));    \n  }\n\nAccede al servidor pidiendo el archivo 'modificacion.php' y pasando todos los datos del artículo mediante un 'post'.\nEl archivo 'modificacion.php' procede a cambiar la descripción y precio del artículo:\n<?php \n  header('Access-Control-Allow-Origin: *'); \n  header(\"Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept\");\n  \n  $json = file_get_contents('php://input');\n \n  $params = json_decode($json);\n  \n  require(\"conexion.php\");\n  $con=retornarConexion();\n  \n\n  mysqli_query($con,\"update articulos set descripcion='$params->descripcion',\n                                          precio=$params->precio\n                                          where codigo=$params->codigo\");\n    \n  \n  class Result {}\n\n  $response = new Result();\n  $response->resultado = 'OK';\n  $response->mensaje = 'datos modificados';\n\n  header('Content-Type: application/json');\n  echo json_encode($response);  \n?>\n\n\nEn la clase 'AppComponent' podemos comprobar si el resultado fue 'OK' y actualizar nuevamente la página:\n  modificacion() {\n    this.articulosServicio.modificacion(this.art).subscribe((datos:any) => {\n      if (datos['resultado']=='OK') {\n        alert(datos['mensaje']);\n        this.recuperarTodos();\n      }\n    });    \n  }\n\n\n\nHemos explicado con este problema todos los pasos esenciales para implementar una aplicación en Angular que se comunica con un servidor web con PHP y acceder a una base de datos MySQL.\nPuede probar funcionando esta aplicación de Angular desde aquí"
  },
  {
    "title": "28 - Pipes: definición",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=28&codigo=28&inicio=20",
    "content": "Las pipes también llamadas tuberías o filtros son funciones que se llaman en una vista (html) y que tienen por objetivo transformar un dato a mostrar para mejorar la experiencia del usuario.\nHay una cantidad reducida de pipes que trae por defecto Angular y podemos hacer uso en cualquier vistas de nuestras componentes. Lo más importante es que podemos crear nuestras propias pipes, lo veremos en el próximo concepto.\n\nLa llamada a estas funciones tiene una sintaxis muy distinta a la tradicional y su objetivo es hacer más claro la sintaxis de nuestra vista.\nPor ejemplo para mostrar el contenido de una variable toda en mayúsculas en la plantilla utilizamos la siguiente sintaxis:\n<p>Nombre del cliente:{{ nombre | uppercase}}</p>\n\nConsiderando que en la componente hemos definido la propiedad:\nnombre = 'Juan Carlos';\n\nLa salida en el navegador será:\nNombre del cliente:JUAN CARLOS\n\n\nComo vemos en la interpolación de la propiedad 'nombre' llamamos a la pipe después del caracter '|'.\nLa pipe 'uppercase' transforma a mayúsculas el dato que se muestra en la página, no se modifica la propiedad 'nombre'.\nEn algunas pipes podemos pasar parámetros:\n<p>El saldo es:{{ saldo | currency:'$'}}</p>\n\nSeguido al nombre de la pipe disponemos cada parámetro antecedido por el caracter ':'.\n\nPodemos aplicar una pipe directamente a un valor indicado en la vista:\n<p>{{ 'Hola' | uppercase }}</p>\n\nComo se trata de un string debemos indicarlo entre comillas. Luego cuando ejecutamos en el navegador tenemos como resultado 'HOLA'.\n\nProblema\nConfeccionar una aplicación que defina una serie de propiedades y muestre sus valores aplicando distintas pipes que trae por defecto Angular.\n\n\n\n\n\nDesde la línea de comandos de Node.js procedemos a crear el proyecto023:\nf:\\angularya> ng new proyecto023\n\n\n\n\nDefinimos ahora en la componente 'AppComponent' una serie de propiedades:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { UpperCasePipe, LowerCasePipe, CurrencyPipe, DatePipe, JsonPipe, SlicePipe } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, UpperCasePipe, LowerCasePipe, CurrencyPipe, DatePipe, JsonPipe, SlicePipe],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  nombre = 'Juan Carlos';\n  saldo = 1000.50;\n  dias = ['domingo', 'lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado'];\n  articulos = [{\n    codigo: 1,\n    descripcion: \"papas\",\n    precio: 12.33\n  }, {\n    codigo: 2,\n    descripcion: \"manzanas\",\n    precio: 54\n  }];\n  fechaActual = new Date();\n}\n\nDebemos importar las clases respectivas que contienen las tuberías:\nimport { UpperCasePipe, LowerCasePipe, CurrencyPipe, DatePipe, JsonPipe, SlicePipe } from '@angular/common';\n\n\nHemos definido 5 propiedades de distintos tipos: string, number, vector con los días, vector de artículos con objetos y un objeto de tipo Date.\nEl archivo de la vista 'app.component.html' queda con la siguiente sintaxis:\n<p>Nombre del cliente:{{ nombre }}</p>\n<p>Nombre del cliente en mayúsculas:{{ nombre | uppercase }}</p>\n<p>Nombre del cliente en minúsculas:{{ nombre | lowercase }}</p>\n<p>El saldo es:{{ saldo | currency:'$'}}</p>\n<p>Días laborables: {{ dias | slice:1:6}}</p>\n<p>{{ articulos | json }}</p>\n<p>Fecha actual:{{ fechaActual | date:'d/M/y' }}</p>\n<router-outlet />\n\nYa vimos las pipes: uppercase y lowercase:\n<p>Nombre del cliente en mayúsculas:{{ nombre | uppercase }}</p>\n<p>Nombre del cliente en minúsculas:{{ nombre | lowercase }}</p>\n\nPara mostrar un importe monetario podemos utilizar la pipe 'currency':\n<p>El saldo es:{{ saldo | currency:'$'}}</p>\n\nSi necesitamos mostrar parte de un vector podemos utilizar la pipe 'slice' e indicar en dos parámetros a partir de que índice recuperar los datos y hasta que índice:\n<p>Días laborables: {{ dias | slice:1:6}}</p>\n\nOtra pipe útil cuando tenemos que depurar programas es la impresión del contenido de una variable que almacena datos en formato JSON:\n<p>{{ articulos | json }}</p>\n\nFinalmente utilizamos la pipe 'date':\n<p>Fecha actual:{{ fechaActual | date:'d/M/y' }}</p>\n\n\n\n\nPara ver el resultado en el navegador ejecutamos la aplicación:\nf:\\angulardevya\\proyecto023> ng serve -o\n\nY tenemos como resultado en el navegador:\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "29 - Pipes: creación de pipes personalizadas",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=29&codigo=29&inicio=20",
    "content": "Vimos en el concepto anterior que una pipe tiene por objetivo convertir un dato en la vista de la componente (html) con la finalidad que el usuario tenga una mejor experiencia.\nEl framework Angular provee un conjunto de pipes por defecto como pueden ser: uppercase, lowercase, json, date etc\nPero lo más importante que tenemos es que Angular nos permite crear nuestras propias pipes que se adapten a resolver problemas de nuestra aplicación.\nVeremos los pasos para crear una pipe haciendo uso de la herramienta Angular CLI para facilitar su codificación.\nProblema\nCrear una pipe que permita transformar un valor entero comprendido entre 1 y 7 en un string en castellano de dicho número. Además permitir pasar un parámetro opcional indicando que muestre dicho valor en 'ingles' o 'portugues'.\n\n\n\n\nDesde la línea de comandos de Node.js procedemos a crear el proyecto024:\nf:\\angulardevya> ng new proyecto024\n\n\n\n\nPara crear una 'pipe' descendemos primero a la carpeta del proyecto que acabamos de crear y mediante angular Cli procedemos a ejecutar :\nf:\\angulardevya\\proyecto024> ng generate pipe letras\n\n\nLuego de esto tenemos creados dos archivos:\nletras.pipe.ts\nletras.pipe.spec.ts\n\n\n\n\nEl siguiente paso es codificar la clase 'LetrasPipe' que se encuentra almacenada en el archivo 'letras.pipe.ts':\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'letras'\n})\nexport class LetrasPipe implements PipeTransform {\n\n  transform(value: unknown, ...args: unknown[]): unknown {\n    return null;\n  }\n\n}\n\n\nEl método transform es el que se ejecuta cada vez que llamamos a la pipe 'letras' declarada en el decorador @Pipe.\nEl método transform recibe un parámetro obligatorio que es 'value' y puede ser de cualquier tipo (number, string, array, object etc.) y un segundo parámetro opcional.\nVeamos la lógica como implementar la pipe que transforme un valor entero comprendido entre 1 y 7 a letras:\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'letras'\n})\nexport class LetrasPipe implements PipeTransform {\n\n  transform(value: any, args?: any): any {\n    if (args != null) {\n      if (args=='ingles')\n        switch (value) {\n          case 1: return 'one';\n          case 2: return 'two';\n          case 3: return 'three';\n          case 4: return 'four';\n          case 5: return 'five';\n          case 6: return 'six';\n          case 7: return 'seven';                        \n        }\n        if (args=='portugues')\n        switch (value) {\n          case 1: return 'um';\n          case 2: return 'dois';\n          case 3: return 'três';\n          case 4: return 'quatro';\n          case 5: return 'cinco';\n          case 6: return 'seis';\n          case 7: return 'sete';                        \n        }        \n    }\n    switch (value) {\n      case 1: return 'uno';\n      case 2: return 'dos';\n      case 3: return 'tres';\n      case 4: return 'cuatro';\n      case 5: return 'cinco';\n      case 6: return 'seis';\n      case 7: return 'siete';                        \n    }  \n    return null;\n  }\n}\n\nEl parámetro 'value' recibe el valor que debe procesar la pipe. El parámetro 'args' puede no llegar en dicho caso almacena un null.\nSi en 'args' llega un null luego ejecuta el último switch de la función retornando en castellano el número almacenado en 'value'.\n\nLuego en la componente importamos la clase LetrasPipe y definimos por ejemplo un vector con los números del 1 al 7 ('app.component.ts'):\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { LetrasPipe } from './letras.pipe';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, LetrasPipe],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  vector = [1,2,3,4,5,6,7];\n}\n\n\nEn el archivo 'app.component.html' es donde hacemos uso de la pipe 'letras' que acabamos de crear:\n<h1>Números en castellano</h1>\n<ul>\n  @for(valor of vector;track valor) {\n  <li>\n    {{valor | letras}}\n  </li>\n  }\n</ul>\n<h1>Números en inglés</h1>\n<ul>\n  @for(valor of vector;track valor) {\n  <li>\n    {{valor | letras:'ingles'}}\n  </li>\n  }\n</ul>\n<h1>Números en portugués</h1>\n<ul>\n  @for(valor of vector;track valor) {\n  <li>\n    {{valor | letras:'portugues'}}\n  </li>\n  }\n</ul>\n<router-outlet />\n\n\n\n\nLa primer forma de llamar a la pipe sin parámetro es:\n    {{valor | letras}}\n\nDe esta forma tenemos en pantalla los valores de los números en castellano.\nEn el caso que le pasemos como parámetro alguno de los dos valores 'ingles' o 'portugues' tendremos como resultado la transformación del número a alguno de estos dos idiomas:\n    {{valor | letras:'ingles'}}\n\n\n\nY tenemos como resultado en el navegador:\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "30 - Compilación y despliegue de una aplicación Angular en un servidor de Internet",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=30&codigo=30&inicio=20",
    "content": "Cuando uno desarrolla una aplicación web utilizando el framework de Angular lo desarrolla y prueba en forma local. Cada cambio que desarrolla lo puede probar en forma local ejecutando el servidor de desarrollo que trae Angular:\nf:\\angulardevya\\proyecto024>ng serve -o\n\nUna vez finalizada la aplicación debemos subirla a nuestro servidor real en Internet, para esto debemos ejecutar el siguiente comando de Angular CLI:\nf:\\angulardevya\\proyecto024>ng build \n\nLuego de este proceso se genera una carpeta llamada 'dist' que contiene todos los archivos que debemos subir a nuestro servidor de Internet:\n\n\nLos archivos de esta carpeta se deben subir a la carpeta raíz de nuestro servidor de Internet, luego cuando accedemos al dominio de nuestro sitio:\nwww.misitio.com\n\nEl servidor responde devolviendo el archivo 'index.html' y este en su interior tiene todas las referencias a archivos *.js y *.css\n<!doctype html>\n<html lang=\"en\" data-critters-container>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Proyecto024</title>\n  <base href=\"/\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n<link rel=\"stylesheet\" href=\"styles-5INURTSO.css\"></head>\n<body>\n  <app-root></app-root>\n<script src=\"polyfills-LZBJRJJE.js\" type=\"module\"></script><script src=\"main-YZINELUB.js\" type=\"module\"></script></body>\n</html>\n\nSubir una aplicación Angular a una subcarpeta de nuestro servidor.\nSi nuestra aplicación Angular no se ejecutará en la raíz de nuestro servidor de Internet, el proceso de compilación es diferente.\nPor ejemplo si queremos cargar una aplicación Angular a la carpeta:\nhttp://ejerciciostutorialesya.com/angulardev/proyecto024/\n\nEl proceso de compilación debe ser:\nf:\\angulardevya\\proyecto024>ng build --base-href=/angulardev/proyecto024/\n \nUna vez construido el proyecto debemos subir todos los archivos a la carpeta /angulardev/proyecto024/ y ya podemos probar la aplicación:\naquí"
  },
  {
    "title": "31 - Herramienta Angular CLI",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=31&codigo=31&inicio=20",
    "content": "Una herramienta fundamental cuando desarrollamos proyectos es la aplicación Angular CLI, que la hemos utilizado desde el primer día.\nHemos visto que Angular CLI nos permite entre otras cosas:\n\n  Crear una aplicación de Angular (ng new proyecto001)\n  Ejecutar una aplicación Angular en forma local (ng serve -o)\n  Crear componentes (ng generate component dado)\n  Crear servicios (ng generate service articulos)\n  Crear tuberías (ng generate pipe letras)\n  Desplegar aplicaciones en producción (ng build)\n\n\nDebe tener siempre a mano la página que contiene la documentación oficial de \nAngular CLI.\nRecordemos que en el primer concepto de este curso lo primero que hicimos luego de instalar Node.js es la instalación de Angular.CLI mediante el comando:\nnpm install -g @angular/cli\n\n\nComandos útiles de Angular.CLI\n\nPara conocer todos los comandos disponibles de la herramienta Angular.CLI debemos ejecutar:\nng help\n\nTenemos como resultado muchos de los comandos ya vistos y utilizados en conceptos anteriores:\n\nSi por ejemplo queremos ver la versión de Angular.CLI que tenemos instalada en nuestra computadora debemos ejecutar:\nng version"
  },
  {
    "title": "32 - Herramienta Angular CLI - comando: ng new",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=32&codigo=32&inicio=20",
    "content": "Hemos visto que con el comando 'new' de la herramienta Angular CLI se crea un esqueleto de una aplicación Angular:\nng new proyecto025\n\nDurante la generación del proyecto se nos consulta como queremos administrar las hojas de estilo (por defecto archivos CSS):\n\nSeguidamente se nos cuestiona si queremos activar el renderizado en el servidor (por defecto si presionamos la tecla enter se selecciona que NO queremos):\n\n\n\n\nEl comando new podemos pasar otros parámetros para adaptar la aplicación generada.\n\n\n\nPodemos especificar el prefijo a los selectores generados mediante el parámetro --prefix:\nng new proyecto025 --prefix ele\n\nLuego se crea con prefijo 'ele' en lugar del valor por defecto 'app':\nSi abrimos la componente creada por defecto podemos ver que el prefijo es 'ele':\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'ele-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  title = 'proyecto025';\n}\n\nEn lugar de 'app':\n  selector: 'app-root'\n\nLuego si creamos una componente dentro del proyecto también se respetará el prefijo definido en la creación del proyecto:\nng generate component dado\n\nEl selector de la componente dado queda con el siguiente nombre:\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'ele-dado',\n  imports: [],\n  templateUrl: './dado.component.html',\n  styleUrl: './dado.component.css'\n})\nexport class DadoComponent {\n\n}\n\nLa definición de prefijos en las componentes de Angular permiten diferenciar las etiquetas nativas del navegador (ej. 'button') con las etiquetas propias de Angular (ej. ele-button)\nAl crearse  un proyecto uno de los archivos fundamentales que almacenan datos de configuración del mismo es 'angular.json' (se encuentra en la carpeta raíz del proyecto)\nEn el archivo 'angular.json' se encuentra almacenado el prefijo definido al crearse el proyecto:\n\nSi queremos escribir menos con Angular CLI al crear el proyecto podemos utilizar el alias -p en lugar de --prefix:\nng new proyecto025 -p ele\n\n\n\nMediante el parámetro --inline-style (alias: -s) podemos evitar que se cree el archivo *.css y la definición de los estilos se deba hacer directamente en el archivo *.ts:\nng new proyecto025 --inline-style\n\nCon esto no se crearán los archivos *.css para las componentes. El archivo *.ts de la componente tienen un lugar donde definir los estilos:\n\nPuede tener sentido si la componente es bastante sencilla y no requiere la definición de una hoja de estilo compleja.\nProbar modificar los archivos *.ts y *.html de la componente del proyecto.\napp.component.ts\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styles: ['.titulo { color:red; font-size:2rem }',\n    '.parrafo {color:black; font-size:1.1rem }'],\n})\nexport class AppComponent {\n  tit = 'Prueba de inline-style';\n}\n\n\napp.component.html\n<div style=\"text-align:center\">\n  <h1 class=\"titulo\">{{tit}}</h1>\n  <p class=\"parrafo\">Esto es un párrafo.</p>\n</div>\n\n<router-outlet />\n\nSi ejecutamos el proyecto podemos ver que los estilos se están recuperando del archivo *.ts:\n\n\n\n\nMediante el parámetro --inline-template (alias: -s) podemos evitar que se cree el archivo *.html y la definición del HTML se hace directamente en el archivo *.ts (borre primero el proyecto025 antes de crearlo nuevamente con esta nueva configuración):\nng new proyecto025 --inline-template\n\nCon este parámetro estamos indicando que no se cree el archivo *.html para la componente y la definición del HTML se haga en el mismo archivo *.js\nLuego de creado el proyecto solo se han creado los archivos *.css y *.ts:\n\nNuevamente decimos que esto tiene sentido si la complejidad de la componente Angular no es grande.\nPodemos inclusive evitar que se creen tanto el archivo *.css y *.html indicando ambos parámetros al crear la componente:\nng new proyecto025 --inline-style --inline-template\n\n\n\n\nSi tratamos de crear un proyecto y ya existe uno en la carpeta actual se produce un error al ejecutar:\nng new proyecto025\n\nSi queremos forzar la creación del proyecto y sobreescribir los archivos actuales debemos añadir el parámetro --force (alias -f):\nng new proyecto025 --force\n\n\n\n\nSi por algún motivo no queremos que Angular.CLI nos genere el archivo de test debemos pasar el parámetro --skip-tests (alias -s):\nng new proyecto025 --skip-tests\n\n\nComo podemos comprobar no se ha generado el archivo 'app.component.spec.ts'.\n\n\n\nOtro parámetro más que podemos utilizar cuando vamos a crear un proyecto es --dry-run (alias: -d)\nMediante esta opción Angular CLI nos informa que archivos se crearán (no los crea) y a partir de estos datos poder tomar la decisión de crear o no el proyecto:\nng new proyecto025 --dry-run"
  },
  {
    "title": "33 - Herramienta Angular CLI - comando: ng generate",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=33&codigo=33&inicio=20",
    "content": "Otro comando que hemos utilizado a lo largo de los primeros conceptos de este curso de Angular es 'generate'.\nMediante el comando 'generate' de la herramienta Angular CLI podemos crear:\n\n\ncomponent\nservice\nmodule\npipe\nclass\ninterface\nenum\ndirective\napplication\nlibrary\nguard\nservice-worker\nweb-worker\nresolver\ninterceptor\napp-shell\n\n\nng generate component\nMediante el comando:\nng generate component dado\n\nSe crea una componente 'dado' con los archivos respectivos.\nSe informa en la consola los archivos creados:\n\n\nPodemos pasar varias opciones cuando creamos la componente:\nng generate component dado --inline-style\n\nEvita que se  cree el archivo dado.component.css\nLo mismo podemos evitar que se cree el archivo HTML:\nng generate component dado --inline-template\n\nTenemos como resultado la no creación del archivo HTML:\n\nPodemos definir el prefijo para la componente mediante la opción --prefix (alias: -p):\nng generate component dado --prefix juego\n\nLuego la componente que se crea tiene dicho prefijo:\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'juego-dado',\n  imports: [],\n  templateUrl: './dado.component.html',\n  styleUrl: './dado.component.css'\n})\nexport class DadoComponent {\n\n}\n\nSi queremos definir el nombre completo para el selector tenemos la opción --selector:\nng generate component dado --selector ju-dado\n\nLuego la componente se crea con dicho nombre de selector:\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'ju-dado',\n  imports: [],\n  templateUrl: './dado.component.html',\n  styleUrl: './dado.component.css'\n})\nexport class DadoComponent {\n\n}\n\n\n\nPara evitar que se cree el archivo 'dado.spec.js' debemos insertar el comando --skip-tests:\nng generate component dado --skip-tests\n\nLuego no se genera el archivo 'dado.spec.js'.\n\nTengamos en cuenta que todas estas opciones se pueden combinar y ejecutar en forma simultanea, por ejemplo si queremos generar solo el archivo *.ts de la componente y que no genere el archivo spec, *.css y *.html:\nng generate component dado --skip-tests --inline-template --inline-style\n\n\nOtras opciones posibles cuando creamos una componente son: \n\n\n--force (alias: -f) Forzar la sobrescritura de los archivos existentes (se borra la componente anterior que tiene el mismo nombre)\n\n\n--dry-run (alias: -d) Informa los archivos que se crearán sin hacer dicha actividad.\n\n\n\nAngular CLI permite ingresar comandos en formato resumido utilizando el primer caracter:\nng g c dado\n\nEn lugar de escribir:\nng generate component dado\n\n\n\nng generate service\nMediante el comando:\nng generate service articulos\n\nSe crea una clase ArticulosService y se inyecta a nivel de 'root':\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ArticulosService {\n\n  constructor() { }\n}\n\n\nDisponemos de los siguientes opciones en este comando:\n\n--dry-run\n--force\n--skip-tests\n\n\nng generate pipe\nMediante el comando:\n ng generate pipe letras\n\nSe genera el archivo 'letras.pipe.ts':\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'letras'\n})\nexport class LetrasPipe implements PipeTransform {\n\n  transform(value: unknown, ...args: unknown[]): unknown {\n    return null;\n  }\n\n}\n\nDisponemos de los siguientes opciones en este comando:\n\n--dry-run\n--force\n--skip-tests\n\n\n\nng generate class\nMediante el comando:\n ng generate class articulo\n\nSe crea el archivo 'articulo.ts':\nexport class Articulo {\n}\n\n\n\nng generate interface\nMediante el comando:\n ng generate interface venta\n\nSe crea el archivo 'venta.ts':\nexport interface Venta {\n}\n\n\nng generate enum\nMediante el comando:\n ng generate enum operaciones\n\nSe crea el archivo 'operaciones.enum.ts':\nexport enum Operaciones {\n}"
  },
  {
    "title": "34 - Herramienta Angular CLI - comando: ng serve",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=34&codigo=34&inicio=20",
    "content": "Otro comando que hemos utilizado en cada uno de los proyectos que hemos implementado es 'serve' (desde el principio hemos utilizado la opción -o):\nng serve -o\n\nRecordemos que debemos ejecutar el comando serve en la carpeta donde se haya nuestra aplicación Angular. Al disponer la opción -o se abre automáticamente el navegador web. La sintaxis larga pero que produce la misma acción es:\nng serve --open\n\n\nPara conocer todas las opciones disponibles en un comando de Angular CLI debemos acceder a la opción --help:\nng serve --help\n\n\n\nOpción --port\nPor defecto el servidor web local que crea Angular CLI se ejecuta en el puerto 4200, si necesitamos que el servidor web se ejecute en otro puerto podemos indicarlo con la opción --port en el momento de iniciarlo:\nng serve -o --port 4444\n\n\n\n\n\nOpción --watch (alias: -w)\nPor defecto cada vez que modificamos nuestro proyecto y grabamos los cambios el resultado se actualiza en el navegador en forma automática. En algunas situaciones si queremos que no se actualice debemos utilizar la opción 'watch' pasando el valor false:\nng serve -o --watch false"
  },
  {
    "title": "35 - Estructura y nombres de archivos y carpetas de un proyecto Angular - Carpeta raiz",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=35&codigo=35&inicio=20",
    "content": "Hemos trabajado por un tiempo desarrollando ejercicios con el framework de Angular 19, pero no nos hemos detenido para analizar en profundidad los archivos y carpetas que se generan cada vez que creamos un proyecto.\nPana analizar los archivos y carpetas crearemos un nuevo proyecto:\nng new proyecto026\n\nLo primero que puede variar esta estructura son que decisiones tomamos para indicar si queremos utilizar formato de hojas de estilo y Server-Side rendering (seleccionemos los datos por defecto es decir CSS y no Server-Side rendering):\n\nSi analizamos el contenido de la carpeta que se crea 'proyecto026' nos puede intimidar la cantidad de carpetas y archivos que contiene:\n\nLa carpeta 'proyecto026' creada con Angular 19 tiene 9 archivos y 4 carpetas:\n\n\nArchivos de la raiz del proyecto\n\n  .editorconfig Este archivo define estilos de codificación consistentes para múltiples desarrolladores que trabajan en el mismo proyecto con editores de texto distinto. No hay problemas de estilo si un desarrollador utiliza el VS Code y otro el Sublime Text, ya que ambos editores tomarán en cuenta las definiciones contenidas en .editorconfig:\n# Editor configuration, see https://editorconfig.org\nroot = true\n\n[*]\ncharset = utf-8\nindent_style = space\nindent_size = 2\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n[*.ts]\nquote_type = single\n\n[*.md]\nmax_line_length = off\ntrim_trailing_whitespace = false\n\nPara modificar este archivo podemos consultar el sitio que define su estándar editorconfig.org\n\n\n\n  .gitignore Especifica los archivo y carpetas que debe ignorar el sistema de control de versiones (Git) \n  # See http://help.github.com/ignore-files/ for more about ignoring files.\n\n# Compiled output\n/dist\n/tmp\n/out-tsc\n/bazel-out\n\n# Node\n/node_modules\nnpm-debug.log\nyarn-error.log\n\n# IDEs and editors\n.idea/\n.project\n.classpath\n.c9/\n*.launch\n.settings/\n*.sublime-workspace\n\n# Visual Studio Code\n.vscode/*\n!.vscode/settings.json\n!.vscode/tasks.json\n!.vscode/launch.json\n!.vscode/extensions.json\n.history/*\n\n# Miscellaneous\n/.angular/cache\n.sass-cache/\n/connect.lock\n/coverage\n/libpeerconnection.log\ntestem.log\n/typings\n\n# System files\n.DS_Store\nThumbs.db\n\n\n\n\n  angular.json Se definen valores por defecto para la configuración del proyecto para las herramientas de compilación y desarrollo:\n{\n  \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\",\n  \"version\": 1,\n  \"newProjectRoot\": \"projects\",\n  \"projects\": {\n    \"proyecto026\": {\n      \"projectType\": \"application\",\n      \"schematics\": {},\n      \"root\": \"\",\n      \"sourceRoot\": \"src\",\n      \"prefix\": \"app\",\n      \"architect\": {\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:application\",\n          \"options\": {\n            \"outputPath\": \"dist/proyecto026\",\n            \"index\": \"src/index.html\",\n            \"browser\": \"src/main.ts\",\n            \"polyfills\": [\n              \"zone.js\"\n            ],\n            \"tsConfig\": \"tsconfig.app.json\",\n            \"assets\": [\n              {\n                \"glob\": \"**/*\",\n                \"input\": \"public\"\n              }\n            ],\n            \"styles\": [\n              \"src/styles.css\"\n            ],\n            \"scripts\": []\n          },\n          \"configurations\": {\n            \"production\": {\n              \"budgets\": [\n                {\n                  \"type\": \"initial\",\n                  \"maximumWarning\": \"500kB\",\n                  \"maximumError\": \"1MB\"\n                },\n                {\n                  \"type\": \"anyComponentStyle\",\n                  \"maximumWarning\": \"4kB\",\n                  \"maximumError\": \"8kB\"\n                }\n              ],\n              \"outputHashing\": \"all\"\n            },\n            \"development\": {\n              \"optimization\": false,\n              \"extractLicenses\": false,\n              \"sourceMap\": true\n            }\n          },\n          \"defaultConfiguration\": \"production\"\n        },\n        \"serve\": {\n          \"builder\": \"@angular-devkit/build-angular:dev-server\",\n          \"configurations\": {\n            \"production\": {\n              \"buildTarget\": \"proyecto026:build:production\"\n            },\n            \"development\": {\n              \"buildTarget\": \"proyecto026:build:development\"\n            }\n          },\n          \"defaultConfiguration\": \"development\"\n        },\n        \"extract-i18n\": {\n          \"builder\": \"@angular-devkit/build-angular:extract-i18n\"\n        },\n        \"test\": {\n          \"builder\": \"@angular-devkit/build-angular:karma\",\n          \"options\": {\n            \"polyfills\": [\n              \"zone.js\",\n              \"zone.js/testing\"\n            ],\n            \"tsConfig\": \"tsconfig.spec.json\",\n            \"assets\": [\n              {\n                \"glob\": \"**/*\",\n                \"input\": \"public\"\n              }\n            ],\n            \"styles\": [\n              \"src/styles.css\"\n            ],\n            \"scripts\": []\n          }\n        }\n      }\n    }\n  }\n}\n\n\"prefix\": \"app\"     \n\n\"prefix\" es una cadena que Angular antepone a los selectores generados. Por ejemplo la componente por defecto que se crea:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  title = 'proyecto026';\n}\n\nSi creamos una componente llamada 'dado' luego su selector toma el nombre 'app-dado':\n@Component({\n  selector: 'app-dado',\n  imports: [],\n  templateUrl: './dado.component.html',\n  styleUrl: './dado.component.css'\n})\nexport class DadoComponent {\n\n}\n\nLa carpeta raíz para los archivos fuente del proyecto esta definido en:\n\"sourceRoot\": \"src\"\n\n\nEn la entrada \"assets\" hacemos referencia a los archivos estáticos del proyecto y las carpetas donde se almacenan, recordemos en el problema donde necesitabamos insertar archivos *.jpg los cargamos en la carpeta 'assets':\n \"assets\": [\n              \"src/favicon.ico\",\n              \"src/assets\"\n            ],\n\nEn la entrada styles especificamos todos los archivos de hoja de estilo globales al proyecto (styles.css es uno que se ha creado por defecto):\n            \"styles\": [\n              \"src/styles.css\"\n            ],\n\nPor ejemplo si queremos tener acceso solo a la hoja de estilo de BootStrap 'bootstrap.min.css', solo debemos copiar dicho archivo en la carpeta 'src' o una subcarpeta de la misma y especificar su path:\n            \"styles\": [\n              \"src/styles.css\",\n              \"src/bootstrap.min.css\"\n            ],\n\n\nEn la entrada scripts especificamos los archivos de script JavaScript para agregar al contexto global del proyecto:\n            \"scripts\": []\n\nPor ejemplo si queremos tener acceso al archivo JavaScript de BootStrap 'bootstrap.min.js', debemos copiar dicho archivo y el jquery en la carpeta 'src' o una subcarpeta de la misma y especificar su path:\n            \"scripts\": [\"src/jquery-3.4.1.min.js\",\n              \"src/bootstrap.min.js\"]\n\nEl orden en que los listamos es importante, primero debe ser el jquery y seguidamente el bootstrap.min.js (según sus dependencias, en este caso BootStrap depende de la librería JQuery)\n\n\n\n\n\n  package.json Configura las dependencias del paquete npm que están disponibles para todos los proyectos en el espacio de trabajo.\n{\n  \"name\": \"proyecto026\",\n  \"version\": \"0.0.0\",\n  \"scripts\": {\n    \"ng\": \"ng\",\n    \"start\": \"ng serve\",\n    \"build\": \"ng build\",\n    \"watch\": \"ng build --watch --configuration development\",\n    \"test\": \"ng test\"\n  },\n  \"private\": true,\n  \"dependencies\": {\n    \"@angular/animations\": \"^19.0.0\",\n    \"@angular/common\": \"^19.0.0\",\n    \"@angular/compiler\": \"^19.0.0\",\n    \"@angular/core\": \"^19.0.0\",\n    \"@angular/forms\": \"^19.0.0\",\n    \"@angular/platform-browser\": \"^19.0.0\",\n    \"@angular/platform-browser-dynamic\": \"^19.0.0\",\n    \"@angular/router\": \"^19.0.0\",\n    \"rxjs\": \"~7.8.0\",\n    \"tslib\": \"^2.3.0\",\n    \"zone.js\": \"~0.15.0\"\n  },\n  \"devDependencies\": {\n    \"@angular-devkit/build-angular\": \"^19.0.2\",\n    \"@angular/cli\": \"^19.0.2\",\n    \"@angular/compiler-cli\": \"^19.0.0\",\n    \"@types/jasmine\": \"~5.1.0\",\n    \"jasmine-core\": \"~5.4.0\",\n    \"karma\": \"~6.4.0\",\n    \"karma-chrome-launcher\": \"~3.2.0\",\n    \"karma-coverage\": \"~2.2.0\",\n    \"karma-jasmine\": \"~5.1.0\",\n    \"karma-jasmine-html-reporter\": \"~2.1.0\",\n    \"typescript\": \"~5.6.2\"\n  }\n}\n\nEl archivo se organiza indicando primero en la propiedad \"dependencies\" todos los paquetes requeridos para la aplicación que estamos desarrollando, y en segundo lugar en la propiedad \"devDepencencies\" se hace referencia a todos los paquetes requeridos para desarrollar la aplicación.\nLos paquetes que se declaran en el archivo corresponden a:\n\nPaquetes de Angular: núcleo angular y módulos opcionales; comienzan los nombres de sus paquetes @angular/\nPaquetes de soporte : bibliotecas de terceros que deben estar presentes para que se ejecuten las aplicaciones de Angular\nPaquetes Polyfill : Polyfills tapan huecos en la implementación de JavaScript que no disponen algunos navegadores.\n\n\n\n\n\n\n\n\n\n\n  package-lock.json  Proporciona información de versión para todos los paquetes instalados en la carpeta node_modules por el cliente npm (no lo mostramos ya que tiene más de 15000 líneas)\n\n\n\n  tsconfig.json Especifica la configuración predeterminada del lenguaje TypeScript para proyectos en el espacio de trabajo.\n/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */\n/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */\n{\n  \"compileOnSave\": false,\n  \"compilerOptions\": {\n    \"outDir\": \"./dist/out-tsc\",\n    \"strict\": true,\n    \"noImplicitOverride\": true,\n    \"noPropertyAccessFromIndexSignature\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"skipLibCheck\": true,\n    \"isolatedModules\": true,\n    \"esModuleInterop\": true,\n    \"experimentalDecorators\": true,\n    \"moduleResolution\": \"bundler\",\n    \"importHelpers\": true,\n    \"target\": \"ES2022\",\n    \"module\": \"ES2022\"\n  },\n  \"angularCompilerOptions\": {\n    \"enableI18nLegacyMessageIdFormat\": false,\n    \"strictInjectionParameters\": true,\n    \"strictInputAccessModifiers\": true,\n    \"strictTemplates\": true\n  }\n}\n\n\n\n\n  tsconfig.spec.json Configuración de TypeScript para las pruebas de aplicación.  \n/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */\n/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./out-tsc/spec\",\n    \"types\": [\n      \"jasmine\"\n    ]\n  },\n  \"include\": [\n    \"src/**/*.spec.ts\",\n    \"src/**/*.d.ts\"\n  ]\n}\n\n\n\n\n\n\n  tsconfig.app.json  Configuración de TypeScript específica de la aplicación , incluidas las opciones de compilación de plantillas de TypeScript y Angular.  \n/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */\n/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./out-tsc/app\",\n    \"types\": []\n  },\n  \"files\": [\n    \"src/main.ts\"\n  ],\n  \"include\": [\n    \"src/**/*.d.ts\"\n  ]\n}\n\n\n\n\n  README.md   Primer archivo que deberíamos leer cuando accedemos a un proyecto nuevo.\n# Proyecto026\n\nThis project was generated using [Angular CLI](https://github.com/angular/angular-cli) version 19.0.2.\n\n## Development server\n\nTo start a local development server, run:\n\n```bash\nng serve\n```\n\nOnce the server is running, open your browser and navigate to `http://localhost:4200/`. The application will automatically reload whenever you modify any of the source files.\n\n## Code scaffolding\n\nAngular CLI includes powerful code scaffolding tools. To generate a new component, run:\n\n```bash\nng generate component component-name\n```\n\nFor a complete list of available schematics (such as `components`, `directives`, or `pipes`), run:\n\n```bash\nng generate --help\n```\n\n## Building\n\nTo build the project run:\n\n```bash\nng build\n```\n\nThis will compile your project and store the build artifacts in the `dist/` directory. By default, the production build optimizes your application for performance and speed.\n\n## Running unit tests\n\nTo execute unit tests with the [Karma](https://karma-runner.github.io) test runner, use the following command:\n\n```bash\nng test\n```\n\n## Running end-to-end tests\n\nFor end-to-end (e2e) testing, run:\n\n```bash\nng e2e\n```\n\nAngular CLI does not come with an end-to-end testing framework by default. You can choose one that suits your needs.\n\n## Additional Resources\n\nFor more information on using the Angular CLI, including detailed command references, visit the [Angular CLI Overview and Command Reference](https://angular.dev/tools/cli) page."
  },
  {
    "title": "36 - Estructura y nombres de archivos y carpetas de un proyecto Angular - Carpeta 'src'",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=36&codigo=36&inicio=20",
    "content": "La carpeta 'src' (source) depende directamente de la carpeta raiz del proyecto y contiene en su interior 1 carpetas y 3 archivos:\n\n\nArchivos de la carpeta 'src'\n\n\n  index.html Es la página HTML principal que se sirve cuando alguien visita el sitio web. Angular CLI agrega automáticamente todos los archivos JavaScript y CSS al compilar la aplicación, por lo que generalmente no necesita agregar ningún <script>o <link>.\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Proyecto026</title>\n  <base href=\"/\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n</head>\n<body>\n  <app-root></app-root>\n</body>\n</html>\n\nSi ejecutamos la aplicación y vemos el código que llega al navegador nos encontraremos un contenido similar a este (se agregan una serie de archivos *.js):\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <script type=\"module\" src=\"/@vite/client\"></script>\n\n  <meta charset=\"utf-8\">\n  <title>Proyecto026</title>\n  <base href=\"/\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n<link rel=\"stylesheet\" href=\"styles.css\"></head>\n<body>\n  <app-root></app-root>\n<script src=\"polyfills.js\" type=\"module\"></script><script src=\"main.js\" type=\"module\"></script></body>\n</html>\n\n\n\nPodemos analizar que en el archivo original en el body se inserta una etiqueta de tipo 'app-root'. Esta etiqueta hace referencia a la única componente que se ha creado en forma automática y se encuentra almacenada en la carpeta hija llamada 'app' donde si abrimos el archivo 'app.component.ts' nos encontramos definido en la propiedad 'selector' el nombre de la etiqueta 'app-root':\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'proyecto026';\n}\n\nSi borraramos de la sección del body del archivo 'index.html' la etiqueta 'app-root' y lanzamos la aplicación, veremos que aparece una página web vacía.\n\n\n\n\n  styles.css En este archivo definimos la hoja de estilo global del proyecto.\n\n\n\n\n  main.ts Este archivo es el punto de entrada principal para la aplicación Angular: \nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { appConfig } from './app/app.config';\nimport { AppComponent } from './app/app.component';\n\nbootstrapApplication(AppComponent, appConfig)\n  .catch((err) => console.error(err));\n\nSe llama a la función bootstrapApplication y le pasamos en el primer parámetro la referencia de la componente principal."
  },
  {
    "title": "37 - Estructura y nombres de archivos y carpetas de un proyecto Angular - Carpeta 'app'",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=37&codigo=37&inicio=20",
    "content": "Después de haber trabajado con muchos ejercicios podemos tener una idea de como se organizan las carpetas y archivos en un proyecto Angular.\nLa carpeta 'app' depende directamente de la carpeta 'src' y contiene en su interior 6 archivos:\n\n\nArchivos de la carpeta 'app'\n\n\n  app.component.ts Define la lógica para el componente raíz de la aplicación, llamado AppComponent:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n})\nexport class AppComponent {\n  title = 'proyecto026';\n}\n\nHay que tener en cuenta que la clase se llama 'AppComponent' y tiene asociado el selector 'app-root' que es el que hacemos referencia en el archivo index.html.\nAngular CLI crea en forma automática esta clase y define en su interior un atributo llamado 'title' y se le asigna un string que coincide con el nombre del proyecto que creamos con el comando 'ng new proyecto037'\n\n\n\n  app.component.html Define la plantilla HTML asociada con la clase AppComponent. El contenido original tiene más de 300 líneas y seguramente lo eliminaremos para crear la interfaz visual de la componente raiz de nuestra aplicación.\nPor ejemplo podemos modificar y disponer que muestre el nombre del proyecto dentro de una etiqueta HTML h1:\n<h1>{{title}}</h1>\n<router-outlet />\n\n\n\n\n\n  app.component.css Define la hoja de estilo que se aplica solo a dicha componente. Angular CLI crea este archivo vacío.\n\n\n\n\n  app.component.spec.ts Se definen las pruebas unitarias para la componente 'AppComponent'\nimport { TestBed } from '@angular/core/testing';\nimport { AppComponent } from './app.component';\n\ndescribe('AppComponent', () => {\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      imports: [AppComponent],\n    }).compileComponents();\n  });\n\n  it('should create the app', () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.componentInstance;\n    expect(app).toBeTruthy();\n  });\n\n  it(`should have the 'proyecto026' title`, () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.componentInstance;\n    expect(app.title).toEqual('proyecto026');\n  });\n\n  it('should render title', () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    fixture.detectChanges();\n    const compiled = fixture.nativeElement as HTMLElement;\n    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, proyecto026');\n  });\n});\n\n\n\n\n\n\n  app.routes.ts El archivo contiene un arreglo de tipo Routes con todas las rutas de nuestra aplicación, por defecto el arreglo se encuentra vacío.\nimport { Routes } from '@angular/router';\n\nexport const routes: Routes = [];\n\n\n\n\n  app.config.ts Lista de proveedores que deberían estar disponibles para el componente raíz y todos sus hijos.\nimport { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';\nimport { provideRouter } from '@angular/router';\n\nimport { routes } from './app.routes';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes)]\n};"
  },
  {
    "title": "38 - Estructura y nombres de archivos y carpetas de un proyecto Angular - Carpeta 'public'",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=38&codigo=38&inicio=20",
    "content": "A partir de la versión 18 de Angular se crea por defecto la carpeta public conteniendo el archivo 'favicon.ico'.\nEn la carpeta public disponemos archivos de imágenes, videos y otros archivos (por ejemplo si tenemos una serie de archivos pdf que se descargan de nuestra aplicación) que se copiarán tal cual en la aplicación definitiva.\nLa carpeta public en una carpeta hija del proyecto propiamente dicho:\n\nPodemos organizar en esta carpeta, subcarpetas agrupando las imágenes, videos y otros archivos. Crearemos una carpeta llamada 'paises' dentro de la carpeta 'public' e insertamos 3 imágenes de banderas de dichos paises:\n\nLuego accedemos a las mismas indicando el siguiente camino:\n<img src=\"/paises/uruguay.png\">\n\nPor ejemplo podríamos disponer una serie de documentos *.docx para ser descargados desde el sitio:\n\nLuego accedemos a los documentos para ser descargados con el siguiente camino:\n<a href=\"/documentos/documento1.docx\">Documento 1</a>\n\n\nCuando compilamos la aplicación de Angular el contenido de la carpeta 'public' queda sin cambios y debe ser subida al servidor de internet junto con el resto de archivos.\n\nLuego de compilar la aplicación se genera la carpeta 'dist' en la raiz del proyecto, si vemos su contenido nos encontramos que tenemos una copia con todo el contenido de la carpeta 'public':"
  },
  {
    "title": "39 - Estructura y nombres de archivos y carpetas de un proyecto Angular - Carpetas '<Nombre del proyecto>\\dist'",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=39&codigo=39&inicio=20",
    "content": "Las carpetas '<Nombre del proyecto>\\dist' no se generan inmediatamente al crear un proyecto Angular, sino cuando compilamos por primera vez:\nng build \n\nLuego de compilar el proyecto Angular por primera vez podemos ver que se han generado las carpetas 'proyecto36\\dist' dependiendo de la raiz:\n\nDentro de la carpeta 'proyecto37' se localizan todos los archivos y carpeta 'assets' que deben ser subidos al servidor web.\n\n\nindex.html El archivo index.html no es exactamente el mismo archivo que se encuentra en la raiz del proyecto, sino con los script necesarios de la aplicación Angular:\n<!doctype html>\n<html lang=\"en\" data-critters-container>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Proyecto026</title>\n  <base href=\"/angulardev/proyecto026/\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n<link rel=\"stylesheet\" href=\"styles-5INURTSO.css\"></head>\n<body>\n  <app-root></app-root>\n<script src=\"polyfills-LZBJRJJE.js\" type=\"module\"></script><script src=\"main-BYMF447A.js\" type=\"module\"></script></body>\n</html>\n\nSi analizamos el código añadido podemos ver que se han agregado etiquetas 'script'.\n\n\n\n\nstyles.xxxxxxxx.css Contiene una copia de la hoja de estilo global del proyecto (borra saltos de línea y espacios en blanco para reducir su tamaño), recordemos que se almacena en la carpeta 'src' el archivo 'styles.css'.\n\n\n\nmainxxxxxx.js Contiene el código JavaScript de la aplicación.\n\n\n\npolyfillsxxxxxx.js Contiene más código JavaScript de la aplicación.\n\n\n\n\nfavicon.ico Es la copia del archivo que se encuentra en la carpeta raiz del proyecto.\n\n\n\n\n3rdpartylicenses.txt Contiene las licencias de todos los módulos de terceros utilizados en el proyecto:"
  },
  {
    "title": "40 - Estructura y nombres de archivos y carpetas de un proyecto Angular - Carpeta node_modules",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=40&codigo=40&inicio=20",
    "content": "El framework de Angular, el gestor de línea de comandos Angular CLI y todas las componentes que implementamos y utilizamos de otros desarrolladores (por ejemplo Angular Material) son empaquetadas utilizando el software npm (node package manager - es el sistema de gestión de paquetes por defecto para Node.js y maneja las dependencias para una aplicación)\nLos paquetes utilizando npm se descargan en la carpeta 'node_modules':\n\n\nPor ejemplo en la versión 19 de Angular cuando creamos un proyecto tenemos en principio 555 carpetas que dependen directamente de la carpeta nodo_modules (y cada carpeta tiene subcarpetas) y a medida que instalemos otros recursos (por ejemplo Angular Material) esta cantidad crecerá.\nHay que tener bien en claro que todos estas carpetas no se instalarán en la aplicación web que desarrollemos, muchas son requeridas por el framework de Angular, otras para las pruebas de integración en Angular, otras para las pruebas unitarias etc.\n\nEsta carpeta si la borramos completamente, la podemos recrear en forma exacta mediante el comando (nos tenemos que posicionar en la carpeta que contiene el archivo package.json):\nnpm install\n\nEs por ello si tenemos que enviarnos el proyecto por email por ejemplo no es necesario incorporar todos los archivos de esta carpeta, ya que los podemos recrear.\n\nEl archivo 'package.json' que se encuentra en la carpeta raiz de nuestro proyecto es el que tiene la información de todos los paquetes requeridos:\n{\n  \"name\": \"proyecto026\",\n  \"version\": \"0.0.0\",\n  \"scripts\": {\n    \"ng\": \"ng\",\n    \"start\": \"ng serve\",\n    \"build\": \"ng build\",\n    \"watch\": \"ng build --watch --configuration development\",\n    \"test\": \"ng test\"\n  },\n  \"private\": true,\n  \"dependencies\": {\n    \"@angular/animations\": \"^19.0.0\",\n    \"@angular/common\": \"^19.0.0\",\n    \"@angular/compiler\": \"^19.0.0\",\n    \"@angular/core\": \"^19.0.0\",\n    \"@angular/forms\": \"^19.0.0\",\n    \"@angular/platform-browser\": \"^19.0.0\",\n    \"@angular/platform-browser-dynamic\": \"^19.0.0\",\n    \"@angular/router\": \"^19.0.0\",\n    \"rxjs\": \"~7.8.0\",\n    \"tslib\": \"^2.3.0\",\n    \"zone.js\": \"~0.15.0\"\n  },\n  \"devDependencies\": {\n    \"@angular-devkit/build-angular\": \"^19.0.2\",\n    \"@angular/cli\": \"^19.0.2\",\n    \"@angular/compiler-cli\": \"^19.0.0\",\n    \"@types/jasmine\": \"~5.1.0\",\n    \"jasmine-core\": \"~5.4.0\",\n    \"karma\": \"~6.4.0\",\n    \"karma-chrome-launcher\": \"~3.2.0\",\n    \"karma-coverage\": \"~2.2.0\",\n    \"karma-jasmine\": \"~5.1.0\",\n    \"karma-jasmine-html-reporter\": \"~2.1.0\",\n    \"typescript\": \"~5.6.2\"\n  }\n}\n\nEste archivo se modifica cada vez que agregamos nuevos recursos al proyecto, por ejemplo si añadimos 'Angular Material' mediante el comando:\nng add @angular/material\n\nLuego el archivo 'package.json' se ha modificado con la dependencia:\n{\n  \"name\": \"proyecto026\",\n  \"version\": \"0.0.0\",\n  \"scripts\": {\n    \"ng\": \"ng\",\n    \"start\": \"ng serve\",\n    \"build\": \"ng build\",\n    \"watch\": \"ng build --watch --configuration development\",\n    \"test\": \"ng test\"\n  },\n  \"private\": true,\n  \"dependencies\": {\n    \"@angular/animations\": \"^19.0.0\",\n    \"@angular/cdk\": \"^19.0.1\",\n    \"@angular/common\": \"^19.0.0\",\n    \"@angular/compiler\": \"^19.0.0\",\n    \"@angular/core\": \"^19.0.0\",\n    \"@angular/forms\": \"^19.0.0\",\n    \"@angular/material\": \"^19.0.1\", \n    \"@angular/platform-browser\": \"^19.0.0\",\n    \"@angular/platform-browser-dynamic\": \"^19.0.0\",\n    \"@angular/router\": \"^19.0.0\",\n    \"rxjs\": \"~7.8.0\",\n    \"tslib\": \"^2.3.0\",\n    \"zone.js\": \"~0.15.0\"\n  },\n  \"devDependencies\": {\n    \"@angular-devkit/build-angular\": \"^19.0.2\",\n    \"@angular/cli\": \"^19.0.2\",\n    \"@angular/compiler-cli\": \"^19.0.0\",\n    \"@types/jasmine\": \"~5.1.0\",\n    \"jasmine-core\": \"~5.4.0\",\n    \"karma\": \"~6.4.0\",\n    \"karma-chrome-launcher\": \"~3.2.0\",\n    \"karma-coverage\": \"~2.2.0\",\n    \"karma-jasmine\": \"~5.1.0\",\n    \"karma-jasmine-html-reporter\": \"~2.1.0\",\n    \"typescript\": \"~5.6.2\"\n  }\n}\n\nGracias a este archivo que especifica todas las dependencias, luego podemos recrear el código que debe almacenar la carpeta 'node_modules'."
  },
  {
    "title": "41 - Vistas diferidas : @defer {} @placeholder{}",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=41&codigo=41&inicio=40",
    "content": "Las vistas diferidas es una nueva estructura que se puede emplear en la plantilla HTML y ha sido introducida a partir de Angular 17.\nLa vistas diferidas permite renderizar un bloque HTML, componente etc. una vez que la página se ha cargado por completo, solo faltando el o los bloques de código diferido.\nLa carga diferida tiene por objetivo mejorar la experiencia del usuario cuando interactúa con nuestra aplicación.\nSintaxis\nLa sintaxis más elemental sin parámetros es:\n@defer {\n  aquí disponemos el bloque que se va a renderizar luego que se haya cargado toda la página\n} @placeholder {\n  aquí disponemos el bloque que debe renderizar inmediatamente\n}\n\n\nEl bloque @placeholder es opcional pero nos puede ser de mucha utilidad para informar al usuario que se va ha renderizar en dicho lugar, por ejemplo podemos reservar un área de la página donde se mostrará un gráfico estadístico que requiera datos de un servidor web.\n\nProblema\nCrear una página con un título, seguidamente muestre los números del 0 al 500000, al final de la página mostrar un pié página con un mensaje.\nComo podemos imaginar la generación y renderizado de la página va a ser lenta, debido a su tamaño. Lo más conveniente es que se muestre la página con un mensaje informando al usuario que se está generando la lista de números y tenga un poco de paciencia. Pasemos a crear  el proyecto:\nng new proyecto027\n\nEn la clase de la componente 'app.component.ts' creamos un arreglo de 500001 elementos con los valores comprendidos entre 0 y 500000:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  numeros = [...Array(500001).keys()];\n}\n\nEs importante recordar en JavaScript y por lo tanto aplicable en TypeScript para generar en forma concisa el arreglo:\n\n\nArray(500001): Esto crea un nuevo array con una longitud de 500001 elementos. Los elementos en este array aún no tienen valores asignados y serán undefined.\n\n\nArray(500001).keys(): La función keys() devuelve un nuevo objeto Array que contiene las claves para cada índice del arreglo. En este caso, las claves serán los números desde 0 hasta 500000.\n\n\n[...Array(500001).keys()]: El operador de propagación (...), recordemos que se utiliza para expandir los elementos del objeto Array en un nuevo array. Esto crea un array que contiene los números del 0 al 500000.\n\n\nEn resumen, después de ejecutar este código, la variable numeros contendrá un array con los números del 0 al 500000.\n\nAhora veamos como creamos el bloque que generará la lista de números en forma diferible, pasamos a codificar en el archivo app.component.html:\n<h1>Listado de numeros del 0 al 500000</h1>\n@defer {\n  <p>\n  @for(num of numeros;track num) {\n    {{num}} -\n  }\n  </p>\n}\n@placeholder {\n  <p>Generando numeros...</p>\n}\n<p>Gracias por visitar el sitio.</p>\n\n\nPodemos ejecutar la aplicación y ver que inmediatamente se carga la página casi por completo, pero queda pendiente el bloque @defer:\n \nMientras no se ha resuelto el contenido del bloque @defer se muestra el contenido del bloque @placeholder.\nLuego de algunos segundos, dependiendo de la velocidad de la computadora se remplaza el contenido del @placeholder por el contenido  del bloque @defer, en nuestro ejemplo mostrando la lista de números en pantalla :\n \n\nPodemos probar esta aplicación en la web aquí.\n\nSin vista diferida podemos comprobar que la página tarda varios segundos antes que se muestre en el navegador, lo cual genera una experiencia de usuario muy pobre. Puede modificar y probar el código sin el bloque de vista diferida:\n<h1>Listado de numeros del 0 al 500000</h1>\n<p>\n  @for(num of numeros;track num) {\n  {{num}} -\n  }\n</p>\n<p>Generando numeros...</p>\n<p>Gracias por visitar el sitio.</p>\n\nSeguramente sin vista diferida deberíamos utilizar otro algoritmo para que muestre parte de la página hasta que se muestre la lista de números.\nSi utilizamos una versión de Angular anterior a la 17, un algoritmo posible es el siguiente:\nimport { Component, OnInit } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n  numeros = [...Array(500001).keys()];\n  lista = 'generando la lista...';\n\n  ngOnInit() {\n    setTimeout(() => {\n      this.lista = this.numeros.join('-');\n    }, 0);\n  }\n\n}\n\n\nOnInit es una interfaz que proporciona el método ngOnInit, que se ejecuta cuando la componente se inicializa.\nEl método ngOnInit() se llama después de que la componente ha sido inicializada. En este caso, se utiliza para actualizar la propiedad lista después de un breve retraso, simbolizado por setTimeout. Este enfoque se utiliza para mostrar el mensaje 'generando la lista...' antes de que la lista completa de números se procese y actualice en la vista.\nY su plantilla queda con el siguiente código:\n<h1>Listado de numeros del 0 al 500000</h1>\n{{lista}}\n<p>Gracias por visitar el sitio.</p>\n\nLa vista diferida nos permite implementar un código más legible y veremos más adelante que tiene otras ventajas."
  },
  {
    "title": "42 - Vistas diferidas : @defer ([opciones de activación]) {}",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=42&codigo=42&inicio=40",
    "content": "El bloque diferible podemos indicar bajo que circunstancias debe cargarse:\n\non idle: La opción de activación por defecto. Por lo mismo es que no se la agrega:\n@defer (on idle){\n  <p>\n  @for(num of numeros;track num) {\n    {{num}} -\n  }\n  </p>\n}\n\nEn este caso lo más común es no disponer dicha activación:\n@defer {\n  <p>\n  @for(num of numeros;track num) {\n    {{num}} -\n  }\n  </p>\n}\n\n\n\non timer: se activaría después de una duración específica. La duración es obligatoria y se puede especificar en 'ms'  o 's':\n<p>¿Quién descubrió America?</p>\n@defer (on timer(5s)) {\n  <p>Cristóbal Colón</p>\n} @placeholder {\n  <p>¿?</p>\n}\n\nPrimero se muestra el contenido del bloque @placeholder y luego de 5 segundos es remplazado por el contenido del bloque @defer.\n \nY luego de 5 segundos:\n \n\n\n\non interaction: Se activará el bloque diferido cuando el usuario interactúe con el elemento especificado en el @placeholder a través de los eventos click o keydown.\n@defer (on interaction) {\n  <p>Cristóbal Colón</p>\n} @placeholder {\n  <button>¿Quién descubrió America?</button>\n}\n\nPrimero se muestra el botón:\n \nY al ser presionado el botón aparece el párrafo remplazando el contenido del @placeholder:\n \n\n\n\n\non hover: se activa la carga diferida cuando el mouse se coloca sobre el área de activación. Los eventos utilizados para esto son mouseenter y focusin.\n@defer (on hover) {\n  <p>Cristóbal Colón</p>\n} @placeholder {\n  <p>¿Quién descubrió America?</p>\n}\n\nSi desplazamos la flecha del mouse sobre el párrafo '¿Quién descubrió America?', el mismo será actualizado por el párrafo 'Cristóbal Colón'.\n\n\n\non viewport: se activa el bloque diferido cuando el contenido se encuentra en la ventana visible del navegador. Es muy útil si tenemos páginas que requieren un scroll casi infinito. No tenemos que renderizar si no avanzamos con el scroll de la página. El siguiente ejemplo que vamos a realizar utilizará esta opción de activación de la vista diferida.\n\n\n\n\n\nProblema\nCrear una componente llamada 'tablamultiplicacion' que reciba en una propiedad el número del cual queremos que muestre la tabla de multiplicación y se encargue de mostrarla por pantalla.\n<app-tablamultiplicacion [tabla]=\"2\" />\n\nEl resultado de visual de esta componente debe generar la siguiente pantalla:\n \nPor otro lado la componente principal de la aplicación generar las tablas de multiplicar del 2 al 10000. Mediante vistas diferidas evitar que se generen todas las tablas en forma inmediata y haga que la experiencia de usuario sea aceptable.\n\nCreemos el proyecto:\nng new proyecto028\n\n\nPrimero creamos la componente:\nng generate component tablamultiplicacion\n\nCodificamos la clase 'tablamultiplicacion.component.ts':\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-tablamultiplicacion',\n  imports: [],\n  templateUrl: './tablamultiplicacion.component.html',\n  styleUrl: './tablamultiplicacion.component.css'\n})\nexport class TablamultiplicacionComponent {\n  @Input() tabla:number=0;\n}\n\n\nPor otro lado la vista 'tablamultiplicacion.component.html':\n<h1>Tabla del {{tabla}}</h1>\n@for(valor of [1,2,3,4,5,6,7,8,9,10];track $index) {\n  <p>\n    {{tabla}} * {{valor}}={{tabla*valor}}\n  </p>\n}\n<hr>\n\n\nPasemos ahora a modificar la componente creada por defecto 'app.component.ts':\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { TablamultiplicacionComponent } from './tablamultiplicacion/tablamultiplicacion.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, TablamultiplicacionComponent],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  numeros = [...Array(9999).keys()].map(num => num + 2);\n}\n\nCreamos un arreglo llamado numeros donde guardamos los valores del 2 al 10000:\n\nPor último la plantillo donde hacemos uso de las vistas diferidas 'app.component.html':\n\n@for(valor of numeros;track valor) {\n  @defer (on viewport)  {\n    <app-tablamultiplicacion [tabla]=\"valor\" />\n  }\n  @placeholder {\n    <p>Esperando la tabla del {{valor}}</p>\n  }\n}\n<router-outlet />\n\nDentro del ciclo @for creamos las 9999 vistas diferidas y su activación depende que se esté viendo en la pantalla del navegador, como podemos imaginar la mayoría de las tablas están fuera del viewport del navegador (según el tamaño de la pantalla pueden estar visibles 2 o tres tablas por pantalla)\nLa experiencia de ejecución es aceptable gracias a que utilizamos la activación por viewport.\n\nPodemos probar esta aplicación en la web aquí.\n\nProbemos de eliminar el 'on viewport' y veremos que el navegador se toma su tiempo en renderizar las 9999 tablas de multiplicar:\n@for(valor of numeros;track valor) {\n  @defer {\n    <app-tablamultiplicacion [tabla]=\"valor\" />\n  }\n  @placeholder {\n    <p>Esperando la tabla del {{valor}}</p>\n  }\n}"
  },
  {
    "title": "43 - Vistas diferidas : Lazy Loading (carga perezosa)",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=43&codigo=43&inicio=40",
    "content": "Las vistas diferidas nos permite en algunas situaciones el concepto de Lazy Loading al permitir organizar una aplicación Angular que no cargue en forma completa toda la aplicación web en una única llamada al servidor, sino que retrase la carga hasta el momento de su utilización.\nEl proceso de particionar la aplicación en distintos archivos JavaScript lo hace automáticamente Angular cuando construimos la aplicación.\nVeamos un problema y verifiquemos en el navegador que cuando disponemos una o más componentes en un bloque @defer, el mismo se almacena en un archivo JavaScript separado y es peticionado al servidor en el momento que sea necesario.\nProblema\nCrear una componente que llamada 'graficotarta' que muestre un gráfico de tarta genérico. Luego en la componente principal de nuestra aplicación proceder a mostrar el gráfico cuando hagamos click sobre un botón.\n\n\nCreemos el proyecto:\nng new proyecto029\n\n\nPrimero creamos la componente:\nng generate component graficotarta\n\nNo hacemos ningún cambio al archivo 'graficotarta.component.ts':\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-graficotarta',\n  imports: [],\n  templateUrl: './graficotarta.component.html',\n  styleUrl: './graficotarta.component.css'\n})\nexport class GraficotartaComponent {\n\n}\n\n\nEn la plantilla 'graficotarta.component.html' disponemos un div:\n<div class=\"tarta\"></div>\n\n\nEn la hoja de estilo 'graficotarta.component.css' disponemos:\n.tarta {\n  width: 200px;\n  height: 200px;\n  background: conic-gradient(\n      #ff5733 0% 33%,      /* Color para la primera porción */\n      #33ff57 33% 66%,     /* Color para la segunda porción */\n      #5733ff 66% 100%     /* Color para la tercera porción */\n  );\n  border-radius: 50%;\n}\n\n\n\nPasemos ahora a modificar la componente creada por defecto 'app.component.ts' importando la otra componente:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { GraficotartaComponent } from './graficotarta/graficotarta.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, GraficotartaComponent],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'proyecto029';\n}\n\n\ny la plantilla 'app.component.html' donde cargaremos mediante una vista diferida el gráfico de tarta:\n@defer (on interaction) {\n<app-graficotarta></app-graficotarta>\n} @placeholder {\n<button>Ver gráfico de tarta</button>\n}\n<router-outlet />\n\nLo más interesante es ver que sucede en las peticiones de archivos desde el navegador. Debemos abrir la ventana de herramientas del navegador y en la pestaña 'Red' podemos observar los archivos solicitados al servidor hasta ese momento:\n \nLuego presionamos el botón y podemos observar que se solicita otro archivo al servidor con el código que genera el gráfico de tarta:\n \nPodemos probar esta aplicación en la web aquí.\nEn una aplicación grande podemos dividir distintas funcionalidades y realizar su carga con lazy loading.\n\ncomando prefetch (captación previa)\nVimos en el ejemplo anterior que con la carga perezosa podemos reducir la sobrecarga del servidor, por ejemplo si el usuario no presiona el botón no será necesario solicitar al servidor la componente.\nHay situaciones donde tal vez lo más importante es la velocidad de ejecución de nuestra aplicación y no queremos que el usuario cuando presione el botón tenga que esperar la recuperación de datos del servidor, para esto disponemos un comando llamado 'prefetch':\n@defer (on interaction; prefetch on idle) {\n<app-graficotarta></app-graficotarta>\n} @placeholder {\n<button>Ver gráfico de tarta</button>\n}\n\nAgregando 'prefetch on idle', con esto indicamos que el bloque se recupere del servidor sin la necesidad que se dispare el 'on interaction'."
  },
  {
    "title": "44 - Vistas diferidas : @defer (when [expresión lógica]) {}",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=44&codigo=44&inicio=40",
    "content": "Otra variante que podemos implementar con las vistas diferidas es utilizando la palabra clave when con una expresión lógica que retorne true o false. La vista se materializará cuando la expresión lógica se verifique verdadera.\nCreemos un proyecto y veamos el funcionamiento de esta variante de vista diferida:\nng new proyecto030\n\n\nEn el archivo 'app.component.ts' definimos un atributo que almacene el valor false:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  visible = false;\n}\n\n\nLa la plantilla 'app.component.html' queda con el siguiente código:\n<p>¿Quién descubrió America?</p>\n<input type=\"button\" (click)=\"visible=true\" value=\"mostrar respuesta\">\n@defer (when visible) {\n  <p>Respuesta:Cristóbal Colón</p>\n} @placeholder {\n  <p>¿?</p>\n}\n<router-outlet />\n\nComo el atributo visible almacena el valor false, el bloque de código no se renderiza. Luego cuando presionamos el botón cambiamos el valor del atributo visible por el valor false, en dicho momento se hace visible el bloque de código definido en el @defer.\nTener en cuenta que en una aplicación más realista en el bloque @defer tendremos una componente, que se cargará con lazy loading una vez que el when se verifique con el valor true.\nPodemos probar esta aplicación en la web aquí.\nPodemos utilizar también el prefetch, para el caso en que sea una componente su contenido se recupere del servidor inmediatamente y cuando el when se verifique verdadero, la componente se renderize inmediatamente:\n@defer (when visible;prefetch on idle) {\n<p>Respuesta:Cristóbal Colón</p>\n} @placeholder {\n<p>¿?</p>\n}"
  },
  {
    "title": "45 - Vistas diferidas : @defer {} @placeholder{} @loading{} @error{}",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=45&codigo=45&inicio=40",
    "content": "Hemos dicho que cuando definimos una vista diferida, el único bloque obligatorio es el @defer {}.\nA parte del @defer podemos agregar:\n\n\n@placeholder : Ya dijimos y hemos trabajado con este bloque que aparece mientras la vista no ha sido activada. Este contenido se reemplaza con el contenido principal una vez que se completa la carga. \n\n\n\n\n@loading : El bloque @loadinge es un bloque opcional que le permite declarar el contenido que se mostrará durante la carga de del bloque @defer. Por ejemplo, podría mostrar una rueda giratoria de carga mientras el contenido se recupera de un servidor.\n@defer {\n  <componente></componente>\n} @loading (after 100ms; minimum 1s) {\n  <img alt=\"cargando...\" src=\"cargando.gif\" />\n}\n\nEl bloque @loading acepta dos parámetros opcionales para especificar la mínima cantidad de tiempo que se debe mostrar el bloque y la cantidad de tiempo que se debe esperar para que comience la carga antes de mostrar la plantilla de carga. minimum y after los parámetros se especifican en incrementos de tiempo de milisegundos (ms) o segundos (s).\nAl igual que @placeholder, estos parámetros existen para evitar el parpadeo rápido del contenido en el caso de que las dependencias diferidas se recuperen rápidamente. Tanto los temporizadores minimum como after para el bloque @loading comienzan inmediatamente después de que se haya activado la carga del @defer.\n\n\n\n\n@error : El bloque @error permite declarar contenido que se mostrará si falla la carga diferida.\n@defer {\n  <componente></componente>\n} @loading (after 100ms; minimum 1s) {\n  <img alt=\"cargando...\" src=\"cargando.gif\" />\n} @error {\n  <p>Problemas con el servidor</p>\n}\n\nImaginemos que se corta la conexión con el servidor, cuando se trate de recuperar el archivo que almacena   <componente></componente>, se dispara el bloque @error."
  },
  {
    "title": "46 - Directiva de atributo [ngStyle] y directivas para estilos individuales - Sintaxis completa",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=46&codigo=46&inicio=40",
    "content": "La directiva de atributo ngStyle actualiza los estilos para un elemento HTML determinado.\nEstablece una o más propiedades de estilo, especificadas como pares clave-valor separados por dos puntos. La clave es un nombre de estilo y el valor es una expresión a evaluar o valor a asignar.\nPodemos crear un proyecto para ir probando estas funcionalidades:\nng new proyecto031\n\nSi indicamos directamente el valor a asignar tenemos la siguiente sintaxis:\n<h1 [ngStyle]=\"{'color':'red','background-color':'#ff0','text-align':'center'}\">Sitio fuera de servicio</h1>\n\nEn el ejemplo vemos que si asignamos valores no presenta ninguna ventaja que definir la propiedad 'style' de HTML:\n<h1 style=\"color:red;background-color:#ff0;text-align:center\">Sitio fuera de servicio</h1>\n\nPero cuando utilizamos la directiva de atributo ngStyle podemos indicar una expresión en la zona del valor, por ejemplo si tenemos definido el atributo en la clase:\n  colorEstado='#f00';\n\nLuego en la vista accedemos a dicho atributo:\n<h1 [ngStyle]=\"{'color':colorEstado}\">Sitio fuera de servicio</h1>\n\nEstamos indicando que para el atributo 'color' debe tomar el valor almacenado en la variable colorEstado, es importante notar que no debe ir entre comillas la variable.\nPodemos llamar a un método en el lugar de la expresión, si tenemos definido en el modelo el método:\n  retornarColor() {\n    return '#00f';\n  }\n\nLuego cuando definimos la directiva tenemos la sintaxis:\n<h1 [ngStyle]=\"{'color':retornarColor()}\">Sitio fuera de servicio</h1>\n\n\nDisponer una condición en la expresión\nPor ejemplo si necesitamos que una tabla que muestra los números del 1 al 5, tengan las celdas de colores alternos, lo podemos resolver con la sintaxis:\n<table>\n  @for(elemento of [1,2,3,4,5];track $index) {\n  <tr>\n    <td [ngStyle]=\"{'background-color':elemento%2==0?'red':'yellow'}\">{{elemento}}</td>\n  </tr>\n  }\n</table>\nCada vuelta del for se verifica si el resto de dividir el elemento del array es cero procede a asignar el valor 'red' a la propiedad 'background-color' en caso contrario asigna 'yellow'.\n\nTrabajar con unidades de medida.\nLa sintaxis a emplear con unidades de medida se deben indicar como sufijo cuando la definimos:\n@for(elemento of [10,12,14,20,30];track $index) {\n  <p [ngStyle]=\"{'font-size.px':elemento}\">\n    Tamaño de fuente en píxeles: {{elemento}}\n  </p>\n}\nLuego tenemos como resultado:\n\nEs decir utilizamos la sintaxis: 'font-size.px'\nOtros ejemplos de unidades de medida asignada podrían ser:\n\n\n 'margin-top.px':'10'\n\n\n 'padding.em':'1'\n\n\n\nAsignar a la directiva un objeto con un conjunto de estilos\nPodemos crear en el modelo un objeto literal con distintos estilos, que luego podemos modificar cuando se producen eventos. Para probar esto crearemos un div con una etiqueta y dos botones que modifican el tamaño de la fuente.\nEn el modelo de la componente definimos 'app.component.ts':\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { NgStyle } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, NgStyle],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  colorEstado = '#f00';\n\n  retornarColor() {\n    return '#00f';\n  }\n\n  tamano = 30;\n  presentacion = {\n    \"background-color\": \"black\",\n    \"color\": \"white\",\n    \"width.px\": \"1000\",\n    \"height.px\": \"200\",\n    \"font-size.px\": this.tamano,\n    \"display\": \"flex\",\n    \"justify-content\": \"center\",\n    \"align-items\": \"center\"\n  }\n\n  agrandar() {\n    this.tamano++;\n    this.presentacion[\"font-size.px\"] = this.tamano;\n  }\n\n  reducir() {\n    this.tamano--;\n    this.presentacion[\"font-size.px\"] = this.tamano;\n  }\n}\n\nEn la vista tenemos 'app.component.html':\n<h1 [ngStyle]=\"{'color':'red','background-color':'#ff0','text-align':'center'}\">Sitio fuera de servicio</h1>\n<h1 [ngStyle]=\"{'color':colorEstado}\">Sitio fuera de servicio</h1>\n<h1 [ngStyle]=\"{'color':retornarColor()}\">Sitio fuera de servicio</h1>\n<table>\n  @for(elemento of [1,2,3,4,5];track $index) {\n  <tr>\n    <td [ngStyle]=\"{'background-color':elemento%2==0?'red':'yellow'}\">{{elemento}}</td>\n  </tr>\n  }\n</table>\n@for(elemento of [10,12,14,20,30];track $index) {\n  <p [ngStyle]=\"{'font-size.px':elemento}\">\n    Tamaño de fuente en píxeles: {{elemento}}\n  </p>\n}\n\n<div [ngStyle]=\"presentacion\">Texto centrado en forma horizontal y vertical.</div>\n<button (click)=\"agrandar()\">Agrandar</button>\n<button (click)=\"reducir()\">Reducir</button>\n<router-outlet />\n\nHemos asignado a la directiva ngStyle la variable 'presentación' que se define en el modelo.\nCuando se presiona alguno de los botones procedemos a actualizar la variable 'presentacion' y podemos ver que el texto se actualiza.\n\n\nSintaxis para directivas individuales\nPodemos hacer referencia a una propiedad individual con la sintaxis:\n<p [style.color]=\"'#f00'\">Color rojo</p>\n\nDisponemos 'style' y seguidamente el nombre de la propiedad, en este caso 'color'. Son importante las comillas simples dentro de las comillas dobles, estamos indicando que tomo el string '#f00'.\nEs más común que enlacemos la directiva con una variable definida en el modelo, por ejemplo si tenemos en el modelo:\n  colorFondo='#ff0';\n\nLuego en la vista enlazamos esta variable con la sintaxis:\n<p [style.background-color]=\"colorFondo\">Color</p>\n\n\nAgregar a la aplicación anterior la posibilidad de modificar el tamaño de la fuente de un texto mediante dos botones.\nEn el archivo 'app.component.ts' tenemos:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { NgStyle } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, NgStyle],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  colorEstado = '#f00';\n\n  retornarColor() {\n    return '#00f';\n  }\n\n  tamano = 30;\n  presentacion = {\n    \"background-color\": \"black\",\n    \"color\": \"white\",\n    \"width.px\": \"1000\",\n    \"height.px\": \"200\",\n    \"font-size.px\": this.tamano,\n    \"display\": \"flex\",\n    \"justify-content\": \"center\",\n    \"align-items\": \"center\"\n  }\n\n  agrandar() {\n    this.tamano++;\n    this.presentacion[\"font-size.px\"] = this.tamano;\n  }\n\n  reducir() {\n    this.tamano--;\n    this.presentacion[\"font-size.px\"] = this.tamano;\n  }\n\n  tamanoFuente = 50;\n\n  agrandarFuente() {\n    this.tamanoFuente++;\n  }\n\n  reducirFuente() {\n    this.tamanoFuente--;\n  }\n}\n\n\nEn el archivo 'app.component.html' queda:\n<h1 [ngStyle]=\"{'color':'red','background-color':'#ff0','text-align':'center'}\">Sitio fuera de servicio</h1>\n<h1 [ngStyle]=\"{'color':colorEstado}\">Sitio fuera de servicio</h1>\n<h1 [ngStyle]=\"{'color':retornarColor()}\">Sitio fuera de servicio</h1>\n<table>\n  @for(elemento of [1,2,3,4,5];track $index) {\n  <tr>\n    <td [ngStyle]=\"{'background-color':elemento%2==0?'red':'yellow'}\">{{elemento}}</td>\n  </tr>\n  }\n</table>\n@for(elemento of [10,12,14,20,30];track $index) {\n  <p [ngStyle]=\"{'font-size.px':elemento}\">\n    Tamaño de fuente en píxeles: {{elemento}}\n  </p>\n}\n\n<div [ngStyle]=\"presentacion\">Texto centrado en forma horizontal y vertical.</div>\n<button (click)=\"agrandar()\">Agrandar</button>\n<button (click)=\"reducir()\">Reducir</button>\n\n<div [style.font-size.px]=\"tamanoFuente\">Texto</div>\n<button (click)=\"agrandarFuente()\">Agrandar</button>\n<button (click)=\"reducirFuente()\">Reducir</button>\n<router-outlet />\n\nComo vemos si tenemos que trabajar con unidades de medida debemos indicarla en la misma directiva:\n<div [style.font-size.px]=\"tamano\">Texto</div>\n\n\nPodemos probar esta aplicación en la web aquí.\n\nAcotaciones\nDebemos usar NgStyle cuando debemos establecer muchos estilos en línea de forma simultánea y dinámica, según el estado del componente, en el caso que solo debemos establecer un único estilo conviene utilizar la sintaxis que acabamos de ver."
  },
  {
    "title": "47 - Directiva de atributo [ngClass] y directivas para clases individuales - Sintaxis completa",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=47&codigo=47&inicio=40",
    "content": "En el concepto anterior vimos las diferentes herramientas que nos provee Angular para manipular los estilos en línea. Ahora veremos que Angular nos permite manipular las clases que se asocian a un elemento HTML.\nPodemos crear un proyecto para ir probando estas funcionalidades:\nng new proyecto032\n\n\nLa directiva de atributo [ngClass] permite establecer una o más clases a un elemento HTML.\nVeamos distintas formas de utilizar la directiva [ngClass]\nSi tenemos definidas las siguientes clases en el archivo 'app.component.css':\n.clase1 {\n    color:red;\n    background-color:blue;\n}\n\n.clase2 {\n    font-size:20px;\n    font-family: 'Courier New', Courier, monospace;\n}\n\nLuego en la vista 'app.component.html':\n<p [ngClass]=\"'clase1 clase2'\">Prueba de directiva ngClass</p>\n\nSe le asignan las clases 'clase1' y 'clase2' al párrafo. Son importante las comillas simples para que funcione. Normalmente no haríamos esto ya que es más sencillo fijar el atributo 'class' de HTML:\n<p class=\"clase1 clase2\">Prueba de class</p>\n\nUna alternativa más útil es definir un objeto literal cuyas claves son nombres de clases y sus valores un valor boolean que indica si se debe activar o no la clase al elemento HTML.\nSi tenemos los atributos:\n  estado1=true;\n  estado2=false;\n\nLuego en la vista definimos la directiva de atributo [ngClass]:\n<p [ngClass]=\"{'clase1':estado1,'clase2':estado2}\">Prueba de directiva ngClass</p>\n\nLuego solo se activa la 'clase1' ya que 'estado1' almacena true, debido a que 'estado2' almacena false significa que la 'clase2' no se aplica a la etiqueta.\nComo vemos podemos en forma dinámica cambiar variables definidas en el modelo y se aplican los cambios gracias a la directiva [ngClass]\n\n\n\nDisponer una condición en la expresión\nPor ejemplo si necesitamos que una tabla que muestra los números del 1 al 5, tengan las celdas de colores alternos, lo podemos resolver con la sintaxis:\n<table>\n  @for(elemento of [1,2,3,4,5];track $index) {\n  <tr>\n    <td [ngClass]=\"{'color1':elemento%2==0,'color2':elemento%2==1}\">{{elemento}}</td>\n  </tr>\n  }\n</table>\n\nSuponiendo que las dos clases están definidas en el archivo 'app.component.css':\n.color1 {\n    color: white;\n    background-color: blue;\n}\n\n.color2 {\n    color: white;\n    background-color: green;\n}\n\nCada vuelta del for solo se aplica una de las dos clases.\n\nVamos a agregar a la aplicación otra funcionalidad que permita mediante dos botones fijar o eliminar dos estilos que se aplican a un elemento HTML.\napp.component.css\n.clase1 {\n  color:red;\n  background-color:blue;\n}\n\n.clase2 {\n  font-size:20px;\n  font-family: 'Courier New', Courier, monospace;\n}\n\n.color1 {\n  color: white;\n  background-color: blue;\n}\n\n.color2 {\n  color: white;\n  background-color: green;\n}\n\n.clase3 {\n  color:red;\n  background-color:blue;\n}\n\n.clase4 {\n  font-size:20px;\n  font-family: 'Courier New', Courier, monospace;\n}\n\n\napp.component.html\n<p [ngClass]=\"'clase1 clase2'\">Prueba de directiva ngClass</p>\n<p [ngClass]=\"{'clase1':estado1,'clase2':estado2}\">Prueba de directiva ngClass</p>\n\n<table>\n  @for(elemento of [1,2,3,4,5];track $index) {\n  <tr>\n    <td [ngClass]=\"{'color1':elemento%2==0,'color2':elemento%2==1}\">{{elemento}}</td>\n  </tr>\n  }\n</table>\n\n<p [ngClass]=\"forma\">Prueba de directiva</p>\n<button (click)=\"fijar()\">Fijar clases</button>\n<button (click)=\"eliminar()\">Eliminar clases</button>\n\n\napp.component.ts\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { NgClass } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, NgClass],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  estado1 = true;\n  estado2 = false;\n\n  forma = {\n    'clase3 clase4': true\n  };\n  fijar() {\n    this.forma['clase3 clase4'] = true;\n  }\n\n  eliminar() {\n    this.forma['clase3 clase4'] = false;\n  }\n}\n\nSe asocia la variable 'forma' a la directiva 'ngClass', luego significa que cuando comienza la ejecución de la aplicación las dos clases se asocian a dicha etiqueta:\n\nLuego si se presiona el botón de 'eliminar', modificamos el objeto literal asignando el valor false, esto hace que las dos clases se eliminen de la etiqueta.\n\nEnlace a clases individuales.\nEn lugar de utilizar la directiva 'ngClass' podemos utilizar una sintaxis alternativa para agregar o eliminar clases en particular para una etiqueta HTML:\n<p [class.clase1]=\"true\">Prueba de class</p>\n\nSe añade las 'clase1' al parrafo. En lugar de disponer un true podemos definir una condición o llamar a una función que retorne true o false:\n<table>\n  @for(elemento of [1,2,3,4,5];track $index) {\n  <tr>\n    <td [class.clase1]=\"elemento%2==0\">{{elemento}}</td>\n  </tr>\n  }\n</table>\n\nCon el código anterior solo se incorpora la 'clase1' a las filas pares de la tabla. Si la etiqueta ya dispone de otras clases no se borran las mismas\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "48 - Directivas de atributo - creación de directivas personalizadas",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=48&codigo=48&inicio=40",
    "content": "Hemos dicho que una directiva de atributo cambia la apariencia o el comportamiento de un elemento HTML. Hay varias directivas que trae Angular por defecto. Ahora veremos que podemos crear nuestras propias directivas de atributo personalizadas y definir el algoritmo que se debe aplicar al elemento HTML que se le asigna.\nLa herramienta de Angular CLI provee lo necesario para crear un esqueleto básico de una directiva de atributo. Debemos utilizar la siguiente sintaxis:\nng generate directive [nombre de la directiva]\n\nConfeccionaremos un problema elemental para conocer los pasos en la creación, codificación y uso de una directiva de atributo personalizada.\nProblema\nCrear una directiva personalizada que se pueda asociar a cualquier elemento HTML y cuyo objetivo sea resaltar el texto que muestra, cambiando el color de fondo por amarillo.\n\n\n\nCrearemos primero el proyecto\nng new proyecto033\n\n\n\nProcedemos a crear la directiva de atributo personalizada llamando a la misma 'resaltado':\nng generate directive resaltado\n\nSe crean dos archivos:\n\n\nSe crea propiamente el archivo que contendrá la lógica de la directiva y tiene como nombre 'resaltado.directive.ts':\nimport { Directive } from '@angular/core';\n\n@Directive({\n  selector: '[appResaltado]'\n})\nexport class ResaltadoDirective {\n\n  constructor() { }\n\n}\n\n\n\nTambién se crea el archivo 'resaltado.directive.spec.ts' para especificar pruebas unitarias (por el momento no hemos trabajado con este tipo de archivos, no lo modificaremos ni analizaremos):\nimport { ResaltadoDirective } from './resaltado.directive';\n\ndescribe('ResaltadoDirective', () => {\n  it('should create an instance', () => {\n    const directive = new ResaltadoDirective();\n    expect(directive).toBeTruthy();\n  });\n});\n\n\n\n\nProcedemos a modificar el archivo 'resaltado.directive.ts' implementando la lógica de nuestra directiva:\nimport { Directive, ElementRef } from '@angular/core';\n\n@Directive({\n  selector: '[appResaltado]'\n})\nexport class ResaltadoDirective {\n\n  constructor(private elemento: ElementRef) {\n    elemento.nativeElement.style.backgroundColor = 'yellow';\n  }\n\n}\n\nSe inyecta al constructor un objeto de la clase 'ElementRef':\n  constructor(private elemento: ElementRef) {\n\nPreviamente debemos importar la clase 'ElementRef', que se almacena en '@angular/core':\nimport { Directive, ElementRef } from '@angular/core';\n\nLa lógica de nuestra directiva es muy simple, solo debe manipular el color de fondo del elemento HTML al que se le aplicó.\nEl parámetro 'elemento' tiene la referencia al elemento HTML que se le aplicó la directiva, mediante el método 'nativeElement' podemos acceder a los atributos y métodos del DOM.\n\n\n\nSolo nos falta importar la directiva en nuestra componente para luego poder consumir la directiva de atributo en la interfaz visual de una componente. Pasemos a modificar el archivo 'app.component.ts' por:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ResaltadoDirective } from './resaltado.directive';\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, ResaltadoDirective],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'proyecto033';\n}\n\n\nLuego el archivo 'app.component.html' consumimos la directiva de atributo:\n<h3>Datos generales.</h3>\n<p>Chile es un país de América ubicado en el extremo sudoeste de América del Sur.\n  Su nombre oficial es <span appResaltado>República de Chile</span>\n  y su <span appResaltado>capital es la ciudad de Santiago</span>.\n  Primer país sudamericano en ingresar a la Organización para la Cooperación y el\n  Desarrollo Económicos, Chile es una de las economías de América Latina que más ha\n  crecido desde mediados de la década de 1980.</p>\n<p>Antes del descubrimiento de América, las tierras situadas al sur del desierto de Atacama ya\n  se llamaban <span appResaltado>Chili</span> en la tradición indígena.\n  Una vez instalados en Nueva Castilla y\n  Nueva Toledo, los conquistadores españoles siguieron llamando de esa forma a la\n  región del sur, a veces también conocida como «valle de Chile», nombre que se extendió\n  posteriormente a todo el actual país.</p>\n<router-outlet />\n\nCuando queremos resaltar un texto, podemos utilizar el elemento 'span' y asignar la directiva 'appResaltado'.\nTenemos como resultado en el navegador:\n\nPodemos probar esta aplicación en la web aquí.\n\n\n\nAcotaciones\n\n\nPodemos aplicar la directiva creada a cualquier otro elemento HTML:\n<h1 appResaltado>Estado de resultados</h1>\n<p appResaltado>Esto es una prueba.</p>\n\n\n\nSi queremos que la directiva tenga un prefijo distinto a 'app' cuando se crea, debemos utilizar la sintaxis:\nng generate directive resaltado --prefix lib\n\n\n\nSi queremos que la directiva no tenga prefijo cuando se crea, debemos utilizar la sintaxis:\nng generate directive resaltado --prefix"
  },
  {
    "title": "49 - Directivas de atributo - creación y definición de propiedades",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=49&codigo=49&inicio=40",
    "content": "Vimos en el concepto anterior los pasos que debemos dar para crear una simple directiva. Ahora veremos que podemos pasar uno o más datos para personalizar la directiva con datos a enviarle.\n\n\nProblema\nCrear una directiva personalizada que se pueda asociar a cualquier elemento HTML y cuyo objetivo sea resaltar el texto que muestra, cambiando el color de fondo por amarillo por defecto o un color que le pasemos a dicha directiva. Agregar un segundo dato a enviar a la directiva que sea el tamaño de la fuente.\n\n\n\nCrearemos primero el proyecto\nng new proyecto034\n\n\n\nProcedemos a crear la directiva de atributo personalizada llamando a la misma 'resaltado':\nng generate directive resaltado\n\nSe crean dos archivos.\n\nSe crea propiamente el archivo que contendrá la lógica de la directiva y tiene como nombre 'resaltado.directive.ts':\nTambién se crea el archivo 'resaltado.directive.spec.ts' para especificar pruebas unitarias (por el momento no hemos trabajado con este tipo de archivos, no lo modificaremos ni analizaremos)\n\n\n\nProcedemos a modificar el archivo 'resaltado.directive.ts' implementando la lógica de nuestra directiva:\nimport { Directive, ElementRef, Input, OnInit, SimpleChanges, OnChanges } from '@angular/core';\n\n@Directive({\n  selector: '[appResaltado]',\n})\nexport class ResaltadoDirective implements OnInit, OnChanges {\n\n  @Input('appResaltado') colorResaltado!: string;\n  @Input('tamano') tam: number = 0;\n\n  constructor(private elemento: ElementRef) {\n  }\n\n  ngOnInit(): void {\n    this.actualizar();\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    this.actualizar();\n  }\n\n  actualizar() {\n    if (this.colorResaltado != null)\n      this.elemento.nativeElement.style.backgroundColor = this.colorResaltado;\n    else\n      this.elemento.nativeElement.style.backgroundColor = 'yellow';\n    if (this.tam > 0)\n    {\n      console.log(this.elemento.nativeElement);\n      this.elemento.nativeElement.style.fontSize = this.tam + 'px';\n    }\n  }\n}\n\nSe inyecta al constructor un objeto de la clase 'ElementRef':\n  constructor(private elemento: ElementRef) {\n\nDebemos importar 6 clases, que se almacenan en '@angular/core':\nimport { Directive, ElementRef, Input, OnInit, SimpleChanges, OnChanges } from '@angular/core';\n\nEl método onInit que se ejecuta una vez que la directiva ha sido creada y almacenado los datos en las propiedades appResaltado y tamano. Desde el método onInit llamamos al método 'actualizar'.\nEl método actualizar modifica el color de fondo del elemento HTML según el dato recibido en la propiedad 'appResaltado' o en el caso que no lo recibe pinta el elemento de amarillo:\n  actualizar() {\n    if (this.colorResaltado != null)\n      this.elemento.nativeElement.style.backgroundColor = this.colorResaltado;\n    else\n      this.elemento.nativeElement.style.backgroundColor = 'yellow';\n\nTambién en el método actualizar si hemos inicializado la propiedad 'tamano' procedemos a modificar el tamaño de la fuente:\n    if (this.tam > 0)\n      this.elemento.nativeElement.style.fontSize = this.tam + 'px';\n\n\nEl método ngOnChanges se dispara si cambiamos el valor de una propiedad de la directiva, en cuyo caso procedemos a actualizar el color de fondo y tamaño de fuente llamando al método 'actualizar':\n  ngOnChanges(changes: SimpleChanges) {\n    this.actualizar();\n  }\n\n\n\n\nPara probar la directiva debemos importar la directiva en nuestro componente 'app.component.ts':\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ResaltadoDirective } from './resaltado.directive';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, ResaltadoDirective],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  colorselect = \"green\";\n  tamanoFuente = 30;\n\n  cambiarColor(col:string) {\n    this.colorselect = col;\n  }\n  agrandar() {\n    this.tamanoFuente++;\n  }\n  achicar() {\n    this.tamanoFuente--;\n  }\n}\n\nEn la clase definimos 2 atributos llamados colorselect y tamanoFuente que almacenan los valores que se le pasan a las propiedades de la directiva que hemos creado.\n\nTambién modificamos el archivo 'app.component.html':\n<p>Texto con resaltado : <span [appResaltado]=\"colorselect\" [tamano]=\"tamanoFuente\">prueba de directiva</span></p>\n<button (click)=\"cambiarColor('red')\">Rojo</button>\n<button (click)=\"cambiarColor('yellow')\">Amarillo</button>\n<button (click)=\"agrandar()\">Agrandar</button>\n<button (click)=\"achicar()\">Achicar</button>\n<router-outlet />\n\nPara inicializar la propiedad que define el color inicial de la directiva le asignamos:\n[appResaltado]=\"colorselect\"\nEn la misma etiqueta 'span' definimos el otro atributo:\n[tamano]=\"tamanoFuente\"\n\nSi se presiona el botón con la etiqueta 'Rojo' se ejecuta el método:\n  cambiarColor(col:string) {\n    this.colorselect = col;\n  }\n\nCuando cambiamos el valor del atributo 'colorselect', se actualiza el color de la etiqueta HTML que tiene asociada la directiva de atributo.\n\nSi ejecutamos la aplicación tenemos como resultado:\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "50 - Directivas de atributo - responder a eventos del usuario dentro de la directiva",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=50&codigo=50&inicio=40",
    "content": "Cuando creamos una directiva personalizada podemos capturar eventos dentro de la misma para reaccionar. Podemos por ejemplo detectar y reaccionar cuando el mouse entra o sale del elemento HTML que estamos aplicando la directiva.\n\n\n\n\nProblema\nCrear una directiva personalizada que se pueda asociar a cualquier elemento HTML y cuyo objetivo sea mediante la síntesis de voz hacer la lectura del contenido de texto que contiene la etiqueta. La lectura debe comenzar cuando el usuario dispone el mouse sobre la etiqueta y terminarla si saca la flecha del mouse.\n\n\n\nCrearemos primero el proyecto\nng new proyecto035\n\n\n\nProcedemos a crear la directiva de atributo personalizada llamando a la misma 'textovoz' (indicamos que no queremos prefijo):\nng generate directive textovoz --prefix\n\nSe crean dos archivos.\n\n\n\nProcedemos a modificar el archivo 'textovoz.directive.ts' implementando la lógica de nuestra directiva:\nimport { Directive, ElementRef, HostListener } from '@angular/core';\n\n@Directive({\n  selector: '[textovoz]'\n})\nexport class TextovozDirective {\n\n  constructor(private elemento: ElementRef) {\n  }\n\n  @HostListener('mouseenter') entradaMouse() {\n    speechSynthesis.speak(new SpeechSynthesisUtterance(this.elemento.nativeElement.textContent));\n  }\n\n  @HostListener('mouseleave') salidaMouse() {\n    speechSynthesis.cancel();\n  }\n\n}\n\nSe inyecta al constructor un objeto de la clase 'ElementRef':\n  constructor(private elemento: ElementRef) {\n\nDebemos importar 3 clases, que se almacenan en '@angular/core':\nimport { Directive, ElementRef, HostListener } from '@angular/core';\n\nPara captura de eventos debemos utilizar la función decoradora @HostListener pasando como parámetro el nombre del evento a capturar:\n  @HostListener('mouseenter')\n\nCuando el usuario ingresa la flecha del mouse dentro de la componente, mediante el objeto 'speechSynthesis' y la clase 'SpeechSynthesisUtterance' procede la alocución del string que le pasamos como parámetro, el mismo lo rescatamos del contenido de la etiqueta HTML:\n  @HostListener('mouseenter') entradaMouse() {\n    speechSynthesis.speak(new SpeechSynthesisUtterance(this.elemento.nativeElement.textContent));\n  }\n\n\nTambién capturamos el evento 'mouseleave' donde procedemos a cancelar la alocución del mensaje, en el caso que no se haya terminado previamente:\n  @HostListener('mouseleave') salidaMouse() {\n    speechSynthesis.cancel();\n  }\n\n\n\n\nPara probar la directiva 'textovoz' vamos a utilizar la componente que Angular nos ha creado por defecto, modificamos el archivo 'app.component.ts':\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { TextovozDirective } from './textovoz.directive';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, TextovozDirective],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'proyecto035';\n}\n\n\nY el archivo 'app.component.html':\n<p>Como se pronuncia la palabra: <span textovoz>casa</span></p>\n<p>Como se pronuncia la palabra: <span textovoz>ventana</span></p>\n<p>Como se pronuncia la oración:</p>\n<pre textovoz>\n    Aquí me pongo a cantar\n    al compás de la vihuela\n    que el hombre que lo desvela\n    una pena extraordinaria\n    como el ave solitaria\n    con el cantar se consuela\n  </pre>\n<router-outlet />\n\nComo vemos simplemente agregamos la directiva de atributo que hemos creado:\n<span textovoz>casa</span>\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "51 - TypeScript",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=51&codigo=51&inicio=40",
    "content": "Hemos avanzado sobre muchas características del framework Angular y no nos hemos detenido sobre el lenguaje que lo soporta que es TypeScript.\nTypeScript es un superconjunto de JavaScript que compila a JavaScript.\nTypeScript agrega muchas características a JavaScript que nos facilitan la implementación de las aplicaciones.\nCada vez que compilamos la aplicación Angular:\nC:\\angulardevya\\proyecto035> ng serve -o\n\nSe convierten todos los archivos TypeScript (*.ts) en archivos JavaScript (*.js). Este proceso se hace en forma automática gracias a la herramienta Angular CLI. Como programadores en Angular solo nos concentramos en el desarrollo de la aplicación utilizando TypeScript y dejamos que la herramienta se encargue de todas las transformaciones para que luego se ejecute dentro de un navegador web (recordemos que los navegadores solo pueden interpretar archivos JavaScript y no TypeScript)\nCuando creamos un proyecto con Angular CLI se instala en la carpeta 'node_modules' el compilador en la subcarpeta 'typescript'.\nSi abrimos el archivo package.json podemos identificar en las dependencias de desarrollo la versión de TypeScript que requiere nuestro proyecto:\n{\n  \"name\": \"proyecto035\",\n  \"version\": \"0.0.0\",\n  \"scripts\": {\n    \"ng\": \"ng\",\n    \"start\": \"ng serve\",\n    \"build\": \"ng build\",\n    \"watch\": \"ng build --watch --configuration development\",\n    \"test\": \"ng test\"\n  },\n  \"private\": true,\n  \"dependencies\": {\n    \"@angular/animations\": \"^19.0.0\",\n    \"@angular/common\": \"^19.0.0\",\n    \"@angular/compiler\": \"^19.0.0\",\n    \"@angular/core\": \"^19.0.0\",\n    \"@angular/forms\": \"^19.0.0\",\n    \"@angular/platform-browser\": \"^19.0.0\",\n    \"@angular/platform-browser-dynamic\": \"^19.0.0\",\n    \"@angular/router\": \"^19.0.0\",\n    \"rxjs\": \"~7.8.0\",\n    \"tslib\": \"^2.3.0\",\n    \"zone.js\": \"~0.15.0\"\n  },\n  \"devDependencies\": {\n    \"@angular-devkit/build-angular\": \"^19.0.2\",\n    \"@angular/cli\": \"^19.0.2\",\n    \"@angular/compiler-cli\": \"^19.0.0\",\n    \"@types/jasmine\": \"~5.1.0\",\n    \"jasmine-core\": \"~5.4.0\",\n    \"karma\": \"~6.4.0\",\n    \"karma-chrome-launcher\": \"~3.2.0\",\n    \"karma-coverage\": \"~2.2.0\",\n    \"karma-jasmine\": \"~5.1.0\",\n    \"karma-jasmine-html-reporter\": \"~2.1.0\",\n    \"typescript\": \"~5.6.2\"\n  }\n}\n\n\n\nVentajas\n\nFacilita el desarrollo de aplicaciones complejas.\n\nAgrega la posibilidad de definir tipos (string, number, boolean etc.) a las variables que creamos. Con esta característica nos permite identificar problemas en nuestras aplicaciones en tiempo de compilación. Esta característica ayuda que nuestro programa sea más legible.\nEl origen del nombre de este lenguaje \"TypeScript\" es por la posibilidad de definir tipos (Type)  a las variables.\n\nDefinición de sintaxis más claras en la declaración de clases y sus propiedades.\nDefinición de herencia de clases e implementación de interfaces.\nDefinición propiedades privadas, protegidas y públicas.\nCaptura de errores cuando se compila el programa en TypeScript.\n\n\nTypeScript es un lenguaje creado por Microsoft y de distribución libre, el sitio oficial del lenguaje donde podemos consultar su documentación más actual está aquí. De todos modos recordemos que no necesitamos descargarlo e instalarlo ya que Angular CLI siempre hace esto por nosotros cada vez que creamos un proyecto."
  },
  {
    "title": "52 - TypeScript: tipado estático",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=52&codigo=52&inicio=40",
    "content": "Los lenguajes con tipado estático permiten detectar errores de asignación en tiempo de desarrollo.\nPor ejemplo si tenemos la definición de una variable 'number' y luego queremos asignarle un 'string' la herramienta de desarrollo la puede detectar (también si lo compilamos nos detecta un error)\nPara probar los conceptos de TypeScript podemos crear un proyecto:\nng new proyecto036\n\n\nJavaScript es un lenguaje de programación que usa un tipado dinámico, luego la comprobación de tipificación se realiza durante su ejecución en vez de durante la compilación.\nPara activar en VSCode la verificación de tipos en TypeScript debemos entrar a la opción de \"Configuración\" y buscar \"typescript validate\" y proceder a activarlo:\n\nLuego podemos probar en nuestro proyecto definir una variable de tipo number y posteriormente tratar de asignarle un string:\n\n\n\nTipo de datos básicos soportados por TypeScript. \n\n\nnumber\nPermite almacenar tanto valores enteros como reales.\nlet edad: number = 23;\nlet altura: number = 1.92;\n\nSi inicializamos la variable inmediatamente podemos dejar que TypeScript infiera el tipo de dato, es decir es lo mismo que escribir:\nlet edad = 23;\nlet altura = 1.92;\n\n\n\nstring\nPermite almacenar una cadena de caracteres:\nlet estudios:string = 'primarios';\n\nPodemos almacenar entre las comillas cualquier caracter.\n\n\nboolean\nPodemos almacenar el valor true o false:\nlet activo: boolean = true;\n\n\n\nArreglos con elementos del mismo tipo\nPodemos almacenar un conjunto de elementos del mismo tipo mediante vectores o arreglos:\n    let vector: number[] = [1, 4, 2];\n    vector.push(33);\n    for(let elemento of vector)\n      console.log(elemento);\n\nIndicamos luego del tipo de dato los corchetes abiertos y cerrados:\n    let vector: number[]\n\nSi queremos definir e inicializar algunas componentes del arreglo luego la sintaxis es:\n    let vector: number[] = [1, 4, 2];\n\nEl compilador de TypeScript nos podrá avisar del error si queremos agregar componentes que no sean de tipo 'number':\n    vector.push('juan'); //error\n\nOtra sintaxis para definir un arreglo en TypeScript es mediante genéricos utilizando la clase Array:\n    let vector: Array<number> = [1, 4, 2];\n    vector.push(33);\n    for(let elemento of vector)\n      console.log(elemento);\n\n\nPodemos probar dentro de una aplicación Angular los códigos anteriores implementando el método ngOnInit que pertenece a la interfaz OnInit.\nLa interfaz OnInit forma parte del ciclo de vida del componente de Angular. Se ejecuta después de que Angular ha creado el componente y ha configurado sus propiedades de entrada, pero antes de que se presente en la vista.\nPuede utilizar este método para realizar acciones específicas que deben llevarse a cabo justo después de que el componente se haya inicializado.\nimport { Component, OnInit } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n  title = \"Prueba TypeScript\";\n\n  ngOnInit() {\n    let vector: number[] = [1, 4, 2];\n    vector.push(33);\n    for (let elemento of vector)\n      console.log(elemento);\n  }\n\n}\n\nLuego si ejecutamos la aplicación y abrimos la consola del navegador podemos ver los valores almacenados en el vector:\n\n\n \n\n\nenum\nEl tipo de dato enum permite hacer nuestro código más legible:\nimport { Component, OnInit } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\nenum Operacion {Suma, Resta, Multiplicacion, Division};\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n  title = \"Prueba TypeScript\";\n\n\n  ngOnInit() {\n    let operacion: Operacion = Operacion.Multiplicacion;\n    this.mostrarOperacion(operacion);\n  }\n\n  mostrarOperacion(operacion:Operacion) {\n    switch (operacion) {\n      case Operacion.Suma: {\n        console.log('Operación actual: Suma ');\n        break;\n      }\n      case Operacion.Resta: {\n        console.log('Operación actual: Resta ');\n        break;\n      }\n      case Operacion.Multiplicacion: {\n        console.log('Operación actual: Multiplicacion ');\n        break;\n      }\n      case Operacion.Division: {\n        console.log('Operación actual: Division ');\n        break;\n      }\n    }\n  }\n}\n\nEstamos declarando un nuevo tipo de dato que puede almacenar alguno de los cuatro valores indicados entre llaves:\n    enum Operacion {Suma, Resta, Multiplicacion, Division};\n\nLuego podemos definir una variable de este tipo y almacenar uno de esos cuatro valores:\n    let operacion: Operacion = Operacion.Multiplicacion;\n\nCuando queremos saber que valor almacena la variable 'operacion' la comparamos por ejemplo con los valores posibles del tipo 'Operacion':\n  mostrarOperacion(operacion:Operacion) {\n    switch (operacion) {\n      case Operacion.Suma: {\n        console.log('Operación actual: Suma ');\n        break;\n      }\n      case Operacion.Resta: {\n        console.log('Operación actual: Resta ');\n        break;\n      }\n      case Operacion.Multiplicacion: {\n        console.log('Operación actual: Multiplicacion ');\n        break;\n      }\n      case Operacion.Division: {\n        console.log('Operación actual: Division ');\n        break;\n      }\n    }\n  }\n\n\nEs una forma más elegante que tratar de resolver el problema con una variable de tipo 'number':\nimport { Component, OnInit } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n  title = \"Prueba TypeScript\";\n\n\n  ngOnInit() {\n    let operacion = 2; // significado 0 = suma / 1 = resta / 2 = multiplicacion / 3 = division\n    this.mostrarOperacion(operacion);\n  }\n\n  mostrarOperacion(operacion: number) {\n    switch (operacion) {\n      case 0: {\n        console.log('Operación actual: Suma ');\n        break;\n      }\n      case 1: {\n        console.log('Operación actual: Resta ');\n        break;\n      }\n      case 2: {\n        console.log('Operación actual: Multiplicacion ');\n        break;\n      }\n      case 3: {\n        console.log('Operación actual: Division ');\n        break;\n      }\n    }\n  }\n}\n\n\n\n\nany\nEn las situaciones que debemos almacenar un dato en una variable y no sabemos de antemano que tipo se trata, TypeScript incorpora el tipo 'any'.\nEs un tipo de dato que debemos evitarlo en lo posible ya que el compilador no nos puede ayudar y debemos esperar a ejecutar el programa para identificar errores.\nCuando utilizamos librerías heredadas de JavaScript es muy posible que nos veamos obligados a utilizar este tipo de dato.\n    let dato: any;\n    dato = 10;\n    console.log(dato);\n    dato = 'Hola';\n    console.log(dato);\n    dato = true;\n    console.log(dato);        \n    dato = [1,2,3];\n    console.log(dato);\n\nLa variable dato muta su tipo a lo largo de la ejecución del algoritmo, primero es number, luego string, boolean y finalmente de tipo Array.\nPodemos definir un Array con elementos de distinto tipo:\n    let vec: any[] = [10, 'Inicio', true];\n\n\n\n\n\nParámetros de métodos. \nTambién cuando definimos funciones o métodos debemos definir el tipo de dato de los mismos:\n\n  mayor(valor1: number, valor2: number): number {\n    if (valor1 > valor2)\n      return valor1;\n    else\n      return valor2;\n  }\n\nEl método mayor recibe dos parámetros de tipo 'number' y retorna un tipo de dato 'number' que lo indicamos luego de los dos puntos.\nSi no retorna dato un método podemos utilizar el tipo 'void':\nexport class AppComponent {\n\n  constructor() {\n    this.mostrarMensaje('Hola mundo');\n  }\n\n  mostrarMensaje(mensaje: string): void {\n    alert(mensaje);\n  }\n\n}\n\n\nVariable de tipo unión.\nTypeScript permite definir variables que almacenen dos o más tipos de datos. Puede almacenar un único valor en un determinado momento, pero dicho valor puede variar entre los tipos indicados en la definición:\nlet edad: number | string;\nedad=34;\nconsole.log(edad);\nedad='20 años';\nconsole.log(edad);\n\nMediante el caracter | separamos los tipos posibles de datos que puede almacenar la variable. La variable 'edad' puede almacenar un valor de tipo 'number' o 'string':\nlet edad: number | string;"
  },
  {
    "title": "53 - TypeScript: clases",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=53&codigo=53&inicio=40",
    "content": "TypeScript incorpora muchas características de la programación orientada a objetos disponibles en lenguajes como Java y C#.\nLa sintaxis básica de una clase puede ser:\nclass Persona {\n  nombre: string;\n  edad: number;\n\n  constructor(nombre:string, edad:number) {\n    this.nombre = nombre;\n    this.edad = edad;\n  }\n\n  imprimir() {\n    console.log(`Nombre: ${this.nombre} y edad:${this.edad}`);\n  }\n}\n\nlet persona1: Persona;\npersona1 = new Persona('Juan', 45);\npersona1.imprimir();\n\nLos atributos se definen fuera de los métodos. Para acceder a los mismos dentro de los métodos debemos anteceder la palabra clave 'this':\n  imprimir() {\n    console.log(`Nombre: ${this.nombre} y edad:${this.edad}`);\n  }\n\nEl constructor es el primer método que se ejecuta en forma automática al crear un objeto de la clase 'Persona':\n  constructor(nombre:string, edad:number) {\n    this.nombre = nombre;\n    this.edad = edad;\n  }\n\n\nPodemos probar este código agregándolo previo a la componente y luego ver la consola del navegador:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\nclass Persona {\n  nombre: string;\n  edad: number;\n\n  constructor(nombre: string, edad: number) {\n    this.nombre = nombre;\n    this.edad = edad;\n  }\n\n  imprimir() {\n    console.log(`Nombre: ${this.nombre} y edad:${this.edad}`);\n  }\n}\n\nlet persona1: Persona;\npersona1 = new Persona('Juan', 45);\npersona1.imprimir();\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = \"Prueba TypeScript\";\n}\n\nEn la consola comprobamos los valores:\n\n\nModificadores de acceso a propiedades y métodos.\nPodemos definir propiedades y métodos privados y públicos antecediendo las palabras claves 'private' y 'public'.\nVeamos un ejemplo:\nclass Dado {\n  private valor: number = 1;\n\n  public tirar() {\n    this.generar();\n  }\n\n  private generar() {\n    this.valor = Math.floor(Math.random() * 6) + 1;\n  }\n\n  public imprimir() {\n    console.log(`Salió el valor ${this.valor}`);\n  }\n}\n\nlet dado1 = new Dado();\ndado1.tirar();\ndado1.imprimir();\n\nEl objeto 'dado1' tiene acceso a todos los atributos y métodos que tienen el modificador 'public' por eso podemos llamar a los métodos 'tirar' e 'imprimir':\ndado1.tirar();\ndado1.imprimir();\n\nSe generará un error si queremos acceder al atributo 'valor' o al método 'generar':\n\n\n\nSi no agregamos modificador de acceso por defecto es 'public', luego tendremos el mismo resultado si utilizamos la siguiente sintaxis para declarar la clase:\nclass Dado {\n  private valor: number = 1;\n\n  tirar() {\n    this.generar();\n  }\n\n  private generar() {\n    this.valor = Math.floor(Math.random() * 6) + 1;\n  }\n\n  imprimir() {\n    console.log(`Salió el valor ${this.valor}`);\n  }\n}\n\nlet dado1=new Dado();\ndado1.tirar();\ndado1.imprimir();\n\nEs decir nos ahorramos de escribir 'public' antes de las propiedades y métodos que queremos definir con esta característica.\n\nTodo atributo de una clase debe inicializarse cuando se lo define o en el constructor, sino se genera un error.\nSi por algún motivo no queremos inicializar el atributo, debemos utilizar el modificador \"!\" (Non-null assertion operator)\nPodemos indicar a TypeScript que confíe en que la propiedad no será nula utilizando el operador de afirmación de no nulo (!). Sin embargo, debes estar seguro de que nunca intentarás acceder a la propiedad antes de que se le haya asignado un valor:\nclass Dado {\n  private valor!: number;\n\n  public tirar() {\n    this.generar();\n  }\n\n  private generar() {\n    this.valor = Math.floor(Math.random() * 6) + 1;\n  }\n\n  public imprimir() {\n    console.log(`Salió el valor ${this.valor}`);\n  }\n}\n\nlet dado1 = new Dado();\ndado1.tirar()\ndado1.imprimir()\n\nLuego si nos olvidamos de llamar al método 'tirar' y llamamos al método imprimir, se mostrará el valor 'undefined' que es el contenido en el atributo 'valor'.\n\nDefinición e inicialización de propiedades en los parámetros del constructor.\nEsta característica no es común en otros lenguajes orientados a objetos y tiene por objetivo crear clases más breves.\nEn TypeScript podemos definir algunas propiedades de la clase en la zona de parámetros del constructor, con esto nos evitamos de su declaración fuera de los métodos.\nPor ejemplo la clase Persona la podemos codificar con ésta otra sintaxis:\nclass Persona {\n\n  constructor(public nombre:string, public edad:number) { }\n\n  imprimir() {\n    console.log(`Nombre: ${this.nombre} y edad:${this.edad}`);\n  }\n}\n\nlet persona1: Persona;\npersona1 = new Persona('Juan', 45);\npersona1.imprimir();\n\n\nComo vemos el constructor tiene un bloque de llaves vacías ya que no tenemos que implementar ningún código en su interior, pero al anteceder el modificador de acceso en la zona de parámetros los mismos pasan a ser propiedades de la clase y no parámetros:\n  constructor(public nombre:string, public edad:number) { }\n\nPodemos sin problemas definir propiedades tanto 'public' como 'private'.\nLa definición de propiedades en la zona de parámetros solo se puede hacer en el constructor de la clase y no está permitido en cualquier otro método.\n\nModificador readonly\nDisponemos además de los modificadores 'private' y 'public' uno llamado 'readonly'. Mediante este modificador el valor de la propiedad solo puede ser cargado en el constructor o al momento de definirlo y luego no puede ser modificado ni desde un método de la clase  o fuera de la clase.\nVeamos un ejemplo con una propiedad 'readonly':\nclass Articulo {\n  readonly codigo: number;\n  descripcion: string;\n  precio: number;\n\n  constructor(codigo:number, descripcion:string, precio:number) {\n    this.codigo=codigo;\n    this.descripcion=descripcion;\n    this.precio=precio;\n  }\n\n  imprimir() {\n    console.log(`Código:${this.codigo} Descripción:${this.descripcion} Precio:${this.precio}`);\n  }\n}\n\nlet articulo1: Articulo;\narticulo1 = new Articulo(1,'papas',12.5);\narticulo1.imprimir();\n\n\nUna vez que se inicia la propiedad 'codigo' en el constructor su valor no puede cambiar:\n  imprimir() {\n    this.codigo=7; //Error\n    console.log(`Código:${this.codigo} Descripción:${this.descripcion} Precio:${this.precio}`);\n  }\n\nEl mismo error se produce si tratamos de cambiar su valor desde fuera de la clase:\nlet articulo1: Articulo;\narticulo1 = new Articulo(1,'papas',12.5);\narticulo1.codigo=7; //Error\narticulo1.imprimir();\n\n\nPodemos utilizar también la sintaxis abreviada de propiedades:\nclass Articulo {\n\n  constructor(readonly codigo:number, public descripcion:string, public precio:number) { }\n\n  imprimir() {\n    console.log(`Código:${this.codigo} Descripción:${this.descripcion} Precio:${this.precio}`);\n  }\n}\n\n\n\nPropiedades estáticas\nLas propiedades estáticas pertenecen a la clase y no a las instancias de la clase. Se las define antecediendo el modificador 'static'.\nCon un ejemplo quedará claro este tipo de propiedades:\nclass Dado {\n  private valor: number = 1;\n  static tiradas:number=0;\n  tirar() {\n    this.generar();\n  }\n\n  private generar() {\n    this.valor = Math.floor(Math.random() * 6) + 1 ;\n    Dado.tiradas++;\n  }\n\n  imprimir() {\n    console.log(`Salió el valor ${this.valor}`);\n  }\n}\n\nlet dado1=new Dado();\ndado1.tirar();\ndado1.imprimir();\nlet dado2=new Dado();\ndado2.tirar();\ndado2.imprimir();\nconsole.log(`Cantidad de tiradas de dados:${Dado.tiradas}`); // 2\n\nUna propiedad estática requiere el modificador 'static' previo a su nombre:\n  static tiradas:number=0;\n\nPara acceder a dichas propiedades debemos anteceder el nombre de la clase y no la palabra clave 'this':\n    Dado.tiradas++;\n\nNo importan cuantos objetos de la clase se definan luego todos esos objetos comparten la misma variable estática:\nlet dado1=new Dado();\ndado1.tirar();\ndado1.imprimir();\nlet dado2=new Dado();\ndado2.tirar();\ndado2.imprimir();\nconsole.log(`Cantidad de tiradas de dados:${Dado.tiradas}`); // 2\n\nEs por eso que la propiedad 'tiradas' almacena un 2 luego de tirar el primer y segundo dado.\nLa propiedad 'valor' es independiente en cada dado pero la propiedad 'tiradas' es compartida por los dos objetos.\n\n\nMétodos estáticas\nIgual que las propiedades estáticas los métodos estáticos se los accede por el nombre de la clase. Este tipo de métodos solo pueden acceder a propiedades estáticas.\nclass Matematica {\n  static mayor(v1:number, v2: number): number {\n    if (v1>v2)\n      return v1;\n    else\n      return v2;\n  }\n\n  static menor(v1:number, v2: number): number {\n    if (v1<v2)\n      return v1;\n    else\n      return v2;\n  }\n\n  static aleatorio(inicio: number, fin: number): number {\n    return Math.floor((Math.random()*(fin+1-inicio))+inicio);\n  }\n}\n\nlet x1=Matematica.aleatorio(1,10);\nlet x2=Matematica.aleatorio(1,10);\nconsole.log(`El mayor entre ${x1} y ${x2} es ${Matematica.mayor(x1,x2)} `);\nconsole.log(`El menor entre ${x1} y ${x2} es ${Matematica.menor(x1,x2)}`);\n\nDebemos anteceder la palabra clave static al nombre del método.\nCuando llamamos a un método debemos anteceder también el nombre de la clase, no hace falta definir una instancia u objeto de la clase:\nlet x1=Matematica.aleatorio(1,10);"
  },
  {
    "title": "54 - TypeScript: funciones y métodos",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=54&codigo=54&inicio=40",
    "content": "TypeScript aporta varias características que JavaScript no dispone hasta el momento cuando tenemos que plantear funciones y métodos.\nParámetros tipados y funciones que retornan un valor.\nPodemos indicar a cada parámetro el tipo de dato que puede recibir y también el tipo de dato que retorna la función o método en caso que estemos en una clase:\nfunction sumar(valor1:number, valor2:number): number {\n  return valor1+valor2;\n}\n\nconsole.log(sumar(10, 5));\n\nLa función sumar recibe dos parámetros de tipo number y retorna un valor de tipo number. Luego si llamamos a esta función enviando un valor distinto a number el compilador nos avisará del error:\nconsole.log(sumar('juan', 'carlos'));\n\nSe genera un error: Argument of type 'string' is not assignable to parameter of type 'number'.\nInclusive editores de texto moderno como Visual Studio Code pueden antes de compilarse avisar del error.\nEl tipado estático favorece a identificar este tipo de errores antes de ejecutar la aplicación. Lo mismo cuando una función retorna un dato debemos indicar al final de la misma dicho tipo:\nfunction sumar(valor1:number, valor2:number): number {\n\nLa función sumar retorna un valor de tipo number.\nLuego si la función retorna un tipo distinto a number se genera un error:\nfunction sumar(valor1:number, valor2:number): number {\n  return 'Hola mundo';\n}\n\nComo estamos retornando un string se genera el error:  Type 'string' is not assignable to type 'number'\n\nFunciones anónimas.\nUna función anónima no especifica un nombre. Son semejantes a JavaScript con la salvedad de la definición de tipos para los parámetros:\nconst funcSumar = function (valor1:number, valor2:number): number {\n  return valor1 + valor2;\n}\n\nconsole.log(funcSumar(4, 9));\n\n\nParámetros opcionales.\nEn TypeScript debemos agregar el caracter '?' al nombre del parámetro para indicar que el mismo puede o no llegar un dato:\nfunction sumar(valor1: number, valor2: number, valor3?: number): number {\n  if (valor3)\n    return valor1 + valor2 + valor3;\n  else\n    return valor1 + valor2;\n}\n\nconsole.log(sumar(5, 4));\nconsole.log(sumar(5, 4, 3));\n\nEl tercer parámetro es opcional:\nfunction sumar(valor1: number, valor2: number, valor3?: number): number {\n\nLuego a la función 'sumar' la podemos llamar pasando 2 o 3 valores numéricos:\nconsole.log(sumar(5,4));\nconsole.log(sumar(5,4,3));\n\nSi pasamos una cantidad de parámetros distinta a 2 o 3 se genera un error en tiempo de compilación: ' error TS2554: Expected 2-3 arguments, but got 4.'\n\nLos parámetros opcionales deben ser los últimos parámetros definidos en la función. Puede tener tantos parámetros opcionales como se necesiten.\n\n\nParámetros por defecto.\nEsta característica de TypeScript nos permite asignar un valor por defecto a un parámetro para los casos en que la llamada a la misma no se le envíe.\nfunction sumar(valor1: number, valor2: number, valor3: number = 0): number {\n  return valor1 + valor2 + valor3;\n}\n\nconsole.log(sumar(5, 4));\nconsole.log(sumar(5, 4, 3));\n\nEl tercer parámetro almacena un cero si no se lo pasamos en la llamada:\nconsole.log(sumar(5, 4));\n\nPuede haber varios valores por defecto, pero deben ser los últimos. Es decir primero indicamos los parámetros que reciben datos en forma obligatoria cuando los llamamos y finalmente indicamos aquellos que tienen valores por defecto.\n\nparámetros Rest.\nOtra característica de TypeScript es la posibilidad de pasar una lista indefinida de valores y que los reciba un vector.\nEl concepto de parámetro Rest se logra antecediendo tres puntos al nombre del parámetro:\nfunction sumar(...valores: number[]) {\n  let suma = 0;\n  for (let x = 0; x < valores.length; x++)\n    suma += valores[x];\n  return suma;\n}\n\nconsole.log(sumar(10, 2, 44, 3));\nconsole.log(sumar(1, 2));\nconsole.log(sumar());\n\nEl parámetro 'valores' se le anteceden los tres puntos seguidos e indicamos que se trata de un vector de tipo 'number'. Cuando llamamos a la función le pasamos una lista de valores enteros que luego la función los empaqueta en el vector:\nconsole.log(sumar(10, 2, 44, 3));\nconsole.log(sumar(1, 2));\nconsole.log(sumar());\n\nLa función con un parámetro Rest puede tener otros parámetros pero se deben declarar antes.\nLos parámetros Rest no pueden tener valores por defecto.\n\noperador Spread.\nEl operador Spread permite descomponer una estructura de datos en elementos individuales. Es la operación inversa de los parámetros Rest.\nLa sintaxis se aplica anteponiendo al nombre de la variable tres puntos:\nfunction sumar(valor1: number, valor2: number, valor3: number): number {\n  return valor1 + valor2 + valor3;\n}\n\nconst vec: [number, number, number] = [10, 20, 30];\nconst s = sumar(...vec);\nconsole.log(s);\n\nOtra cosa importante es hacer notar  que el arreglo indicamos el tipo para cada elemento.\n\nFunciones callbacks\nUna función callback es una función que se pasa a otra función como parámetro y dentro de la misma es llamada.\nfunction operar(valor1: number, valor2: number, func: (x: number, y:number)=>number): number {\n  return func(valor1, valor2);\n}\n\nconsole.log(operar(3, 7, (x: number,y: number): number => {\n  return x+y;\n}))\n\nconsole.log(operar(3, 7, (x: number,y: number): number => {\n  return x-y;\n}))\n\nconsole.log(operar(3, 7, (x: number,y: number): number => {\n  return x*y;\n}))\n\nLa función operar recibe tres parámetros, los dos primeros son de tipo 'number' y el tercero es de tipo función:\nfunction operar(valor1: number, valor2: number, func: (x: number, y:number)=>number): number {\n\nLa función que debe recibir debe tener como parámetros dos 'number' y retornar un 'number'.\nCuando llamamos a la función además de los dos enteros le debemos pasar una función que reciba dos 'number' y retorne un 'number':\nconsole.log(operar(3, 7, (x: number,y: number): number => {\n  return x+y;\n}))\n\nComo podemos observar llamamos a la función 'operar' tres veces y le pasamos funciones que procesan los dos enteros para obtener su suma, resta y multiplicación.\nPodemos llamar a la función 'operar' con una sintaxis más concisa como en JavaScript:\nconsole.log(operar(3, 7, (x: number,y: number): number => x+y))\nconsole.log(operar(3, 7, (x: number,y: number): number => x-y))\nconsole.log(operar(3, 7, (x: number,y: number): number => x*y))\n\n\nPara hacer más claro nuestro código TypeScript mediante la palabra clave type permite crear nuevos tipos y luego reutilizarlos:\ntype Operacion = (x: number, y: number) => number;\n\nfunction operar(valor1: number, valor2: number, func: Operacion): number {\n  return func(valor1, valor2);\n}\n\nconsole.log(operar(3, 7, (x: number, y: number): number => x + y))\nconsole.log(operar(3, 7, (x: number, y: number): number => x - y))\nconsole.log(operar(3, 7, (x: number, y: number): number => x * y))\n\nEl tipo Operacion tiene la firma de una función con dos parámetros de tipo 'number' y el retorno de un 'number'. Luego cuando declaramos la función operar definimos el tercer parámetro llamado 'func' de tipo 'Operacion':\nfunction operar(valor1: number, valor2: number, func: Operacion): number {\n\n\n\n\nParámetros de tipo unión.\nVimos en otro concepto que podemos definir variables que pueden almacenar más de un tipo de dato indicando los mismos el operador '|':\nlet edad: number | string;\nedad=34;\nconsole.log(edad);\nedad='20 años';\nconsole.log(edad);\n\nCon parámetros podemos utilizar la misma sintaxis:\nfunction sumar(valor1: number | string, valor2: number | string ): number | string  {\n  if (typeof valor1 ==='number' && typeof valor2 ==='number')\n    return valor1+valor2;\n  else \n    return valor1.toString() + valor2.toString();\n}\n\nconsole.log(sumar(4, 5));\nconsole.log(sumar('Hola ', 2));\nconsole.log(sumar('Hola ', 'Mundo'));\n\nEn este tipo de caso deberemos identificar que operación realizar según los tipos de datos de los parámetros. En el ejemplo si los dos parámetros se reciben tipos de datos 'number' procedemos a sumarlos como enteros:\n  if (typeof valor1 ==='number' && typeof valor2 ==='number')\n    return valor1+valor2;\n\nEn el caso contrario con que uno de los dos valores sea de tipo 'string' procedemos a concatenarlos, previamente los convertimos a string:\n  else \n    return valor1.toString() + valor2.toString();\n\n\nAcotaciones\nHemos hecho siempre ejemplos con funciones, pero todos estos conceptos se aplican si planteamos métodos dentro de una clase:\nclass Operacion {\n  sumar(...valores:number[]) {\n    let suma=0;\n    for(let x=0;x<valores.length;x++)\n      suma+=valores[x];\n    return suma;\n  }\n}\n\nlet op: Operacion;\nop=new Operacion();\nconsole.log(op.sumar(1,2,3));"
  },
  {
    "title": "55 - TypeScript: herencia",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=55&codigo=55&inicio=40",
    "content": "La herencia es otra característica fundamental de la programación orientada a objetos y TypeScript lo implementa.\nLa herencia significa que se pueden crear nuevas clases partiendo de clases existentes, que tendrá todas los atributos y los métodos de su 'superclase' o 'clase padre' y además se le podrán añadir otros atributos y métodos propios.\nVeamos con un ejemplo la sintaxis que plantea TypeScript para implementar la herencia:\nclass Persona {\n  protected nombre: string;\n  protected edad: number;\n  constructor(nombre: string, edad: number) {\n    this.nombre = nombre;\n    this.edad = edad;\n  }\n\n  imprimir() {\n    console.log(`Nombre: ${this.nombre}`);\n    console.log(`Edad: ${this.edad}`);\n  }\n}\n\nclass Empleado extends Persona {\n  private sueldo: number;\n  constructor(nombre: string, edad: number, sueldo: number) {\n    super(nombre, edad);\n    this.sueldo = sueldo;\n  }\n\n  override imprimir() {\n    super.imprimir();\n    console.log(`Sueldo: ${this.sueldo}`);\n  }\n\n  pagaImpuestos() {\n    if (this.sueldo > 5000)\n      console.log(`${this.nombre} debe pagar impuestos`);\n    else\n      console.log(`${this.nombre} no debe pagar impuestos`);\n  }\n}\n\n\nEl resultado de ejecutar en la consola del navegador es (recordar que la consola la podemos abrir desde el navegador presionando la tecla F12 ):\n\nMediante la palabra clave extends indicamos el nombre de la clase padre. Una clase puede heredar de una sola clase (en este ejemplo 'Persona'):\nclass Empleado extends Persona {\n  private sueldo: number;\n  constructor(nombre: string, edad: number, sueldo: number) {\n    super(nombre, edad);\n    this.sueldo = sueldo;\n  }\n\nLa subclase Empleado puede acceder a las propiedades de la clase padre si los mismos se definieron en forma public o protected, debemos agregar la palabra clave 'override' para sobreescribir un método de la clase padre:\n  override imprimir() {\n    super.imprimir();\n    console.log(`Sueldo: ${this.sueldo}`);\n  }\n\nCon el modificador protected permitimos que la subclase pueda acceder a los atributos de la clase padre pero luego donde definamos un objeto de esta clase no los pueda acceder y permanezcan encapsulados:\nconst empleado1=new Empleado('Ana', 22, 7000);\nempleado1.nombre='facundo'; //error\n\n\nClases abstractas\nEn algunas situaciones tenemos métodos y propiedades comunes a un conjunto de clases, podemos agrupar dichos métodos y propiedades en una clase abstracta.\nHay una sintaxis especial en TypeScript para indicar que una clase es abstracta.\nNo se pueden definir objetos de una clase abstracta y seguramente será heredada por otras clases de las que si podremos definir objetos.\nProblema: Declarar una clase abstracta que represente una Operación. Definir en la misma tres propiedades valor1, valor2 y resultado, y tres métodos: constructor, imprimir y operar (éste último hacerlo abstracto). Plantear dos clases llamadas Suma y Resta que hereden de la clase Operación e implementen el método abstracto operar.\nabstract class Operacion {\n  public valor1: number;\n  public valor2: number;\n  public resultado: number = 0;\n\n  constructor(v1: number, v2: number) {\n    this.valor1 = v1;\n    this.valor2 = v2;\n  }\n\n  abstract operar(): void;\n\n  imprimir() {\n    console.log(`Resultado: ${this.resultado}`);\n  }\n}\n\nclass Suma extends Operacion {\n  constructor(v1: number, v2: number) {\n    super(v1, v2);\n  }\n\n  operar() {\n    this.resultado = this.valor1 + this.valor2;\n  }\n}\n\nclass Resta extends Operacion {\n  constructor(v1: number, v2: number) {\n    super(v1, v2);\n  }\n\n  operar() {\n    this.resultado = this.valor1 - this.valor2;\n  }\n}\n\nlet suma1: Suma;\nsuma1 = new Suma(10, 4);\nsuma1.operar();\nsuma1.imprimir();\n\nlet resta1: Resta;\nresta1 = new Resta(10, 4);\nresta1.operar();\nresta1.imprimir();\n\nMediante la palabra clave abstract indicamos que la clase debe definirse como abstracta, luego no se pueden definir objetos de la clase Operacion:\nabstract class Operacion {\n  public valor1: number;\n  public valor2: number;\n  public resultado: number = 0;\n\n  constructor(v1: number, v2: number) {\n    this.valor1 = v1;\n    this.valor2 = v2;\n  }\n\n  abstract operar(): void;\n\n  imprimir() {\n    console.log(`Resultado: ${this.resultado}`);\n  }\n}\n\nDentro de la clase abstracta definimos un método abstracto llamado operar, esto obliga a todas las clases que heredan de 'Operacion' implementar el algoritmo de dicho método, sino se genera un error en tiempo de compilación.\n\nLa subclase Suma al heredar de Operación implementa el método operar:\nclass Suma extends Operacion {\n  constructor(v1: number, v2: number) {\n    super(v1, v2);\n  }\n\n  operar() {\n    this.resultado = this.valor1 + this.valor2;\n  }\n}\n\nSolo podemos definir objetos de las clases Suma y Resta. Se genera un error si tratamos de crear un objeto de la clase Operacion:\nlet suma1: Suma;\nsuma1=new Suma(10, 4);\nsuma1.operar();\nsuma1.imprimir();"
  },
  {
    "title": "56 - TypeScript: interfaces",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=56&codigo=56&inicio=40",
    "content": "Una interface declara una serie de métodos y propiedades que deben ser implementados luego por una o más clases.\nLas interfaces vienen a suplir la imposibilidad de herencia múltiple.\n\nPor ejemplo podemos tener dos clases que representen un avión y un helicóptero. Luego plantear una interface con un método llamado volar. Las dos clases pueden implementar dicha interface y codificar el método volar (los algoritmos seguramente sean distintos pero el comportamiento de volar es común tanto a un avión como un helicóptero)\nLa sintaxis en TypeScript para declarar una interface es:\ninterface [nombre de la interface] {\n    [declaración de propiedades]\n    [declaración de métodos]\n}\n\n\n\nProblema\nDefinir una interface llamada Punto que declare un método llamado imprimir. Luego declarar dos clases que la implementen.\ninterface Punto {\n  imprimir(): void;\n}\n\nclass PuntoPlano implements Punto {\n  constructor(private x: number, private y: number) { }\n\n  imprimir() {\n    console.log(`Punto en el plano: (${this.x},${this.y})`);\n  }\n}\n\nclass PuntoEspacio implements Punto {\n  constructor(private x: number, private y: number, private z: number) { }\n\n  imprimir() {\n    console.log(`Punto en el espacio: (${this.x},${this.y},${this.z})`);\n  }\n}\n\n\nlet puntoPlano1: PuntoPlano;\npuntoPlano1 = new PuntoPlano(10, 4);\npuntoPlano1.imprimir();\n\nlet puntoEspacio1: PuntoEspacio;\npuntoEspacio1 = new PuntoEspacio(20, 50, 60);\npuntoEspacio1.imprimir();\n\n\nPara declarar una interface en TypeScript utilizamos la palabra clave interface y seguidamente su nombre. Luego entre llaves indicamos todas las cabeceras de métodos y propiedades. En nuestro ejemplo declaramos la interface Punto e indicamos que quien la implemente debe definir un método llamado imprimir sin parámetros y que no retorna nada:\ninterface Punto {\n  imprimir(): void;\n}\n\n\nPor otro lado declaramos dos clases llamados PuntoPlano con dos propiedades y PuntoEspacio con tres propiedades, además indicamos que dichas clases implementarán la interface Punto:\nclass PuntoPlano implements Punto {\n  constructor(private x: number, private y: number) { }\n\n  imprimir() {\n    console.log(`Punto en el plano: (${this.x},${this.y})`);\n  }\n}\n\nclass PuntoEspacio implements Punto {\n  constructor(private x: number, private y: number, private z: number) { }\n\n  imprimir() {\n    console.log(`Punto en el espacio: (${this.x},${this.y},${this.z})`);\n  }\n}\n\nLa sintaxis para indicar que una clase implementa una interface requiere disponer la palabra clave implements y en forma seguida el o los nombres de interfaces a implementar. Si una clase hereda de otra también puede implementar una o más interfaces.\nEl método imprimir en cada clase se implementa en forma distinta, en uno se imprimen 3 propiedades y en la otra se imprimen 2 propiedades.\nLuego definimos un objeto de la clase PuntoPlano y otro de tipo PuntoEspacio:\nlet puntoPlano1: PuntoPlano;\npuntoPlano1 = new PuntoPlano(10, 4);\npuntoPlano1.imprimir();\n\nlet puntoEspacio1: PuntoEspacio;\npuntoEspacio1 = new  PuntoEspacio(20, 50, 60);\npuntoEspacio1.imprimir();\n\n\nSi una clase indica que implementa una interfaz y luego no se la codifica, se genera un error en tiempo de compilación informándonos de tal situación (inclusive el editor Visual Studio Code detecta dicho error antes de compilar):\nprueba.ts(5,7): error TS2420: Class 'PuntoPlano' incorrectly implements interface 'Punto'.\n  Property 'imprimir' is missing in type 'PuntoPlano'.\nprueba.ts(20,13): error TS2339: Property 'imprimir' does not exist on type 'PuntoPlano'.\n\nEste error se produce si codificamos la clase sin implementar el método imprimir:\nclass PuntoPlano implements Punto{\n  constructor(private x:number, private y:number) {}\n}\n\n\nProblema\nSe tiene la siguiente interface:\ninterface Figura {\n  superficie: number;\n  perimetro: number;\n  calcularSuperficie(): number;\n  calcularPerimetro(): number;\n}\n\nDeclar dos clases que representen un Cuadrado y un Rectángulo. Implementar la interface Figura en ambas clases.\n\ninterface Figura {\n  superficie: number;\n  perimetro: number;\n  calcularSuperficie(): number;\n  calcularPerimetro(): number;\n}\n\n\nclass Cuadrado implements Figura {\n  superficie: number;\n  perimetro: number;\n  constructor(private lado:number) {\n    this.superficie = this.calcularSuperficie();\n    this.perimetro = this.calcularPerimetro();\n  }\n\n  calcularSuperficie(): number {\n    return this.lado * this.lado;\n  }\n\n  calcularPerimetro(): number {\n    return this.lado * 4;\n  }  \n}\n\n\nclass Rectangulo implements Figura {\n  superficie: number;\n  perimetro: number;\n  constructor(private ladoMayor:number, private ladoMenor:number) {\n    this.superficie = this.calcularSuperficie();\n    this.perimetro = this.calcularPerimetro();\n  }\n\n  calcularSuperficie(): number {\n    return this.ladoMayor * this.ladoMenor;\n  }\n\n  calcularPerimetro(): number {\n    return (this.ladoMayor * 2) + (this.ladoMenor * 2);\n  }  \n}\n\n\nlet cuadrado1: Cuadrado;\ncuadrado1 = new Cuadrado(10);\nconsole.log(`Perimetro del cuadrado : ${cuadrado1.calcularPerimetro()}`);\nconsole.log(`Superficie del cuadrado : ${cuadrado1.calcularSuperficie()}`);\nlet rectangulo1: Rectangulo;\nrectangulo1 = new Rectangulo(10, 5);\nconsole.log(`Perimetro del rectangulo : ${rectangulo1.calcularPerimetro()}`);\nconsole.log(`Superficie del rectangulo: ${rectangulo1.calcularSuperficie()}`);\n\n\nEn este problema la interface Figura tiene dos métodos que deben ser implementados por las clases y dos propiedades que también deben definirlos:\ninterface Figura {\n  superficie: number;\n  perimetro: number;\n  calcularSuperficie(): number;\n  calcularPerimetro(): number;\n}\n\n\nLa clase Cuadrado indica que implementa la interface Figura, esto hace necesario que se implementen los métodos calcularSuperficie y calcularPerimetro, y las dos propiedades:\nclass Cuadrado implements Figura {\n  superficie: number;\n  perimetro: number;\n  constructor(private lado:number) {\n    this.superficie = this.calcularSuperficie();\n    this.perimetro = this.calcularPerimetro();\n  }\n\n  calcularSuperficie(): number {\n    return this.lado * this.lado;\n  }\n\n  calcularPerimetro(): number {\n    return this.lado * 4;\n  }  \n}\n\nLa clase Cuadrado tiene una propiedad llamada lado que la recibe el constructor.\n\nDe forma similar la clase Rectangulo implementa la interface Figura:\nclass Rectangulo implements Figura {\n  superficie: number;\n  perimetro: number;\n  constructor(private ladoMayor:number, private ladoMenor:number) {\n    this.superficie = this.calcularSuperficie();\n    this.perimetro = this.calcularPerimetro();\n  }\n\n  calcularSuperficie(): number {\n    return this.ladoMayor * this.ladoMenor;\n  }\n\n  calcularPerimetro(): number {\n    return (this.ladoMayor * 2) + (this.ladoMenor * 2);\n  }  \n}\n\n\nFinalmente definimos un objeto de la clase Cuadrado y otro de la clase Rectangulo, luego llamamos a los métodos  calcularPerimetro y calcularSuperficie para cada objeto:\nlet cuadrado1: Cuadrado;\ncuadrado1 = new Cuadrado(10);\nconsole.log(`Perimetro del cuadrado : ${cuadrado1.calcularPerimetro()}`);\nconsole.log(`Superficie del cuadrado : ${cuadrado1.calcularSuperficie()}`);\nlet rectangulo1: Rectangulo;\nrectangulo1 = new Rectangulo(10, 5);\nconsole.log(`Perimetro del rectangulo : ${rectangulo1.calcularPerimetro()}`);\nconsole.log(`Superficie del cuadrado : ${rectangulo1.calcularSuperficie()}`);\n\n\nLas interfaces exige que una clase siga las especificaciones de la misma y se implementen algoritmos más robustos. En nuestro ejemplo tanto la clase Rectangulo como Cuadrado tienen una forma similar de trabajar gracias a que implementan la interfaz Figura.\n\nParámetros de tipo interface.\nUn método o función puede recibir como parámetro una interface. Luego le podemos pasar objetos de distintas clases que implementan dicha interface:\ninterface Figura {\n  superficie: number;\n  perimetro: number;\n  calcularSuperficie(): number;\n  calcularPerimetro(): number;\n}\n\n\nclass Cuadrado implements Figura {\n  superficie: number;\n  perimetro: number;\n  constructor(private lado:number) {\n    this.superficie = this.calcularSuperficie();\n    this.perimetro = this.calcularPerimetro();\n  }\n\n  calcularSuperficie(): number {\n    return this.lado * this.lado;\n  }\n\n  calcularPerimetro(): number {\n    return this.lado * 4;\n  }  \n}\n\n\nclass Rectangulo implements Figura {\n  superficie: number;\n  perimetro: number;\n  constructor(private ladoMayor:number, private ladoMenor:number) {\n    this.superficie = this.calcularSuperficie();\n    this.perimetro = this.calcularPerimetro();\n  }\n\n  calcularSuperficie(): number {\n    return this.ladoMayor * this.ladoMenor;\n  }\n\n  calcularPerimetro(): number {\n    return (this.ladoMayor * 2) + (this.ladoMenor * 2);\n  }  \n}\n\nfunction imprimir(fig: Figura) {\n  console.log(`Perimetro: ${fig.calcularPerimetro()}`);\n  console.log(`Superficie: ${fig.calcularSuperficie()}`);\n}\n\nlet cuadrado1: Cuadrado;\ncuadrado1 = new Cuadrado(10);\nconsole.log('Datos del cuadrado');\nimprimir(cuadrado1);\nlet rectangulo1: Rectangulo;\nrectangulo1 = new Rectangulo(10, 5);\nconsole.log('Datos del rectángulo');\nimprimir(rectangulo1);\n\nLa función imprimir recibe como parámetro fig que es de tipo Figura:\nfunction imprimir(fig: Figura) {\n  console.log(`Perimetro: ${fig.calcularPerimetro()}`);\n  console.log(`Superficie: ${fig.calcularSuperficie()}`);\n}\n\nPodemos luego llamar a la función imprimir pasando tanto objetos de la clase Cuadrado como Rectangulo:\nimprimir(cuadrado1);\n\nimprimir(rectangulo1);\n\nEs importante notar que solo podemos acceder a los métodos y propiedades definidos en la interfaz y no a propiedades y métodos propios de cada clase.\n\nCreación de objetos a partir de una interface.\nTypeScript permite crear objetos a partir de una interfaz. La sintaxis para dicha creación es:\ninterface Punto {\n  x: number;\n  y: number;\n}\n\nlet punto1: Punto;\npunto1 = {x:10, y:20};\nconsole.log(punto1);\n\nNo podemos utilizar el operador new para la creación del objeto.\nPodemos definir la variable e inmediatamente iniciarla:\nlet punto1: Punto = {x:10, y:20};\n\n\n\nPropiedades opcionales.\nUna interface puede definir propiedades opcionales que luego la clase que la implementa puede o no definirlas. Se utiliza la misma sintaxis de los parámetros opcionales, es decir se le agrega el caracter '?' al final del nombre de la propiedad.\ninterface Punto {\n  x: number;\n  y: number;\n  z?: number;\n}\n\nlet puntoPlano: Punto = {x:10, y:20};\nconsole.log(puntoPlano);\nlet puntoEspacio: Punto = {x:10, y:20, z:70};\nconsole.log(puntoEspacio);\n\nComo vemos el objeto 'puntoPlano' solo implementa las propiedades 'x' e 'y'.\nSe produce un error en tiempo de compilación si no implementamos todas las propiedades obligatorias, por ejemplo:\nlet puntoPlano: Punto = {x:10};\n\nEsta línea genera un error ya que solo se define la propiedad 'x' y falta definir la propiedad 'y'.\n\nHerencia de interfaces.\nTypeScript permite que una interface herede de otra:\ninterface Punto {\n  x: number;\n  y: number;\n}\n\ninterface Punto3D extends Punto {\n  z: number;\n}\n\nlet punto1: Punto = {x:10, y:20};\nlet punto2: Punto3D = {x:23, y:13, z:12};\nconsole.log(punto1);\nconsole.log(punto2);"
  },
  {
    "title": "57 - TypeScript: clases genéricas",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=57&codigo=57&inicio=40",
    "content": "TypeScript permite crear clases y funciones que administren distintos tipos de datos. Esta característica no existe en JavaScript\nSe utilizan mucho para la administración de colecciones de datos (pilas, colas, listas etc.)\n\nPara entender las ventajas de definir clases genéricas implementaremos los algoritmos para administrar una pila de enteros y una pila de string. Primero lo haremos utilizando clases tradicionales y luego mediante una clase genérica.\n\nPara concentrarnos en la sintaxis plantearemos la pila utilizando un vector donde definiremos los dos métodos fundamentales de insertar y extraer (no haremos ningún tipo de validaciones por simplicidad)\nclass PilaEnteros {\n  private vec: number[] = [];\n\n  insertar(x: number) {\n    this.vec.push(x);\n  }\n\n  extraer() {\n    if (this.vec.length > 0)\n      return this.vec.pop();\n    else\n      return null;\n  }\n}\n\nclass PilaStrings {\n  private vec: string[] = [];\n\n  insertar(x: string) {\n    this.vec.push(x);\n  }\n\n  extraer() {\n    if (this.vec.length > 0)\n      return this.vec.pop();\n    else\n      return null;\n  }\n}\n\nlet pila1 = new PilaEnteros();\npila1.insertar(20);\npila1.insertar(43);\npila1.insertar(1);\nconsole.log(pila1.extraer());\n\nlet pila2 = new PilaStrings();\npila2.insertar('juan');\npila2.insertar('ana');\npila2.insertar('luis');\nconsole.log(pila2.extraer());\n\n\nComo podemos analizar hemos planteado dos clases, una para administrar una pila con tipos de dato enteros:\nclass PilaEnteros {\n  private vec: number[] = [];\n\n  insertar(x: number) {\n    this.vec.push(x);\n  }\n\n  extraer() {\n    if (this.vec.length > 0)\n      return this.vec.pop();\n    else\n      return null;\n  }\n}\n\nY por otro lado otra clase para administrar una pila de tipo de dato string:\nclass PilaStrings {\n  private vec: string[] = [];\n\n  insertar(x: string) {\n    this.vec.push(x);\n  }\n\n  extraer() {\n    if (this.vec.length > 0)\n      return this.vec.pop();\n    else\n      return null;\n  }\n}\n\nPara probar estas dos clases definimos un objeto de la clase PilaEnteros e insertamos tres valores y luego extraemos uno:\nlet pila1=new PilaEnteros();\npila1.insertar(20);\npila1.insertar(43);\npila1.insertar(1);\nconsole.log(pila1.extraer()); //se imprime un 1 ya que el último en entrar es el primero en salir en una pila.\n\nDe forma similar probamos creando un objeto de la clase PilaStrings:\nlet pila2=new PilaStrings();\npila2.insertar('juan');\npila2.insertar('ana');\npila2.insertar('luis');\nconsole.log(pila2.extraer()); //se imprime 'luis'\n\n\nHasta este momento no hemos presentado ninguna novedad con respecto a lo que conocemos. Veamos ahora como podemos resolver este problema pero empleando una clase genérica:\nclass PilaGenerica<T>{\n  private vec: T[] = [];\n\n  insertar(x: T) {\n    this.vec.push(x);\n  }\n\n  extraer() {\n    if (this.vec.length > 0)\n      return this.vec.pop();\n    else\n      return null;\n  }\n}\n\nlet pila3: PilaGenerica<number>;\npila3 = new PilaGenerica<number>();\npila3.insertar(20);\npila3.insertar(42);\npila3.insertar(1);\nconsole.log(pila3.extraer());\n\nlet pila4: PilaGenerica<string>;\npila4 = new PilaGenerica<string>();\npila4.insertar('juan');\npila4.insertar('ana');\npila4.insertar('luis');\nconsole.log(pila4.extraer());\n\n\nComo vemos hemos declarado una sola clase llamada PilaGenerica y hemos sustituido en los lugares donde hacíamos referencia a number o string por el tipo 'T' que también tenemos que hacer referencia en donde declaramos la clase:\nclass PilaGenerica<T>{\n  private vec: T[] = [];\n\n  insertar(x: T) {\n    this.vec.push(x);\n  }\n\n  extraer() {\n    if (this.vec.length > 0)\n      return this.vec.pop();\n    else\n      return null;\n  }\n}\n\n\nLuego cuando creamos un objeto de la clase PilaGenerica debemos indicar cuando la creamos el tipo de datos que administrará nuestra pila:\nlet pila4:PilaGenerica<string>;\npila4=new PilaGenerica<string>();\n\n\nPodemos crear objetos de la clase PilaGenerica con cualquier tipo de dato primitivo (number, string, boolean etc.) o de otra clase.\nProblemos de codificar otro programa que cree una pila de otra clase creada por nosotros:\nclass PilaGenerica<T>{\n  private vec: T[] = [];\n\n  insertar(x: T) {\n    this.vec.push(x);\n  }\n\n  extraer() {\n    if (this.vec.length > 0)\n      return this.vec.pop();\n    else\n      return null;\n  }\n}\n\nclass Persona {\n  constructor(public nombre: string, public edad: number) { }\n}\n\nlet pila5: PilaGenerica<Persona>;\npila5 = new PilaGenerica<Persona>();\npila5.insertar(new Persona('pedro', 33));\npila5.insertar(new Persona('maria', 33));\npila5.insertar(new Persona('marcos', 33));\nconsole.log(pila5.extraer());\n\n\nCreamos un objeto de la clase PilaGenerica e indicamos que almacenará objetos de la clase Persona:\nlet pila5:PilaGenerica<Persona>;\npila5=new PilaGenerica<Persona>();\n\nCreamos tres objetos de la clase Persona y los insertamos en la Pila:\npila5.insertar(new Persona('pedro', 33));\npila5.insertar(new Persona('maria', 33));\npila5.insertar(new Persona('marcos', 33));\n\nSi extraemos un elemento de la pila tenemos la última persona ingresada:\nconsole.log(pila5.extraer());\n\n\nEl planteo de clases genéricas nos reduce tener que crear múltiples clases para administrar distintos tipos de datos."
  },
  {
    "title": "58 - TypeScript y Angular: definición de una interfaz para controlar los tipos",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=58&codigo=58&inicio=40",
    "content": "En Angular los modelos de datos se los representa generalmente con una interfaz, veamos un ejemplo utilizando una interfaz para definir el modelo de datos.\nProblema\nImplementar una aplicación que permita almacenar en un arreglo los sitios favoritos de internet y una descripción del sitio.\nPara resolver el problema vamos a definir la siguiente interfaz:\nexport interface Sitio {\n  url: string;\n  descripcion: string\n}\n\nLa aplicación debe almacenar en el localStorage del navegador todos los datos para evitar que se pierdan cuando cerremos la aplicación.\n\nSi ejecutamos la aplicación tenemos una pantalla similar a:\n\nPodemos probar la aplicación en la web aquí.\n\n\nComo primer paso pasemos a crear nuestro proyecto:\n\n\n\nCrearemos primero el proyecto\nng new proyecto037\n\n\n\n\nEl segundo paso es crear un archivo en la carpeta 'app' con el nombre 'sitio.ts' y en su interior codificamos la interfaz 'Sitio', la idea de separarla en un archivo independiente es porque la vamos a utilizar a la interfaz 'Sitio' en más de un archivo:\nsitio.ts\nexport interface Sitio {\n  url: string;\n  descripcion: string\n}\n\nDisponemos la palabra clave 'export' para poder importarla en otros archivos.\n\n\n\n\nCrearemos el servicio que se va a encargar de almacenar y recuperar los datos del localStorage.\nPara crear el servicio desde Angular CLI ejecutamos:\nng generate service sitios\n\nSe nos generan 2 archivos y el que debemos modificar es el archivo sitios.service.ts.\nsitios.service.ts\nimport { Injectable } from '@angular/core';\nimport { Sitio } from './sitio';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class SitioService {\n  private localStorageNombre = 'sitios';\n\n  obtenerSitios(): Sitio[] {\n    const sitiosStr = localStorage.getItem(this.localStorageNombre);\n    return sitiosStr ? JSON.parse(sitiosStr) : [];\n  }\n\n  agregarSitio(sitio: Sitio): void {\n    const sitios = this.obtenerSitios();\n    sitios.push(sitio);\n    localStorage.setItem(this.localStorageNombre, JSON.stringify(sitios));\n  }\n\n  borrarSitio(url: string): void {\n    const sitios = this.obtenerSitios();\n    const index = sitios.findIndex((s) => s.url === url);\n    if (index !== -1) {\n      sitios.splice(index, 1);\n      localStorage.setItem(this.localStorageNombre, JSON.stringify(sitios));\n    }\n  }\n\n  modificarSitio(sitio: Sitio, urlBuscar:string): void {\n    const sitios = this.obtenerSitios();\n    const index = sitios.findIndex((s) => s.url === urlBuscar);\n    if (index !== -1) {\n      sitios[index] = sitio;\n      localStorage.setItem(this.localStorageNombre, JSON.stringify(sitios));\n    }\n  }\n}\n\n  obtenerSitios(): Sitio[] {\n    const sitiosStr = localStorage.getItem(this.localStorageNombre);\n    return sitiosStr ? JSON.parse(sitiosStr) : [];\n  }\n\nEl método 'obtenerSitios' retorna un arreglo de la interfaz 'Sitio'. Lo primero que hacemos es con el método getItem recuperamos los datos del localStorage o nos retorna null si todavía no hay nada almacenado.\nFinalmente retornamos un arreglo vacío [] si la variable 'sitioStr' almacena null o retornamos un objeto JSON a partir del string almacenado en el localStorage.\n  agregarSitio(sitio: Sitio): void {\n    const sitios = this.obtenerSitios();\n    sitios.push(sitio);\n    localStorage.setItem(this.localStorageNombre, JSON.stringify(sitios));\n  }\n\nEl método agregarSitio recibe como parámetro un objeto de tipo 'Sitio'. Lo primero llama al método obtenerSitios que retorna como vimos un arreglo vacío [] o un arreglo con todos los sitios almacenados actualmente en el localStorage.\nAgregamos al arreglo 'sitios' el sitio que llega como parámetro y finalmente volvemos a almacenar el arreglo en el localStorage. Recordar que en el localStorage debemos convertir el arreglo 'sitios' a string mediante el método JSON.stringify.\n  borrarSitio(url: string): void {\n    const sitios = this.obtenerSitios();\n    const index = sitios.findIndex((s) => s.url === url);\n    if (index !== -1) {\n      sitios.splice(index, 1);\n      localStorage.setItem(this.localStorageNombre, JSON.stringify(sitios));\n    }\n  }\n\nPrimero recuperamos todos los sitios almacenados en el localStorage, buscamos la 'url' del sitio que queremos borrar llamando al método 'findIndex' de la clase Array. Si lo encontramos procedemos a eliminar un elemento del arreglo llamando al método 'splice' y finalmente volvemos a guardar los datos del arreglo en el localStorage.\n  modificarSitio(sitio: Sitio, urlBuscar:string): void {\n    const sitios = this.obtenerSitios();\n    const index = sitios.findIndex((s) => s.url === urlBuscar);\n    if (index !== -1) {\n      sitios[index] = sitio;\n      localStorage.setItem(this.localStorageNombre, JSON.stringify(sitios));\n    }\n  }\n\nBuscamos la url del sitio que queremos modificar, y en caso de encontrarlo procedemos a asignar a dicha componente los datos modificados que llegan en el parámetro 'sitio'.\n\n\n\nPasemos a codificar la lógica de la componente, la cual se apoya en el servicio para recuperar, agregar y modificar datos.\napp.component.ts\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { Sitio } from './sitio';\nimport { SitioService } from './sitios.service';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, FormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  sitio: Sitio = { url: '', descripcion: '' }; // datos cargados en el formulario\n  sitios: Sitio[] = []; // arreglo con todos los sitios\n  sitioSeleccionado: string = ''; // se almacena el sitio seleccionado con el boton \"seleccionar\"\n\n  constructor(private sitioService: SitioService) {\n    this.sitios = sitioService.obtenerSitios();\n  }\n\n  borrar(url: string): void {\n    this.sitioService.borrarSitio(url);\n    this.sitios = this.sitioService.obtenerSitios();\n  }\n\n  agregar(): void {\n    if (this.sitio.url.trim() === '') {\n      alert('Debe ingresar una URL de sitio');\n      return;\n    }\n\n    if (this.sitios.some((s) => s.url === this.sitio.url)) {\n      alert('Ya existe un sitio con dicha URL');\n      return;\n    }\n\n    this.sitioService.agregarSitio(this.sitio);\n    this.sitio = { url: '', descripcion: '' };\n    this.sitios = this.sitioService.obtenerSitios();\n  }\n\n  seleccionar(sitio: Sitio): void {\n    this.sitioSeleccionado = sitio.url; // Guardar la URL seleccionada\n    this.sitio.url = sitio.url;\n    this.sitio.descripcion = sitio.descripcion;\n  }\n\n  modificar(): void {\n    if (this.sitio.url.trim() === '') {\n      alert('Debe ingresar una URL de sitio');\n      return;\n    }\n\n    const sitioExistente = this.sitios.find((s) => s.url === this.sitio.url && s.url !== this.sitioSeleccionado);\n    if (sitioExistente) {\n      alert('Ya existe un sitio con dicha URL');\n      return;\n    }\n\n    if (this.sitioSeleccionado) {\n\n      const index = this.sitios.findIndex((s) => s.url === this.sitioSeleccionado);\n      if (index !== -1) {\n        this.sitios[index] = { ...this.sitio };\n        this.sitioService.modificarSitio(this.sitio,this.sitioSeleccionado);\n        this.sitio = { url: '', descripcion: '' };\n        this.sitios = this.sitioService.obtenerSitios();\n        this.sitioSeleccionado = '';\n      }\n    }\n  }\n}\n\n  sitio: Sitio = { url: '', descripcion: '' }; // datos cargados en el formulario\n\nLa propiedad 'sitio' es de la interfaz 'Sitio' y lo inicializamos con string vacíos tanto para la url como la descripción. Estos dos atributos están asociados a los controles input del formulario.\n  sitios: Sitio[] = []; // arreglo con todos los sitios\n\nCorresponde al arreglo con todos los sitios. En el constructor se inicializa con los sitios almacenados hasta este momento en el localStorage.\n  sitioSeleccionado: string = ''; // se almacena el sitio seleccionado con el boton \"seleccionar\"\n\nEsta propiedad se requiere para el proceso de modificación de datos.\n  constructor(private sitioService: SitioService) {\n    this.sitios = sitioService.obtenerSitios();\n  }\n\nEl constructor se le inyecta el servicio y se crea en el mismo parámetro la propiedad 'sitioService'. Además llamamos al método obtenerSitios para recuperar todos los datos almacenados en el localStorage. Como sabemos el método retorna un arreglo de tipo Sitio.\n  borrar(url: string): void {\n    this.sitioService.borrarSitio(url);\n    this.sitios = this.sitioService.obtenerSitios();\n  }\n\nEl método borrar se lo llama desde la plantilla cuando se presiona el botón 'borrar' y llega como dato la 'url' del sitio a borrar. Llamamos al método borrarSitio del servicio sitioService que actualiza el localStorage eliminando dicho sitio. Además volvemos a llamar al método obtenerSitios del servicio para que nos retorne actualizado todos los sitios almacenados en el localStorage.\n  agregar(): void {\n    if (this.sitio.url.trim() === '') {\n      alert('Debe ingresar una URL de sitio');\n      return;\n    }\n\n    if (this.sitios.some((s) => s.url === this.sitio.url)) {\n      alert('Ya existe un sitio con dicha URL');\n      return;\n    }\n\n    this.sitioService.agregarSitio(this.sitio);\n    this.sitio = { url: '', descripcion: '' };\n    this.sitios = this.sitioService.obtenerSitios();\n  }\n\nEl método agregar hace algunas validaciones como que hayamos ingresado una 'url' en el formulario o que dicha 'url' ya si haya cargado en el arreglo.\nSi pasa las validaciones llamamos al método agregarSitio del servicio sitioService y volvemos a actualizar el arreglo llamando a obtenerSitios.\n  seleccionar(sitio: Sitio): void {\n    this.sitioSeleccionado = sitio.url; // Guardar la URL seleccionada\n    this.sitio.url = sitio.url;\n    this.sitio.descripcion = sitio.descripcion;\n  }\n\nEl método seleccionar se llama cuando se presiona en la plantilla el botón 'seleccionar', donde procedemos a almacenar en la propiedad sitioSeleccionado la url del sitio seleccionado. También actualizamos el formulario asignando valores al atributo 'sitio'.\n  modificar(): void {\n    if (this.sitio.url.trim() === '') {\n      alert('Debe ingresar una URL de sitio');\n      return;\n    }\n\n    const sitioExistente = this.sitios.find((s) => s.url === this.sitio.url && s.url !== this.sitioSeleccionado);\n    if (sitioExistente) {\n      alert('Ya existe un sitio con dicha URL');\n      return;\n    }\n\n    if (this.sitioSeleccionado) {\n\n      const index = this.sitios.findIndex((s) => s.url === this.sitioSeleccionado);\n      if (index !== -1) {\n        this.sitios[index] = { ...this.sitio };\n        this.sitioService.modificarSitio(this.sitio,this.sitioSeleccionado);\n        this.sitio = { url: '', descripcion: '' };\n        this.sitios = this.sitioService.obtenerSitios();\n        this.sitioSeleccionado = '';\n      }\n    }\n  }\n\nFinalmente el método modificar luego de hacer algunas validaciones procedemos a buscar el sitio que seleccionamos anteriormente y proceder a llamar al método modificarSitio del objeto sitioService pasando como parámetos los datos del formulario que se encuentran en el atributo 'sitio' y la url del sitio que anteriormente seleccionamos y almacenamos en la propiedad sitioSeleccionado.\n\n\n\nLa plantilla muestra la tabla HTML con los sitios web y un formulario para la carga de sitios.\napp.component.html\n<div>\n  <h1>Administración de sitios web</h1>\n  <table>\n    <thead>\n      <tr>\n        <th>URL</th>\n        <th>Descripcion</th>\n        <th>Borrar</th>\n        <th>Seleccionar</th>\n      </tr>\n    </thead>\n    <tbody>\n      @for(sitio of sitios; track sitio.url) {\n      <tr>\n        <td><a href=\"https://www.{{sitio.url}}\" target=\"_blank\">{{sitio.url}}</a></td>\n        <td>{{sitio.descripcion}}</td>\n        <td><button (click)=\"borrar(sitio.url)\">Borrar?</button></td>\n        <td><button (click)=\"seleccionar(sitio)\">Seleccionar</button></td>\n      </tr>\n      } @empty {\n        <tr>\n          <td colspan=\"4\">\n            No hay sitios.\n          </td>\n        </tr>\n      }\n    </tbody>\n  </table>\n  <div>\n    <p>\n      URL:<input type=\"text\" [(ngModel)]=\"sitio.url\" />\n    </p>\n    <p>\n      Descripcion:<input type=\"text\" [(ngModel)]=\"sitio.descripcion\" />\n    </p>\n    <p>\n      <button (click)=\"agregar()\">Agregar</button>\n      <button (click)=\"modificar()\">Modificar</button>\n    </p>\n  </div>\n</div>\n<router-outlet />\n\n      @for(sitio of sitios; track sitio.url) {\n      <tr>\n        <td><a href=\"https://www.{{sitio.url}}\" target=\"_blank\">{{sitio.url}}</a></td>\n        <td>{{sitio.descripcion}}</td>\n        <td><button (click)=\"borrar(sitio.url)\">Borrar?</button></td>\n        <td><button (click)=\"seleccionar(sitio)\">Seleccionar</button></td>\n      </tr>\n      } @empty {\n        <tr>\n          <td colspan=\"4\">\n            No hay sitios.\n          </td>\n        </tr>\n      }\n\nUtilizamos la estructura repetitiva '@for' en la plantilla para mostrar el nombre del sitio, su descripción y dos botones que nos permiten borrar o seleccionar el sitio.\nSi el arreglo 'sitios' está vacío se ejecuta el bloque @empty.\n\n\n\nLa hoja de estilo de la componente.\napp.component.css\ntable {\n  width: 100%;\n  border-collapse: collapse;\n  margin-bottom: 20px;\n}\n\nth, td {\n  border: 1px solid #dddddd;\n  padding: 8px;\n  text-align: left;\n}\n\ntr:nth-child(even) {\n  background-color: #f2f2f2;\n}\n\nth {\n  background-color: #4CAF50;\n  color: white;\n}\n\n\n\n\n\nSi ejecutamos la aplicación tenemos una interfaz similar a:\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "59 - TypeScript: decoradores",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=59&codigo=59&inicio=40",
    "content": "En TypeScript, un decorador es una función especial que se utiliza para modificar o extender el comportamiento de clases, métodos, propiedades o parámetros.\nLas funciones decoradoras permiten agregar metadatos y comportamientos adicionales. \nLas funciones decoradoras se ejecutan en Angular en tiempo de compilación de la aplicación, recordemos que el framework Angular compila el código TypeScript, HTML y CSS, generando JavaScript que es lo que puede interpretar un navegador web.\nVeremos con dos ejemplo cual es la sintaxis para crear funciones decoradoras en TypeScript y en los próximos conceptos veremos las funciones decoradoras que vienen en el framework de Angular.\nFunción decoradora de clase sin parámetros.\nPodemos agregar el código siguiente a un proyecto que tengamos en Angular:\napp.component.ts\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n\nfunction MostrarMensajeDeCreacion(constructor: Function) {\n  console.log(constructor.toString());\n  const prototipo = constructor.prototype;\n  const nombresMetodos = Object.getOwnPropertyNames(prototipo)\n    .filter(nombre => typeof prototipo[nombre] === 'function');\n  console.log('Métodos:', nombresMetodos.join(', '));\n}\n\n// Aplicamos el decorador a una clase\n@MostrarMensajeDeCreacion\nclass MiClase {\n\n  constructor() {\n    console.log('Objeto creado');\n  }\n\n  metodo1() {\n    console.log('Metodo 1 ejecutado');\n  }\n\n  metodo2() {\n    console.log('Metodo 2 ejecutado');\n  }\n}\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent{\n  title = 'prueba';\n}\n\nPara aplicar una función decoradora a una clase debemos anteceder al nombre de la clase el caracter @ seguido del nombre de la función decoradora:\n@MostrarMensajeDeCreacion\nclass MiClase {\n\n\nLa función decoradora MostrarMensajeDeCreacion llega una función (el constructor de la clase) como parámetro. En este caso, la función imprime la representación en cadena de la clase y los nombres de los métodos de la clase:\nfunction MostrarMensajeDeCreacion(constructor: Function) {\n  console.log(constructor.toString());\n  const prototipo = constructor.prototype;\n  const nombresMetodos = Object.getOwnPropertyNames(prototipo)\n    .filter(nombre => typeof prototipo[nombre] === 'function');\n  console.log('Métodos:', nombresMetodos.join(', '));\n}\n\nNo hemos definido objetos de la clase 'MiClase' y podemos ver que el compilador de Angular ejecuta el decorador cuando compila la aplicación:\n\nEs solo un ejemplo elemental para entender que la función decoradora se ejecuta independientemente a que definamos objetos de la clase. El decorador se ejecuta en tiempo de compilación y se utiliza para modificar o extender la funcionalidad de la clase, nosotros solo hemos hecho unas pocas salidas por la consola.\n\n\nFunción decoradora de clase con parámetros.\nPodemos pasar parámetros a una función decoradora, veamos un ejemplo donde le pasamos un objeto de una determinada interface (en forma similar el framework Angular utiliza los decoradores para añadir funcionalidades por ejemplo a las componentes):\nimport { Component} from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n\n// Interfaz para el parámetro del decorador\ninterface DetallesDeCreacion {\n  selector: string;\n  templateUrl: string;\n  styleUrl: string;\n}\n\n// Decorador de Clase para Mostrar Detalles de Creación con Parámetro de la Interfaz\nfunction MostrarDetallesDeCreacion(detalles: DetallesDeCreacion) {\n  return function (constructor: Function) {\n    console.log(constructor.toString());\n    // Mostrar información adicional sobre métodos y propiedades\n    const prototipo = constructor.prototype;\n    const nombresMetodos = Object.getOwnPropertyNames(prototipo)\n      .filter(nombre => typeof prototipo[nombre] === 'function');\n    console.log('Métodos:', nombresMetodos.join(', '));\n\n    console.log('Template URL:', detalles.templateUrl);\n    console.log('Style URL:', detalles.styleUrl);\n  };\n}\n\n// Aplicamos el decorador a una clase con un parámetro de la interfaz\n@MostrarDetallesDeCreacion({\n  selector: 'app-mi-clase',\n  templateUrl: 'mi-clase.component.html',\n  styleUrl: 'mi-clase.component.css',\n})\nclass MiClase {\n\n  constructor() {\n    console.log('Objeto creado');\n  }\n\n  metodo1() {\n    console.log('Metodo 1 ejecutado');\n  }\n\n  metodo2() {\n    console.log('Metodo 2 ejecutado');\n  }\n}\n\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'prueba';\n}\n\n\ninterface DetallesDeCreacion {\n  selector: string;\n  templateUrl: string;\n  styleUrl: string;\n}\n\nSe define una interfaz llamada DetallesDeCreacion que especifica tres propiedades: selector, templateUrl, y styleUrl.\nEs solo un ejemplo y los nombres de las propiedades pueden ser cualquiera.\nfunction MostrarDetallesDeCreacion(detalles: DetallesDeCreacion) {\n  return function (constructor: Function) {\n    console.log(constructor.toString());\n    // Mostrar información adicional sobre métodos y propiedades\n    const prototipo = constructor.prototype;\n    const nombresMetodos = Object.getOwnPropertyNames(prototipo)\n      .filter(nombre => typeof prototipo[nombre] === 'function');\n    console.log('Métodos:', nombresMetodos.join(', '));\n\n    console.log('Template URL:', detalles.templateUrl);\n    console.log('Style URL:', detalles.styleUrl);\n  };\n}\n\nSe define una función llamada MostrarDetallesDeCreacion que toma un parámetro 'detalles' de tipo DetallesDeCreacion. Esta función devuelve otra función que actúa como el decorador real.\nDentro de la función del decorador, se imprime la representación en cadena del constructor de la clase, así como los nombres de los métodos de la clase.\nLuego, imprime las propiedades del parámetro 'detalles' que fueron proporcionadas al aplicar el decorador.\n// Aplicamos el decorador a una clase con un parámetro de la interfaz\n@MostrarDetallesDeCreacion({\n  selector: 'app-mi-clase',\n  templateUrl: 'mi-clase.component.html',\n  styleUrl: 'mi-clase.component.css',\n})\nclass MiClase {\n\n  constructor() {\n    console.log('Objeto creado');\n  }\n\n  metodo1() {\n    console.log('Metodo 1 ejecutado');\n  }\n\n  metodo2() {\n    console.log('Metodo 2 ejecutado');\n  }\n}\n\nSe aplica el decorador MostrarDetallesDeCreacion a la clase MiClase con un objeto que cumple con la interfaz DetallesDeCreacion.\nLos valores proporcionados (como selector, standalone, templateUrl, y styleUrl) se utilizarán dentro del decorador para mostrar información adicional.\nTengamos en cuenta que no creamos objetos de la clase 'MiClase' y el compilador de Angular ejecuta la función decoradora aplicada a la clase:\n\nEste ejemplo nos debe dar una idea como el compilador de Angular procesa el código de la componente AppComponent:\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'prueba';\n}\n\nLo primero que hace es ejecutar la función decoradora @Component y le pasa como parámetro un objeto, en este caso inicializando 4 propiedades: selector, imports, templateUrl y styleUrls. Todos estos datos complementan a la clase AppComponent para acceder a los archivos: app.component.html y app.component.css"
  },
  {
    "title": "60 - TypeScript y Angular: decorador @Component",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=60&codigo=60&inicio=40",
    "content": "En Angular, el decorador @Component es esencial para la creación y configuración de componentes. Este decorador se utiliza para asociar metadatos con la clase de un componente, proporciona información sobre su comportamiento, aspecto y configuración.\nLos metadatos incluyen propiedades como selector (identificador HTML para el componente), template (código HTML o referencia a un archivo HTML), styleUrls (archivos de estilo o estilos en línea) etc.\nCrearemos un proyecto para probar distintas variantes sobre la configuración de los parámetros del decorador @Component.\n\nng new proyecto038\n\nComo ya sabemos Angular CLI al crear un proyecto nos crea una primer componente llamada AppComponent:\napp.component.ts\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'proyecto038';\n}\n\nAhora que ya conocemos mejor el concepto de decorador, pasemos a ver las distintas propiedades del objeto que le pasamos a la función Component.\nLa propiedad 'selector' hace referencia a la etiqueta que debemos agregar a nuestra página para crear una componente de dicho tipo:\n  selector: 'app-root',\n\nEn este caso se encuentra en el archivo index.html:\n<body>\n  <app-root></app-root>\n</body>\n\nOtra propiedad que debemos configurar es imports, que se utiliza para declarar otras componentes que hacemos uso, o módulos que contienen componentes, directivas u otros artefactos que el componente actual necesita para funcionar correctamente.\n\nLa propiedad templateUrl en el decorador @Component se utiliza para especificar la ubicación del archivo HTML externo que contiene la plantilla del componente. En otras palabras, templateUrl se utiliza para separar el código HTML de la lógica del componente, lo que facilita la organización y mantenimiento del código.\n  templateUrl: './app.component.html',\n\nOtra variante que vamos a probar es eliminar la propiedad 'templateUrl' y proceder a insertar la propiedad 'template' con la plantilla HTML directamente dentro del decorador (podemos eliminar el archivo 'app.component.html'), puede ser útil si nuestra componente es muy sencilla y queremos concentrar la plantilla HTML y la clase en el mismo archivo:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  template: `<h1>Componente de Angular</h1>\n  <p>La plantilla de la componente se encuentra definida\n    directamente en el decorador.</p>`,\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'proyecto038';\n}\n\nDe forma similar podemos definir la hoja de estilo de la componente en un archivo o un conjunto de archivos CSS separados:\n  styleUrls: ['./app.component.css']\n\nO borrar la propiedad 'styleUrls' por la propiedad 'style':\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet],\n  template: `<h1>Componente de Angular</h1>\n  <p>La plantilla de la componente se encuentra definida\n    directamente en el decorador.</p>`,\n  styles: `h1 {\n    color:red\n  }\n  p {\n    color:blue\n  }`\n})\nexport class AppComponent {\n  title = 'proyecto038';\n}\n\nEs importante hacer notar que la función decoradora 'Component' debemos importarla para su uso (cuando creamos una componente, dicho código ya se ha agregado):\nimport { Component } from '@angular/core';"
  },
  {
    "title": "61 - TypeScript y Angular: decoradores @Input y @Output",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=61&codigo=61&inicio=60",
    "content": "Ya vimos en los primeros conceptos que el decorador @Input nos permite pasar datos de la componente padre a la componente hija. También vimos que el decorador @Output nos permite disparar eventos desde la componente hija a la componente padre.\nAhora ya tenemos un conocimiento más profundo de los decoradores y como Angular en tiempo de compilación puede generar un código JavaScript y enlazar el pasaje de datos entre componentes.\nProblema\nCrear una aplicación que permita registrar tareas que se deben desarrollar y mediante controles checkbox tildar las ya realizadas, informando en la parte inferior cuantas de dichas tareas han sido finalizadas hasta dicho momento.\nCrear dos componentes, una llamada ListaTareas que muestre todas las tareas, permita ingresar nuevas tareas e informe las tareas finalizadas y por otro lado una componente llamada Tarea que tenga por objetivo mostrar una tarea, poder indicar que ya ha sido realizada e informar a la componente padre cada vez que cambia el estado de la tarea.\nLa interfaz visual es similar a:\n\nPodemos probar esta aplicación también en la web aquí.\n\n\nCrearemos primero el proyecto\nng new proyecto039\n\n\n\nCreamos el modelo de dato que representa una tarea mediante una 'interface':\nng generate interface tarea\n\nSe nos crea el archivo 'tarea.ts' donde definimos la interface:\nexport interface Tarea {\n  id: number,\n  descripcion: string,\n  finalizada: boolean\n}\n\nPor cada tarea guardaremos su identificador, descripción y si la tarea fue finalizada.\n\n\n\nPasemos a crear ahora la componente \"Tarea\":\nng generate component tarea\n\nSe nos crea una carpeta con los 4 archivos que representan la componente, procedemos a modificar la clase propiamente dicha y la plantilla HTML.\ntarea.component.ts\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { Tarea } from '../tarea';\n@Component({\n  selector: 'app-tarea',\n  imports: [],\n  templateUrl: './tarea.component.html',\n  styleUrl: './tarea.component.css'\n})\nexport class TareaComponent {\n  @Input() tarea: Tarea = { id: 0, descripcion: '', finalizada: false };\n  @Output() borrarTarea: EventEmitter<number> = new EventEmitter<number>();\n\n  cambiarEstado() {\n    this.tarea.finalizada = !this.tarea.finalizada;\n  }\n\n  borrar() {\n    this.borrarTarea.emit(this.tarea.id);\n  }\n}\n\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\n\nDebemos importar primero los 3 decoradores y la interface EventEmitter.\nimport { Tarea } from '../tarea';\n\nTambién importamos la interface que creamos nosotros.\n  @Input() tarea: Tarea = { id: 0, descripcion: '', finalizada: false };\n\nDefinimos el decorador input que se aplica a la propiedad 'tarea' (es decir es un decorador de propiedad y no de clase como Component), el mismo espera recibir una tarea como entrada, lo inicializamos pero seguramente cuando lo invoquemos cambie con los datos que llegan desde la componente padre.\n  @Output() borrarTarea: EventEmitter<number> = new EventEmitter<number>();\n\nEs un decorador que indica que borrarTarea es un evento de salida. Cuando se llama al método borrar(), emite un evento con el ID de la tarea que se va a borrar.\n  cambiarEstado() {\n    this.tarea.finalizada = !this.tarea.finalizada;\n  }\n\nEs un método que cambia el estado de la tarea (marcada o no marcada como finalizada) al ser llamado.\n  borrar() {\n    this.borrarTarea.emit(this.tarea.id);\n  }\n\nEmite el evento borrarTarea con el ID de la tarea que se va a borrar.\n\n\nLa plantilla HTML para 'TareaComponent' es:\n<div>\n  <input type=\"checkbox\" [checked]=\"tarea.finalizada\" (change)=\"cambiarEstado()\">\n  {{ tarea.descripcion }}\n  <button (click)=\"borrar()\">Borrar</button>\n</div>\n\n\n\n  <input type=\"checkbox\" [checked]=\"tarea.finalizada\" (change)=\"cambiarEstado()\">\n\nSe crea un elemento input de tipo checkbox. [checked]=\"tarea.finalizada\" utiliza la propiedad binding para enlazar el estado del checkbox al valor de tarea 'finalizada'. Esto significa que el checkbox estará marcado (checked) si tarea.finalizada es true, y desmarcado si es false.\n(change)=\"cambiarEstado()\": Utiliza un evento de cambio (change) para llamar al método cambiarEstado() cuando el estado del checkbox cambia.\n  <button (click)=\"borrar()\">Borrar</button>\n\n(click)=\"borrar()\": Utiliza un evento de clic (click) para llamar al método borrar()\n\n\n\nPasemos a crear ahora la componente \"listatareas\":\nng generate component listatareas\n\nSe nos crea una carpeta con los 4 archivos que representan la componente, procedemos a modificar la clase propiamente dicha y la plantilla HTML.\nlistatareas.component.ts\nimport { Component } from '@angular/core';\nimport { Tarea } from '../tarea';\nimport { TareaComponent } from '../tarea/tarea.component';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  selector: 'app-listatareas',\n  imports: [TareaComponent, FormsModule],\n  templateUrl: './listatareas.component.html',\n  styleUrl: './listatareas.component.css'\n})\nexport class ListatareasComponent {\n  tareas: Tarea[] = [];\n\n  descripcionTarea: string = '';\n\n  agregarTarea() {\n    const nuevaTarea: Tarea = { id: this.tareas.length + 1, descripcion: this.descripcionTarea, finalizada: false };\n    this.tareas.push(nuevaTarea);\n    this.descripcionTarea = '';\n  }\n\n  borrarTarea(tareaId: number) {\n    this.tareas = this.tareas.filter(tarea => tarea.id !== tareaId);\n  }\n\n  cantidadTareasCompletadas(): number {\n    return this.tareas.filter(tarea => tarea.finalizada).length;\n  }\n\n}\n\nimport { Component } from '@angular/core';\nimport { Tarea } from '../tarea';\nimport { TareaComponent } from '../tarea/tarea.component';\nimport { FormsModule } from '@angular/forms';\n\nImportamos el decorador Component, la interface Tarea, la componente TareaComponent y como vamos a trabajar con formularios basado en plantillas debemos importar  FormsModule.\n@Component({\n  selector: 'app-listatareas',\n  imports: [TareaComponent, FormsModule],\n  templateUrl: './listatareas.component.html',\n  styleUrl: './listatareas.component.css'\n})\n\nImportamos en el decorador de la componente la componente que creamos nosotros 'TareaComponent' y FormsModule.\n  tareas: Tarea[] = [];\n\ntareas es un array que almacenará las instancias de la interface Tarea.\n  descripcionTarea: string = '';\n\ndescripcionTarea es una propiedad que se utiliza para almacenar la descripción de la tarea que se va a agregar y esta vinculado al control input de tipo type de la plantilla HTML.\n  agregarTarea() {\n    const nuevaTarea: Tarea = { id: this.tareas.length + 1, descripcion: this.descripcionTarea, finalizada: false };\n    this.tareas.push(nuevaTarea);\n    this.descripcionTarea = '';\n  }\n\nEs un método que crea una nueva tarea con la descripción ingresada y la agrega al array de tareas. Luego, reinicia la propiedad descripcionTarea para que se borre en el formulario la tarea ingresada.\n  borrarTarea(tareaId: number) {\n    this.tareas = this.tareas.filter(tarea => tarea.id !== tareaId);\n  }\n\nEs un método que filtra las tareas para eliminar aquella cuyo id coincide con el tareaId proporcionado desde la plantilla HTML.\n  cantidadTareasCompletadas(): number {\n    return this.tareas.filter(tarea => tarea.finalizada).length;\n  }\n\nDevuelve el número de tareas completadas, utilizando el método filter para filtrar las tareas con finalizada establecida como true y luego calcula la longitud del array resultante.\n\nLa plantilla HTML para 'ListatareasComponent' es:\n<div>\n  <h2>Lista de tareas.</h2>\n  @for(tarea of tareas; track tarea.id) {\n  <app-tarea [tarea]=\"tarea\" (borrarTarea)=\"borrarTarea($event)\"></app-tarea>\n  }\n  <div>\n    <input [(ngModel)]=\"descripcionTarea\" placeholder=\"Ingrese nueva tarea\">\n    <button (click)=\"agregarTarea()\">Agregar tarea</button>\n  </div>\n</div>\n<div>\n  Cantidad de tareas completadas: {{ cantidadTareasCompletadas() }}\n</div>\n\n\n  @for(tarea of tareas; track tarea.id) {\n\nUtilizamos un bucle para recorrer el arreglo de tareas.\n  <app-tarea [tarea]=\"tarea\" (borrarTarea)=\"borrarTarea($event)\"></app-tarea>\n\nPara cada tarea, se utiliza el componente app-tarea para representarla. Se enlaza la tarea actual mediante [tarea]=\"tarea\", y se escucha el evento borrarTarea para ejecutar el método. \n    <input [(ngModel)]=\"descripcionTarea\" placeholder=\"Ingrese nueva tarea\">\n\nCrea un campo de entrada de texto con enlace bidireccional ([(ngModel)]) a la propiedad descripcionTarea. Esto permite que la variable descripcionTarea en el componente refleje los cambios en este campo de entrada.\n    <button (click)=\"agregarTarea()\">Agregar tarea</button>\n\nCrea un botón que llama al método agregarTarea() cuando se hace clic en él. Este método agrega una nueva tarea a la lista.\n\n\nPor último debemos modificar la componente que crea Angular por defecto, donde agregaremos la lista de tareas:\nappcomponent.component.ts\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ListatareasComponent } from './listatareas/listatareas.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, ListatareasComponent],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n}\n\nimport { ListatareasComponent } from './listatareas/listatareas.component';\n\nImporta la componente ListatareasComponent.\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, ListatareasComponent],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\n\nTambién en el decorador hacemos referencia a la importación del componente 'ListatareasComponent'.\n\nLa plantilla HTML para 'AppComponent' es:\n<app-listatareas></app-listatareas>\n<router-outlet />\n\nIncluimos la componente ListatareasComponent en la plantilla HTML mediante la etiqueta app-listatareas que se encuentra definida en la propidad select del decorador de la clase 'ListatareasComponent'.\n\n\n\nAhora podemos ejecutar la aplicación:\nng serve -o\n\nPodemos probar esta aplicación también en la web aquí."
  },
  {
    "title": "62 - TypeScript y Angular: decorador @Injectable",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=62&codigo=62&inicio=60",
    "content": "El decorador @Injectable se utiliza para marcar una clase como un servicio inyectable. Cuando un servicio es inyectable, significa que puede ser incluido en la lista de dependencias y Angular puede proporcionar instancias de ese servicio a otras clases mediante la inyección de dependencias.\nAngular utiliza un sistema de inyección de dependencias para gestionar las dependencias entre diferentes partes de una aplicación. Esto permite la creación de instancias de clases y su provisión a otras clases que las necesitan.\nSe aplica el decorador @Injectable a la clase del servicio que se desea inyectar. Este decorador no requiere ninguna configuración adicional y se coloca en la parte superior de la declaración de la clase.\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class MiServicio {\n  // Métodos y propiedades del servicio\n}\n\n@Injectable está configurado con { providedIn: 'root' } Esto significa que Angular proporcionará una única instancia de MiServicio en toda la aplicación (En ningún momento nosotros debemos instanciar la clase MiServicio)\n\nProblema\nVamos a resolver el mismo problema que el concepto anterior, pero vamos a almacenar las tareas en el localStorage.\nRecordemos el problema: crear una aplicación que permita registrar tareas que se deben desarrollar y mediante controles checkbox tildar las ya realizadas, informando en la parte inferior cuantas de dichas tareas han sido finalizadas hasta dicho momento.\nCrear dos componentes, una llamada ListaTareas que muestre todas las tareas, permita ingresar nuevas tareas e informe las tareas finalizadas y por otro lado una componente llamada Tarea que tenga por objetivo mostrar una tarea, poder indicar que ya ha sido realizada e informar a la componente padre cada vez que cambia el estado de la tarea.\n\n\nLa interfaz visual es similar a:\n\nPodemos probar esta aplicación también en la web aquí.\n\n\n\nCrearemos primero el proyecto\nng new proyecto040\n\n\n\nCreamos el modelo de dato que representa una tarea mediante una 'interface':\nng generate interface tarea\n\nSe nos crea el archivo 'tarea.ts' donde definimos la interface:\nexport interface Tarea {\n  id: number,\n  descripcion: string,\n  finalizada: boolean\n}\n\nPor cada tarea guardaremos su identificador, descripción y si la tarea fue finalizada.\n\n\n\nCrearemos ahora el servicio que nos va a permitir almacenar, recuperar y modificar las tareas en el localStorage del navegador:\nng generate service tareas\n\nProcedemos a crear la lógica del servicio:\ntareas.service.ts\nimport { Injectable } from '@angular/core';\nimport { Tarea } from './tarea';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class TareaService {\n  private localStorageKey = 'datostareas';\n\n  obtenerTareas(): Tarea[] {\n    const tareasStr = localStorage.getItem(this.localStorageKey);\n    return tareasStr ? JSON.parse(tareasStr) : [];\n  }\n\n  guardarTareas(tareas: Tarea[]): void {\n    localStorage.setItem(this.localStorageKey, JSON.stringify(tareas));\n  }\n\n  agregarTarea(nuevaTarea: Tarea): void {\n    const tareas = this.obtenerTareas();\n    tareas.push(nuevaTarea);\n    this.guardarTareas(tareas);\n  }\n\n  borrarTarea(tareaId: number): void {\n    const tareas = this.obtenerTareas().filter(tarea => tarea.id !== tareaId);\n    this.guardarTareas(tareas);\n  }\n}\n\n\n\n\n\nPasemos a crear ahora la componente \"Tarea\":\nng generate component tarea\n\nSe nos crea una carpeta con los 4 archivos que representan la componente, procedemos a modificar la clase propiamente dicha y la plantilla HTML.\ntarea.component.ts\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { Tarea } from '../tarea';\n@Component({\n  selector: 'app-tarea',\n  imports: [],\n  templateUrl: './tarea.component.html',\n  styleUrl: './tarea.component.css'\n})\nexport class TareaComponent {\n  @Input() tarea: Tarea = { id: 0, descripcion: '', finalizada: false };\n  @Output() borrarTarea: EventEmitter<number> = new EventEmitter<number>();\n  @Output() actualizarFinalizada: EventEmitter<Tarea> = new EventEmitter<Tarea>();\n\n  cambiarEstado() {\n    this.tarea.finalizada = !this.tarea.finalizada;\n    console.log(\" mi\")\n    this.actualizarFinalizada.emit(this.tarea);\n  }\n\n  borrar() {\n    this.borrarTarea.emit(this.tarea.id);\n  }\n}\n\n\n\nLa plantilla HTML para 'TareaComponent' es:\n<div>\n  <input type=\"checkbox\" [checked]=\"tarea.finalizada\" (change)=\"cambiarEstado()\">\n  {{ tarea.descripcion }}\n  <button (click)=\"borrar()\">Borrar</button>\n</div>\n\n\n\n\nPasemos a crear ahora la componente \"listatareas\":\nng generate component listatareas\n\nSe nos crea una carpeta con los 4 archivos que representan la componente, procedemos a modificar la clase propiamente dicha y la plantilla HTML.\nlistatareas.component.ts\nimport { Component } from '@angular/core';\nimport { Tarea } from '../tarea';\nimport { TareaComponent } from '../tarea/tarea.component';\nimport { FormsModule } from '@angular/forms';\nimport { TareaService } from '../tareas.service';\n\n@Component({\n  selector: 'app-listatareas',\n  imports: [TareaComponent, FormsModule],\n  templateUrl: './listatareas.component.html',\n  styleUrl: './listatareas.component.css'\n})\nexport class ListatareasComponent {\n  tareas: Tarea[] = [];\n\n  descripcionTarea: string = '';\n\n  constructor(private tareaService: TareaService) {\n    this.tareas = this.tareaService.obtenerTareas();\n  }\n\n  agregarTarea() {\n    let nuevaTarea: Tarea;\n    if (this.tareas.length == 0) {\n      nuevaTarea = { id: 1, descripcion: this.descripcionTarea, finalizada: false };\n    } else {\n      nuevaTarea = { id: this.tareas[this.tareas.length - 1].id + 1, descripcion: this.descripcionTarea, finalizada: false };\n    }\n    this.tareas.push(nuevaTarea);\n    this.tareaService.agregarTarea(nuevaTarea);\n    this.descripcionTarea = '';\n  }\n\n  borrarTarea(tareaId: number) {\n    this.tareas = this.tareas.filter(tarea => tarea.id !== tareaId);\n    this.tareaService.borrarTarea(tareaId);\n  }\n\n  actualizarFinalizada(tarea: Tarea) {\n    this.tareas = this.tareas.map(ta => ta.id === tarea.id ? tarea : ta)\n    this.tareaService.guardarTareas(this.tareas);\n  }\n\n  cantidadTareasCompletadas(): number {\n    return this.tareas.filter(tarea => tarea.finalizada).length;\n  }\n\n}\n\n\nLa plantilla HTML para 'ListatareasComponent' es:\n<div>\n  <h2>Lista de tareas.</h2>\n  @for(tarea of tareas; track tarea.id) {\n  <app-tarea [tarea]=\"tarea\" (borrarTarea)=\"borrarTarea($event)\"\n    (actualizarFinalizada)=\"actualizarFinalizada(tarea)\"></app-tarea>\n  }\n  <div>\n    <input [(ngModel)]=\"descripcionTarea\" placeholder=\"Ingrese nueva tarea\">\n    <button (click)=\"agregarTarea()\">Agregar tarea</button>\n  </div>\n</div>\n<div>\n  Cantidad de tareas completadas: {{ cantidadTareasCompletadas() }}\n</div>\n\n\n\nPor último debemos modificar la componente que crea Angular por defecto, donde agregaremos la lista de tareas:\nappcomponent.component.ts\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ListatareasComponent } from './listatareas/listatareas.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, ListatareasComponent],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n\n}\n\n\nLa plantilla HTML para 'AppComponent' es:\n<app-listatareas></app-listatareas>\n<router-outlet />\n\nIncluimos la componente ListatareasComponent en la plantilla HTML mediante la etiqueta app-listatareas que se encuentra definida en la propidad select del decorador de la clase 'ListatareasComponent'.\n\n\n\nAhora podemos ejecutar la aplicación:\nng serve -o\n\nPodemos ver el localStorage con los datos de las tareas registradas hasta ese momento:\n\nPodemos probar esta aplicación también en la web aquí."
  },
  {
    "title": "63 - TypeScript y Angular: decorador @Directive",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=63&codigo=63&inicio=60",
    "content": "En Angular hemos visto que el decorador @Directive se utiliza para definir una directiva personalizada. Las directivas son instrucciones que se aplican al DOM y pueden modificar su estructura, apariencia o comportamiento. A través del decorador @Directive, puedes crear tu propia directiva y luego usarla en los elementos del DOM dentro de tu aplicación Angular.\n\nProblema\nCrear una directiva que cambie dinámicamente el fondo de un elemento en función del tiempo actual del día. Llamaremos a esta directiva cambiarFondoSegunHora. La idea es que el fondo del elemento cambie de color dependiendo de si es de día, tarde o noche.\n\n\n\n\nCrearemos primero el proyecto\nng new proyecto041\n\n\n\nCreamos la directiva cambiarFondoSegunHora:\nng generate directive cambiarFondoSegunHora\n\nSe nos crea el archivo 'cambiar-fondo-segun-hora.directive.ts' donde codificamos:\nimport { Directive, ElementRef, Renderer2, OnInit } from '@angular/core';\n\n@Directive({\n  selector: '[appCambiarFondoSegunHora]'\n})\nexport class CambiarFondoSegunHoraDirective implements OnInit{\n  constructor(private el: ElementRef, private renderer: Renderer2) { }\n\n  ngOnInit() {\n    this.cambiarFondoSegunHora();\n  }\n\n  private cambiarFondoSegunHora() {\n    const horaActual = new Date().getHours();\n    let colorFondo = '';\n\n    if (horaActual >= 6 && horaActual < 12) {\n      colorFondo = 'yellow'; // Mañana\n    } else if (horaActual >= 12 && horaActual < 18) {\n      colorFondo = 'lightgray'; // Tarde\n    } else {\n      colorFondo = 'gray'; // Noche\n    }\n\n    this.renderer.setStyle(this.el.nativeElement, 'background-color', colorFondo);\n  }\n}\n\n@Directive({\n  selector: '[appCambiarFondoSegunHora]'\n})\n\n@Directive es un decorador que se utiliza para definir una directiva personalizada en Angular.\n  selector: '[appCambiarFondoSegunHora]',\n\nIndica que esta directiva se aplicará a elementos del DOM con el atributo appCambiarFondoSegunHora.\n  constructor(private el: ElementRef, private renderer: Renderer2) { }\n\nEn el constructor, se inyectan las instancias de ElementRef y Renderer2. ElementRef proporciona acceso al elemento del DOM al que se aplica la directiva, y Renderer2 permite manipular el DOM de manera segura.\n  ngOnInit() {\n    this.cambiarFondoSegunHora();\n  }\n\nEl método ngOnInit() se llama automáticamente después de que Angular haya inicializado la directiva. En este caso, se utiliza para llamar al método cambiarFondoSegunHora().\n  private cambiarFondoSegunHora() {\n    const horaActual = new Date().getHours();\n    let colorFondo = '';\n\n    if (horaActual >= 6 && horaActual < 12) {\n      colorFondo = 'yellow'; // Mañana\n    } else if (horaActual >= 12 && horaActual < 18) {\n      colorFondo = 'lightgray'; // Tarde\n    } else {\n      colorFondo = 'gray'; // Noche\n    }\n    this.renderer.setStyle(this.el.nativeElement, 'background-color', colorFondo);\n  }\n\nEl método privado cambiarFondoSegunHora() determina la hora actual y asigna un color de fondo según la hora del día. Luego, utiliza Renderer2 para establecer el estilo del fondo del elemento.\n\n\nAhora en la clase principal de la aplicación hacemos uso de esta directiva.\napp.component.ts\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { CambiarFondoSegunHoraDirective } from './cambiar-fondo-segun-hora.directive';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, CambiarFondoSegunHoraDirective],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n\n}\n\nY en la plantilla disponemos la directiva que hemos creado:\napp.component.html\n<div appCambiarFondoSegunHora>\n  Este fondo cambia según la hora del día.\n</div>\n<router-outlet />\n\n\nPodemos probar esta aplicación también en la web aquí."
  },
  {
    "title": "64 - TypeScript y Angular: decorador @Pipe",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=64&codigo=64&inicio=60",
    "content": "Vimos en conceptos anteriores que una pipe tiene por objetivo convertir un dato en la vista de la componente (html) con la finalidad que el usuario tenga una mejor experiencia, también vimos que el framework Angular provee un conjunto de pipes por defecto como pueden ser: uppercase, lowercase, json, date etc.\nEl decorador @Pipe aparece cuando tenemos que crear nuestras propias pipes que se adapten a resolver problemas de nuestra aplicación.\n\n\nProblema\nCrear una pipe que trunque un texto y agregue puntos suspensivos que da a entender que el texto ha sido truncado.\n\n\n\n\nCrearemos primero el proyecto\nng new proyecto042\n\n\n\nCreamos la tubería (pipe) :\nng generate pipe truncarTexto\n\nSe crean 2 archivos y pasamos a codificar nuestra pipe:\ntruncar-texto.pipe.ts\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'truncarTexto'\n})\nexport class TruncarTextoPipe implements PipeTransform {\n  transform(texto: string, longitudMaxima: number = 50): string {\n    if (texto.length <= longitudMaxima) {\n      return texto;\n    }\n\n    // Truncar el texto y agregar puntos suspensivos\n    const textoTruncado = texto.slice(0, longitudMaxima) + '...';\n    return textoTruncado;\n  }\n}\n\n\nLa tubería TruncarTextoPipe se utiliza para truncar un texto si supera una longitud máxima especificada.\nimport { Pipe, PipeTransform } from '@angular/core';\n\nImportamos las interfaces Pipe y PipeTransform del módulo '@angular/core'.\n@Pipe({\n  name: 'truncarTexto'\n})\n\nComo vemos utilizamos la función decoradora @Pipe y le pasamos como parámetro el nombre de nuestra tubería que haremos uso luego en una plantilla de una componente.\nexport class TruncarTextoPipe implements PipeTransform {\n  transform(texto: string, longitudMaxima: number = 50): string {\n    //lógica\n  }\n}\n\nLa clase TruncarTextoPipe implementa la interfaz PipeTransform, que requiere la implementación del método transform. Este método se ejecutará cuando la tubería sea utilizada en una plantilla y toma dos parámetros:\ntexto: El valor que se va a transformar (en este caso, un texto).\nlongitudMaxima: La longitud máxima permitida para el texto antes de truncarlo. Por defecto, se establece en 50 caracteres si no se proporciona otro valor.\n    if (texto.length <= longitudMaxima) {\n      return texto;\n    }\n\n    // Truncar el texto y agregar puntos suspensivos\n    const textoTruncado = texto.slice(0, longitudMaxima) + '...';\n    return textoTruncado;\n\nLa lógica del método verifica si la longitud del texto es menor o igual a la longitud máxima especificada. Si es así, el texto no se modifica y se devuelve tal cual. Si supera la longitud máxima, se trunca utilizando slice y se le añaden puntos suspensivos ('...') al final. El texto truncado es luego devuelto.\n\n\n\nEste fragmento de código es un componente Angular que utiliza una tubería personalizada (TruncarTextoPipe) y manipula la visualización de un poema en función de la interacción del usuario según la presión de un botón.\napp.component.ts\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { TruncarTextoPipe } from './truncar-texto.pipe';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, TruncarTextoPipe],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  poesia = `<p>En el abrazo eterno del horizonte,<br>\n  donde el cielo y el mar se entrelazan,<br>\n  navegan sueños en olas danzantes,<br>\n  poesía salada que el viento abraza.</p>\n\n  <p>Las gaviotas pintan líneas al viento,<br>\n  testigos de historias que el mar relata,<br>\n  susurran sus secretos en cada momento,<br>\n  mientras las olas cantan su serenata.</p>`\n\n  completo = false;\n  mensajeBoton = \"Ver\"\n\n  cambiar() {\n    this.completo = !this.completo;\n    this.mensajeBoton = this.completo ? \"Ocultar\" : \"Ver\"\n  }\n}\n\nimport { TruncarTextoPipe } from './truncar-texto.pipe';\n\nSe importa la clase TruncarTextoPipe.\n  imports: [RouterOutlet, TruncarTextoPipe],\n\nTambién debemos hacer referencia a la clase en la propiedad imports del decorador de la clase.\n\n  completo = false;\n\ncompleto: Un booleano que indica si se debe mostrar el poema completo o truncado.\n  mensajeBoton = \"Ver\"\n\nmensajeBoton: El mensaje que aparecerá en el botón para alternar entre la vista completa y la truncada.\n  cambiar() {\n    this.completo = !this.completo;\n    this.mensajeBoton = this.completo ? \"Ocultar\" : \"Ver\"\n  }\n\nUn método que se ejecuta cuando se hace clic en el botón. Cambia el valor de completo y actualiza el mensaje del botón en consecuencia.\n\n\nY en la plantilla disponemos la llamada a la pipe que hemos creado:\napp.component.html\n<h1>Poesia.</h1>\n@if (completo) {\n<div [innerHTML]=\"poesia\"></div>\n} @else {\n<div [innerHTML]=\"poesia|truncarTexto\"></div>\n}\n<button (click)=\"cambiar()\">{{mensajeBoton}}</button>\n<router-outlet />\n\n@if (completo) {\n<div [innerHTML]=\"poesia\"></div>\n}\n<router-outlet />\n\nSi la propiedad 'completo' almacena un true, luego se muestra la poesía en forma completa.\n[innerHTML]: Se utiliza para interpolar HTML dinámicamente, permitiendo que las etiquetas HTML en el contenido de poesia se interpreten correctamente.\n @else {\n<div [innerHTML]=\"poesia|truncarTexto\"></div>\n}\n\nPor el else mostramos solo los primeros 50 caracteres contenidos en la propiedad 'poesia'.\nSi queremos que se muestren solo los primeros 15 caracteres pasamos un parámetro a la pipe 'truncarTexto':\n<div [innerHTML]=\"poesia|truncarTexto:15\"></div>\n\nPodemos probar esta aplicación también en la web aquí."
  },
  {
    "title": "65 - Angular e instalación de Bootstrap original",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=65&codigo=65&inicio=60",
    "content": "Bootstrap es un framework de CSS que nos facilita y estandariza el desarrollo de sitios web.\nVeremos que hay varias maneras de utilizar el framework original de Bootstrap y en conceptos futuros veremos como instalar versiones de Bootstrap adaptadas directamente al ambiente de Angular.\nSi todavía no ha trabajado con Bootstrap puede visitar el curso de Bootstrap 5 Ya. \nDistintas formas de instalar Bootstrap 5 original.\nCrearemos un proyecto nuevo para probar las distintas maneras de acceder a Bootstrap 5 desde Angular:\nng new proyecto043\n\n\nLa forma más sencilla es utilizar un CDN donde se encuentre localizado los archivos *.css y *.js del framework de Bootstrap 5.\nDebemos modificar el archivo 'index.html' disponiendo los enlaces a los archivos respectivos y con eso ya tenemos acceso al framework de Bootstrap 5 en todo el proyecto:\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Proyecto043</title>\n  <base href=\"/\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n  <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN\" crossorigin=\"anonymous\">\n\n</head>\n<body>\n  <app-root></app-root>\n  <script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL\" crossorigin=\"anonymous\"></script>\n</body>\n</html>\n\nModifiquemos la componente (app.component.html) que se ha creado por defecto y hagamos uso de las clases definidas en la librería de Bootstrap 5:\n<div class=\"container\">\n  <h1 class=\"display-4\">Angular con Bootstrap</h1>\n  <p class=\"lead\">Bootstrap 5 es un framework de CSS que facilita y estandariza el desarrollo de sitios web.\n    Se ha implementado pensando en adaptarse tanto a las pantallas de equipos de escritorio como a móviles y tablets.</p>\n  <p>Bootstrap 5 ha sido desarrollado y es mantenido por la comunidad de código abierto.</p>\n\n  <button type=\"button\" class=\"btn btn-primary\" data-bs-toggle=\"modal\" data-bs-target=\"#dialogo1\">Información</button>\n\n  <div class=\"modal fade\" id=\"dialogo1\">\n    <div class=\"modal-dialog\">\n      <div class=\"modal-content\">\n        <div class=\"modal-header\">\n          <h5 class=\"modal-title\">Información</h5>\n          <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n        </div>\n        <!-- cuerpo del diálogo -->\n        <div class=\"modal-body\">\n          <a href=\"https://getbootstrap.com/\">Ingresar al sitio oficial</a><br>\n          <a href=\"https://tutorialesprogramacionya.com/bootstrap5ya\">Tutorial de Bootstrap</a>\n        </div>\n        <!-- pie del diálogo -->\n        <div class=\"modal-footer\">\n          <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Cerrar</button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n<router-outlet />\n\nSi ejecutamos la aplicación podemos ver que tenemos disponible la librería *.css de Bootstrap como también acceso a las funcionalidades de Javascript de Bootstrap en si mismo (de todos los elementos de Bootstrap que requieren Javascript):\n\n\n\n\n\n\nSi queremos tener los archivos de Bootstrap en nuestro servidor y no en un CDN tenemos como primer alternativa descargarlos y copiar los archivos a la carpetas 'js' y 'css' que debemos crear en la carpeta 'public', luego tenemos los archivos en forma local:\n\nSolo nos falta cambiar las url en el archivo 'index.html':\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Proyecto043</title>\n  <base href=\"/\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n  <link rel=\"stylesheet\" href=\"/css/bootstrap.min.css\">\n</head>\n<body>\n  <app-root></app-root>\n  <script src=\"/js/bootstrap.min.js\"></script>\n</body>\n</html>\n\nYa podemos ejecutar y tener el mismo resultado:\n\n\n\n\n\nLa tercer forma de instalar la última version de Bootstrap (actualmente la 5) es empleando el gestor de paquetes de Node.Js\nDesde la línea de comandos, en la carpeta raiz de nuestro proyecto procedemos a instalar el paquete:\nnpm install bootstrap --save\n\nLa opción --save hace que npm incluya el paquete dentro de la sección de dependencies del archivo package.json en forma automática, lo que evita que tengamos que escribirlo en forma manual.\n\nSi abrimos el archivo 'package.json' podemos ver que se han añadido las tres dependencias en nuestro proyecto:\n{\n  \"name\": \"proyecto043\",\n  \"version\": \"0.0.0\",\n  \"scripts\": {\n    \"ng\": \"ng\",\n    \"start\": \"ng serve\",\n    \"build\": \"ng build\",\n    \"watch\": \"ng build --watch --configuration development\",\n    \"test\": \"ng test\"\n  },\n  \"private\": true,\n  \"dependencies\": {\n    \"@angular/animations\": \"^19.0.0\",\n    \"@angular/common\": \"^19.0.0\",\n    \"@angular/compiler\": \"^19.0.0\",\n    \"@angular/core\": \"^19.0.0\",\n    \"@angular/forms\": \"^19.0.0\",\n    \"@angular/platform-browser\": \"^19.0.0\",\n    \"@angular/platform-browser-dynamic\": \"^19.0.0\",\n    \"@angular/router\": \"^19.0.0\",\n    \"bootstrap\": \"^5.3.3\",\n    \"rxjs\": \"~7.8.0\",\n    \"tslib\": \"^2.3.0\",\n    \"zone.js\": \"~0.15.0\"\n  },\n  \"devDependencies\": {\n    \"@angular-devkit/build-angular\": \"^19.0.2\",\n    \"@angular/cli\": \"^19.0.2\",\n    \"@angular/compiler-cli\": \"^19.0.0\",\n    \"@types/jasmine\": \"~5.1.0\",\n    \"jasmine-core\": \"~5.4.0\",\n    \"karma\": \"~6.4.0\",\n    \"karma-chrome-launcher\": \"~3.2.0\",\n    \"karma-coverage\": \"~2.2.0\",\n    \"karma-jasmine\": \"~5.1.0\",\n    \"karma-jasmine-html-reporter\": \"~2.1.0\",\n    \"typescript\": \"~5.6.2\"\n  }\n}\n\nComo último paso para poder utilizar Bootstrap en nuestro proyecto, debemos modificar el archivo 'angular.json' donde debemos especificar el path de los 2 archivos (en la propiedad 'build', en 'styles' indicamos el path donde se encuenta el archivo *.css y en 'script' el archivo respectivo):\n{\n  \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\",\n  \"version\": 1,\n  \"newProjectRoot\": \"projects\",\n  \"projects\": {\n    \"proyecto043\": {\n      \"projectType\": \"application\",\n      \"schematics\": {},\n      \"root\": \"\",\n      \"sourceRoot\": \"src\",\n      \"prefix\": \"app\",\n      \"architect\": {\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:application\",\n          \"options\": {\n            \"outputPath\": \"dist/proyecto043\",\n            \"index\": \"src/index.html\",\n            \"browser\": \"src/main.ts\",\n            \"polyfills\": [\n              \"zone.js\"\n            ],\n            \"tsConfig\": \"tsconfig.app.json\",\n            \"assets\": [\n              {\n                \"glob\": \"**/*\",\n                \"input\": \"public\"\n              }\n            ],\n            \"styles\": [\n              \"node_modules/bootstrap/dist/css/bootstrap.min.css\",\n              \"src/styles.css\"\n            ],\n            \"scripts\": [\n              \"node_modules/bootstrap/dist/js/bootstrap.min.js\"\n            ]\n          },\n          \"configurations\": {\n            \"production\": {\n              \"budgets\": [\n                {\n                  \"type\": \"initial\",\n                  \"maximumWarning\": \"500kB\",\n                  \"maximumError\": \"1MB\"\n                },\n                {\n                  \"type\": \"anyComponentStyle\",\n                  \"maximumWarning\": \"4kB\",\n                  \"maximumError\": \"8kB\"\n                }\n              ],\n              \"outputHashing\": \"all\"\n            },\n            \"development\": {\n              \"optimization\": false,\n              \"extractLicenses\": false,\n              \"sourceMap\": true\n            }\n          },\n          \"defaultConfiguration\": \"production\"\n        },\n        \"serve\": {\n          \"builder\": \"@angular-devkit/build-angular:dev-server\",\n          \"configurations\": {\n            \"production\": {\n              \"buildTarget\": \"proyecto043:build:production\"\n            },\n            \"development\": {\n              \"buildTarget\": \"proyecto043:build:development\"\n            }\n          },\n          \"defaultConfiguration\": \"development\"\n        },\n        \"extract-i18n\": {\n          \"builder\": \"@angular-devkit/build-angular:extract-i18n\"\n        },\n        \"test\": {\n          \"builder\": \"@angular-devkit/build-angular:karma\",\n          \"options\": {\n            \"polyfills\": [\n              \"zone.js\",\n              \"zone.js/testing\"\n            ],\n            \"tsConfig\": \"tsconfig.spec.json\",\n            \"assets\": [\n              {\n                \"glob\": \"**/*\",\n                \"input\": \"public\"\n              }\n            ],\n            \"styles\": [\n              \"src/styles.css\"\n            ],\n            \"scripts\": []\n          }\n        }\n      }\n    }\n  }\n}\n\nCon este método no debemos modificar nada el archivo 'index.html':\n<!doctype html>\n<html lang=\"es\">\n\n<head>\n  <meta charset=\"utf-8\">\n  <title>Proyecto043</title>\n  <base href=\"/\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n</head>\n\n<body>\n  <app-root></app-root>\n</body>\n\n</html>\n\n\n\n\nHemos presentado en este concepto las tres formas de integrar el Bootstrap original dentro de un proyecto Angular, el empleo de uno u otro depende de nuestra decisión. Veremos en los próximos conceptos algunos ejercicios empleando Angular y Bootstrap original."
  },
  {
    "title": "66 - Angular y Bootstrap - creación de una componente: barrademenu",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=66&codigo=66&inicio=60",
    "content": "Como hemos tratado en todo el curso el corazón de Angular es dividir una aplicación en componentes y luego hacer que las mismas interactuen entre ellas, lograr crear componentes reutilizables y fáciles de mantener.\nEn este concepto y los próximos realizaremos una serie de componentes para practicar el desarrollo de componentes y utilizaremos en las mismas las herramientas que nos facilitan Bootstrap para las interfaces visuales.\nCreación de una componente de menu de barra.\nCrear una componente llamada MenudebarraComponent y cuyo selector debe llamarse 'boot-menudebarra'.\nMediante 'property binding' se se debe poder comunicar un arreglo con las etiquetas que debe mostrar el menú, una segunda propiedad debe poder cargarse para indicar el color de fondo de la barra, los colores deben ser alguno de los valores clásicos propuestos por Bootstrap (bg-primary, bg-secondary, bg-success, bg-danger, bg-warning, bg-info, bg-light, bg-dark, bg-white)\nPor otro lado desde la componente 'barrademenu' debe disparar un evento cuando el usuario selecciona una opción del menú.\n\n\n\nCrearemos primero el proyecto\nng new proyecto044\n\n\n\n\nInstalamos el Bootstrap original con alguna de las tres formas vistas en el concepto anterior, mediante CDN o localizándolo en la capeta 'public' o mediante npm.\n\n\n\n\n\nCrearemos la componente de barra de menú e indicamos como prefijo para la nueva etiqueta la cadena 'boot' (la idea es recordarnos que esta componente utiliza la librería de Bootstrap):\nng generate component barrademenu --prefix boot\n\n\n\n\n\nModificamos el archivo 'barrademenu.component.ts':\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'boot-barrademenu',\n  imports: [],\n  templateUrl: './barrademenu.component.html',\n  styleUrl: './barrademenu.component.css'\n})\nexport class BarrademenuComponent {\n  @Input() opciones!: string[];\n  @Input() colorfondo!: string;\n  @Output() presionopcion = new EventEmitter();\n\n  presion(i: number): void {\n    this.presionopcion.emit(i);\n  }\n}\n\nDefinimos las dos propiedades que llegan datos a las componentes mediante el decorador @Input:\n  @Input() opciones!: string[];\n  @Input() colorfondo!: string;\n\nPara definir el evento que dispara la componente:\n  @Output() presionopcion = new EventEmitter();\n\nEl método 'presion' se ejecuta cuando alguna de las opciones del menú de barra es presionada (informa a la componente padre el número de opción presionada):\n  presion(i: number): void {\n    this.presionopcion.emit(i);\n  }\n\n\n\n\n\nModificamos el archivo 'barrademenu.component.html':\n<nav class=\"navbar navbar-expand-sm navbar-dark {{colorfondo}}\">\n  <ul class=\"navbar-nav\">\n    @for(opcion of opciones; track $index) {\n    <li class=\"nav-item\">\n      <a class=\"nav-link\" href=\"#\" (click)=\"presion($index+1)\">{{opcion}}</a>\n    </li>\n    }\n  </ul>\n</nav>\n\nUtilizamos clases propias de Bootstrap para definir el color de fondo que se remplaza mediante interpolación\n<nav class=\"navbar navbar-expand-sm navbar-dark {{colorfondo}}\">\n\nMediante un @for generamos todas las etiquetas 'li' con una etiqueta 'a' en su interior que muestra la opción y enlaza el evento 'click' pasando el número de opción seleccionada:\n    @for(opcion of opciones; track $index) {\n    <li class=\"nav-item\">\n      <a class=\"nav-link\" href=\"#\" (click)=\"presion($index+1)\">{{opcion}}</a>\n    </li>\n    }\n\n\n\n\nAhora nos queda consumir la componente 'boot-barrademenu', esto lo haremos desde la componente principal de nuestra aplicación Angular.\nModificamos el archivo 'app.component.html':\n<div class=\"container\">\n  <boot-barrademenu [opciones]=\"opciones\" colorfondo=\"bg-info\" (presionopcion)=\"presion($event)\"></boot-barrademenu>\n</div>\n<router-outlet />\n\nMediante enlace de propiedades enlazamos el arreglo a pasar a la propiedad 'opciones' de la componente:\n[opciones]=\"opciones\"\n\nPara la propiedad 'colorfondo' directamente pasamos el string del color que queremos que aparezca la barra de menú:\ncolorfondo=\"bg-info\"\n\nFinalmente enlazamos el evento que dispara la componente 'presionopcion':\n(presionopcion)=\"presion($event)\n\n\n\n\nModificamos el archivo 'appcomponent.component.ts':\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { BarrademenuComponent } from './barrademenu/barrademenu.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, BarrademenuComponent],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  opciones = [\n    \"Opcion 1\", \"Opcion 2\", \"Opcion 3\", \"Opcion 4\", \"Opcion 5\"\n  ];\n\n  presion(op: number) {\n    alert(\"Se informa que se presiono la opcion \" + op);\n  }\n}\n\nDefinimos el arreglo con las opciones que tendrá la barra de menú:\n  opciones = [\n    \"Opcion 1\", \"Opcion 2\", \"Opcion 3\", \"Opcion 4\", \"Opcion 5\"\n  ];\n\nDefinimos el método que recibe el número de opción seleccionado de la barra de menú:\n  presion(op: number) {\n    alert(\"Se informa que se presiono la opcion \" + op);\n  }\n\n\n\n\n\nAhora ejecutemos la aplicación:\nng serve -o\n\nTenemos como resultado:\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "67 - Angular y Bootstrap - creación de una componente: alerta",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=67&codigo=67&inicio=60",
    "content": "Creación de una componente de cuadro de alerta.\nCrear una componente llamada AlertaComponent y cuyo selector debe llamarse 'boot-alerta'.\nMediante dos propiedades se deben poder cargar el color y el mensaje que muestra el cuadro de alerta.Los colores pueden ser alguno de los valores clásicos propuestos por Bootstrap (alert-primary, alert-secondary, alert-success, alert-danger, alert-warning, alert-info, alert-light, alert-dark, alert-white)\nProbar la componente creada desde la componente principal de la aplicación.\n\n\n\nCrearemos primero el proyecto\nng new proyecto045\n\n\n\n\nInstalamos el Bootstrap original con alguna de las tres formas vistas en conceptos anteriores, mediante CDN o localizándolo en la capeta 'public' o mediante npm.\n\n\n\n\n\nCrearemos la componente de alerta e indicamos como prefijo para la nueva etiqueta la cadena 'boot' (la idea es recordarnos que esta componente utiliza la librería de Bootstrap):\nng generate component alerta --prefix boot\n\n\n\n\n\nModificamos el archivo 'alerta.component.ts':\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'boot-alerta',\n  imports: [],\n  templateUrl: './alerta.component.html',\n  styleUrl: './alerta.component.css'\n})\nexport class AlertaComponent {\n  @Input() color!: string;\n  @Input() mensaje!: string;\n}\n\n\nDefinimos las dos propiedades que se inicializan con el color y el mensaje que debe mostrar la componente:\n  @Input() color!: string;\n  @Input() mensaje!: string;\n\n\n\n\n\nModificamos el archivo 'alerta.component.html':\n<div class=\"alert {{color}} alert-dismissible fade show\" role=\"alert\">\n  {{mensaje}}\n  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\" aria-label=\"Close\">\n  </button>\n</div>\n\nUtilizamos clases propias de Bootstrap para definir el color\n<div class=\"alert {{color}} alert-dismissible fade show\" role=\"alert\">\n\nPor otro lado mediante interpolación se muestra el contenido de la propiedad 'mensaje'.\n\n\n\nAhora nos queda consumir la componente 'boot-alerta', esto lo haremos desde la componente principal de nuestra aplicación Angular.\nModificamos el archivo 'app.component.html':\n<div class=\"container\">\n  <boot-alerta mensaje=\"Recuerde que las facturas vencen el 10 de cada mes\" color=\"alert-warning\"></boot-alerta>\n</div>\n<router-outlet />\n\n\n\n\n\nEn el archivo 'app.component.ts' importamos la componente:\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { AlertaComponent } from './alerta/alerta.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, AlertaComponent],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'proyecto045';\n}\n\n\n\n\nAhora ejecutemos la aplicación:\nng serve -o\n\nTenemos como resultado:\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "68 - Angular y Bootstrap - creación de una componente: tabla",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=68&codigo=68&inicio=60",
    "content": "Creación de una componente de tabla de datos.\nCrear una componente llamada TablaComponent y cuyo selector debe llamarse 'boot-tabla'.\nMediante una propiedad de tipo matriz de string poder pasar los datos que se deben mostrar en una tabla HTML. La primer fila de la matriz representa los títulos.\n\n\n\nCrearemos primero el proyecto\nng new proyecto046\n\n\n\n\nInstalamos el Bootstrap original con alguna de las tres formas vistas en conceptos anteriores, mediante CDN o localizándolo en la capeta 'public' o mediante npm.\n\n\n\n\nCrearemos la componente de tabla e indicamos como prefijo para la nueva etiqueta la cadena 'boot' (la idea es recordarnos que esta componente utiliza la librería de Bootstrap):\nng generate component tabla --prefix boot\n\n\n\n\n\nModificamos el archivo 'tabla.component.ts':\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'boot-tabla',\n  imports: [],\n  templateUrl: './tabla.component.html',\n  styleUrl: './tabla.component.css'\n})\nexport class TablaComponent {\n  @Input() datos: String[][]=[];\n}\n\n\n\n\n\n\nModificamos el archivo 'tabla.component.html':\n<table class=\"table table-striped table-bordered\">\n  <thead>\n    <tr>\n      @for(titulo of datos[0]; track $index) {\n      <th> {{ titulo }} </th>\n      }\n    </tr>\n  </thead>\n  <tbody>\n    @for(fila of datos.slice(1); track fila) {\n    <tr>\n      @for(celda of fila;track celda) {\n      <td>{{ celda }}</td>\n      }\n    </tr>\n    }\n  </tbody>\n</table>\n\n\n\n\n\nAhora nos queda consumir la componente 'boot-tabla', esto lo haremos desde la componente principal de nuestra aplicación Angular.\nModificamos el archivo 'app.component.ts':\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { TablaComponent } from './tabla/tabla.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, TablaComponent],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  da: string[][] = [\n    [\"Artículo\", \"Descripción\", \"Precio\",\"Stock\"],\n    [\"Artículo 1\", \"Descripción 1\", \"$10.00\",\"30\"],\n    [\"Artículo 2\", \"Descripción 2\", \"$20.00\",\"33\"],\n    [\"Artículo 3\", \"Descripción 3\", \"$15.00\",\"72\"],\n    [\"Artículo 4\", \"Descripción 4\", \"$25.00\",\"91\"],\n    [\"Artículo 5\", \"Descripción 5\", \"$30.00\",\"172\"]\n  ];\n}\n\n\n\n\n\nModificamos el archivo 'app.component.html':\n<boot-tabla [datos]=\"da\"></boot-tabla>\n<router-outlet />\n\n\n\n\nAhora ejecutemos la aplicación:\nng serve -o\n\nTenemos como resultado:\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "69 - Angular y Bootstrap - creación de una componente: tarjeta",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=69&codigo=69&inicio=60",
    "content": "Vamos a desarrollar una última componente haciendo uso del framework de Bootstrap original, para ver como integrarlo a Angular. Con esto podemos luego crear componentes visuales similares a las que propone Bootstrap pero con las funcionalidades de Angular.\n\n\nCreación de una componente llamada tarjeta.\nCrear una componente llamada TarjetaComponent y cuyo selector debe llamarse 'boot-tarjeta'.\nDefinir una interface llamada 'Tarjeta' que tenga como atributos la url de una imagen, el nombre de la persona y su mail.\n\n\n\nCrearemos primero el proyecto\nng new proyecto047\n\n\n\n\nInstalamos el Bootstrap original con alguna de las tres formas vistas en conceptos anteriores, mediante CDN o localizandolo en la capeta 'public' o mediante npm.\n\n\n\nCrearemos la interface tarjeta:\nng generate interface tarjeta\n\nY luego la codificamos:\nexport interface Tarjeta {\n  nombre: string,\n  mail: string,\n  foto: string\n}\n\n\n\n\nCrearemos la componente 'tarjeta' e indicamos como prefijo para la nueva etiqueta la cadena 'boot' (la idea es recordarnos que esta componente utiliza la librería de Bootstrap):\nng generate component tarjeta --prefix boot\n\n\n\n\n\nModificamos el archivo 'tarjeta.component.ts':\nimport { Component, Input } from '@angular/core';\nimport { Tarjeta } from '../tarjeta';\n@Component({\n  selector: 'boot-tarjeta',\n  imports: [],\n  templateUrl: './tarjeta.component.html',\n  styleUrl: './tarjeta.component.css'\n})\nexport class TarjetaComponent {\n  @Input() datos: Tarjeta = { nombre: '', mail: '', foto: '' };\n}\n\n\n\n\n\n\nModificamos el archivo 'tarjeta.component.html':\n<div class=\"card\" style=\"width: 18rem;margin:1rem\">\n  <img src=\"{{datos.foto}}\" class=\"card-img-top\" alt=\"...\">\n  <div class=\"card-body\">\n    <h5 class=\"card-title\">{{datos.nombre}}</h5>\n    <p class=\"card-text\">\n      {{datos.mail}}\n    </p>\n  </div>\n</div>\n\n\n\n\n\nAhora nos queda consumir la componente 'boot-tarjeta', esto lo haremos desde la componente principal de nuestra aplicación Angular.\nModificamos el archivo 'app.component.ts':\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { TarjetaComponent } from './tarjeta/tarjeta.component';\nimport { Tarjeta } from './tarjeta';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, TarjetaComponent],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  tarjeta:Tarjeta={nombre:'Juan Pablo',mail:'juanpablo@gmail.com',foto:'https://www.ejerciciostutorialesya.com/angular/fotos/persona1.jpg'};\n}\n\n\n\n\n\nModificamos el archivo 'app.component.html':\n<boot-tarjeta [datos]=\"tarjeta\"></boot-tarjeta>\n<router-outlet />\n\n\n\n\nAhora ejecutemos la aplicación:\nng serve -o\n\nTenemos como resultado:\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "70 - Consumir una API pública utilizando una interface para definir su estructura y la clase HttpClient",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=70&codigo=70&inicio=60",
    "content": "Ya hemos visto en conceptos anteriores como podemos solicitar información a un servidor utilizando la clase HttpClient, pero no habíamos visto hasta ese momento la declaración de interfaces.\nLa declaración de la interface nos permite en tiempo de diseño identificar errores sobre nombre de atributos en los objetos.\nProblema\nLa siguiente URL retorna un archivo JSON con los datos de distintos países:\nhttps://www.ejerciciostutorialesya.com/cursojs/recuperarpaises.php\n\nComo resultado tenemos un archivo similar a:\n[\n  {\n    \"nombre\": \"Argentina\",\n    \"capital\": \"Buenos Aires\",\n    \"idioma\": \"español\",\n    \"moneda\": \"peso\",\n    \"poblacion\": 40000000,\n    \"bandera\": \"https://www.ejerciciostutorialesya.com/cursojs/imagenes/argentina.png\",\n    \"limites\": [\"Chile\", \"Brasil\", \"Uruguay\",\"Bolivia\"]\n  },\n  {\n    \"nombre\": \"Brasil\",\n    \"capital\": \"Brasilia\",\n    \"idioma\": \"portugués\",\n    \"moneda\": \"real\",\n    \"poblacion\": 200000000,\n    \"bandera\": \"https://www.ejerciciostutorialesya.com/cursojs/imagenes/brasil.png\",\n    \"limites\": [\"Argentina\", \"Chile\", \"Paraguay\",\"Uruguay\",\"Colombia\",\"Venezuela\",\"Bolivia\",\"Peru\",\"Ecuador\",\"Guayana Francesa\",\"Surinam\",\"Guyana\"]\n  },\n  {\n    \"nombre\": \"Chile\",\n    \"capital\": \"Santiago\",\n    \"idioma\": \"español\",\n    \"moneda\": \"peso\",\n    \"poblacion\": 18000000,\n    \"bandera\": \"https://www.ejerciciostutorialesya.com/cursojs/imagenes/chile.png\",\n    \"limites\": [\"Argentina\",\"Bolivia\",\"Peru\"]\n  }\n]\n\nConfeccionar una aplicación en Angular que recupere los datos del servidor y los muestre en una tabla HTML.\nVamos a codificar cada uno de los pasos para resolver el problema propuesto.\n\nEl resultado final debe ser similar a:\n\n\nPodemos probar esta aplicación en la web aquí.\n\n\nCrearemos primero el proyecto\nng new proyecto048\n\n\n\n\nDebemos modificar el archivo 'app.config.ts' para poder hacer consultas a un servidor:\nimport { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';\nimport { provideRouter } from '@angular/router';\n\nimport { routes } from './app.routes';\nimport { provideHttpClient } from '@angular/common/http';\nimport { withFetch } from '@angular/common/http';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes), provideHttpClient(withFetch())]\n};\n\n\n\n\nCreamos la interface con la estructura del archivo JSON:\nng generate interface Pais\n\nDeclaramos la estructura de la interface:\nexport interface Pais {\n  nombre: string,\n  capital: string,\n  idioma: string,\n  moneda: string,\n  poblacion: number,\n  bandera: string,\n  limites: string[]\n}\n\nComo podemos ver los objetos contenidos del archivo JSON quedan mapeados con los nombres de las propiedades y sus tipos de datos. nombre es de tipo string, poblacion es numeric, limites es un array de string etc.\n\n\n\nPasamos a crear ahora el servicio que va a emplear la clase HttpClient para comunicarse con el servidor y proceder a recuperar los datos en forma asíncrona:\nng generate service paises\n\nEl código a implementar en el servicio es:\nimport { Injectable } from '@angular/core';\nimport { Pais } from './pais';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class PaisesService {\n  private urlApi = \"https://www.ejerciciostutorialesya.com/cursojs/recuperarpaises.php\"\n\n  constructor(private http: HttpClient) { }\n\n  retornar() {\n    return this.http.get<Pais[]>(this.urlApi);\n  }\n}\n\nimport { HttpClient } from '@angular/common/http';\n\nRecordemos que la clase HttpClient es un servicio proporcionado por Angular para hacer solicitudes HTTP.\nimport { Pais } from './pais';\n\nEs la interfaz que define la estructura de un objeto \"Pais\".\n  constructor(private http: HttpClient) { }\n\nAl constructor se inyecta el servicio HttpClient.\n  retornar() {\n    return this.http.get<Pais[]>(this.urlApi);\n  }\n\nEste método utiliza el servicio HttpClient para realizar una solicitud GET a la URL especificada (this.urlApi).\nEl método devuelve un objeto de la clase Observable de tipo Pais[] (el próximo concepto ahondaremos el concepto de Observable). La notación  indica que se espera una respuesta que sea un array de objetos que coincidan con la interfaz Pais.\nEste método se utilizará en una componente donde se listarán los paises recuperados.\n\n\n\n\nCreamos la componente donde se mostrarán en una tabla HTML los paises:\nng generate component ListadoPaises\n\n\n\nCodificamos la clase 'ListadoPaisesComponent' contenida en el archivo 'listado-paises.component.ts'\nimport { Component } from '@angular/core';\nimport { PaisesService } from '../paises.service';\nimport { Pais } from '../pais';\n\n@Component({\n  selector: 'app-listado-paises',\n  imports: [],\n  templateUrl: './listado-paises.component.html',\n  styleUrl: './listado-paises.component.css'\n})\nexport class ListadoPaisesComponent {\n  paises: Pais[] = [];\n\n  constructor(private paisesService: PaisesService) {\n    this.recuperar()\n  }\n\n  recuperar() {\n    this.paisesService.retornar().subscribe((paises: Pais[]) => {\n      this.paises = paises\n    });\n  }\n\n}\n\n  paises: Pais[] = [];\n\nDefinimos un arreglo inicialmente vacío, que almacenará los datos recuperados del servidor.\n  constructor(private paisesService: PaisesService) {\n    this.recuperar()\n  }\n\nEl constructor del componente recibe el servicio PaisesService como una dependencia e invoca el método recuperar automáticamente.\n  recuperar() {\n    this.paisesService.retornar().subscribe((paises: Pais[]) => {\n      this.paises = paises\n    });\n  }\n\nEl método recuperar utiliza el servicio PaisesService para recuperar la lista de países. Utiliza el método retornar() del servicio, que devuelve un observable (a partir del próximo concepto veremos en profundidad la clase Observable). El componente se suscribe al observable y actualiza la propiedad paises cuando se recibe la respuesta.\n\n\n\n\n\nCodificamos la clase la plantilla HTML 'listado-paises.component.html'\n<table>\n  <thead>\n    <tr>\n      <th>Nombre</th>\n      <th>Capita</th>\n      <th>Idioma</th>\n      <th>Moneda</th>\n      <th>Poblacion</th>\n      <th>Paises limitrofes</th>\n      <th>Bandera</th>\n    </tr>\n  </thead>\n  <tbody>\n    @for(pais of paises;track pais.nombre) {\n    <tr>\n      <td>{{pais.nombre}}</td>\n      <td>{{pais.capital}}</td>\n      <td>{{pais.idioma}}</td>\n      <td>{{pais.moneda}}</td>\n      <td>{{pais.poblacion}}</td>\n      <td>\n        @for(limite of pais.limites;track limite) {\n        {{limite}}<br>\n        }\n      </td>\n      <td><img src=\"{{pais.bandera}}\" alt=\"pais.nombre\"></td>\n    </tr>\n    }\n  </tbody>\n</table>\n\n\n\n\nCodificamos la hoja de estilo 'listado-paises.component.css'\ntable {\n  width: 100%;\n  border-collapse: collapse;\n  margin-bottom: 20px;\n}\n\nth, td {\n  border: 1px solid #dddddd;\n  padding: 8px;\n  text-align: left;\n}\n\ntr:nth-child(even) {\n  background-color: #f2f2f2;\n}\n\nth {\n  background-color: #4CAF50;\n  color: white;\n}\n\n\n\n\n\n\nAhora modificamos la componente principal que crea Angular por defecto 'app.component.ts'\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { ListadoPaisesComponent } from './listado-paises/listado-paises.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, ListadoPaisesComponent],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n}\n\n\n\n\nFinalmente modificamos la plantilla HTML de la componente principal que crea Angular por defecto 'app.component.html'\n<app-listado-paises></app-listado-paises>\n<router-outlet />\n\n\n\n\nYa podemos probar nuestra aplicación en forma local:\nng serve -o\n\n\nTenemos como resultado:\n\n\nPodemos probar esta aplicación en la web aquí."
  },
  {
    "title": "71 - Que utilizar en Angular: Promise u Observable",
    "url": "https://www.tutorialesprogramacionya.com/angulardevya/detalleconcepto.php?punto=71&codigo=71&inicio=60",
    "content": "En Angular, tanto las promesas (Promise) como los observables (Observable) se utilizan para manejar operaciones asíncronas, pero tienen diferencias clave en su implementación y funcionalidad.\n\nSimilitudes entre Promesas y Observables:\n\n\nManejo de operaciones asíncronas: Ambas promesas y observables son utilizados para manejar operaciones asíncronas en Angular, permitiendo que el código no se bloquee mientras espera la finalización de una operación.\n\n\nManejo de errores: Tanto las promesas como los observables proporcionan mecanismos para manejar errores.\n\n\n\n\nDiferencias entre Promesas y Observables:\n\n\nPromesas: Representan un único valor que será resuelto o rechazado.\nObservables: Pueden representar una secuencia de valores que se emiten a lo largo del tiempo, permitiendo la transmisión de múltiples valores.\n\n\nPromesas: Una promesa no se puede cancelar.\nObservables: Son cancelables, lo que significa que puedes cancelar una suscripción antes de que se complete la operación asíncrona.\n\n\nPromesas: Son más simples y adecuadas para operaciones asíncronas únicas.\nObservables: Son más potentes y flexibles, especialmente cuando se trata de manejar secuencias de eventos a lo largo del tiempo. Son preferidos en situaciones más complejas y en el desarrollo de aplicaciones reactivas.\n\n\n\n\nAPI Angular\n\nLa mayor parte de las librerías propuestas en angular utilizan por defecto los observables, se utilizan en servicios como HTTP, formularios reactivos, eventos del DOM, etc.\nEn resumen, mientras que las promesas son más simples y adecuadas para casos de uso más básicos, los observables proporcionan una funcionalidad más avanzada y son la elección preferida en el ecosistema Angular, especialmente en situaciones más complejas y en el desarrollo de aplicaciones más reactivas.\n\n\nProblema\nVamos a desarrollar una aplicación que resuelva el mismo problema utilizando la clase Promise y la clase Observable.\nDesarrollar una aplicación que permita al usuario seleccionar un archivo con formato HTML de su equipo y posteriormente muestre su contenido en la página. Resolver la actividad de la lectura en una Promise y luego con un Observable, utilizando la clase FileReader para la lectura del archivo. Debe realizar la lectura del archivo con formato HTML y si dicho archivo no tiene extensión HTML debe rechazar su lectura.\n\n\n\nCrearemos primero el proyecto\nng new proyecto049\n\n\n\n\nCrear ahora el servicio donde vamos a hacer la lectura del archivo en forma asíncrona, empleando tanto promesas como observables:\nng generate service archivo\n\nEl código a implementar en el servicio es:\nimport { Injectable } from '@angular/core';\nimport { Observable, Observer } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ArchivoService {\n\n  constructor() { }\n\n  recuperarConPromesa(file: File) {\n    return new Promise<string>((resolve, reject) => {\n      if (!file.name.endsWith(\".html\")) {\n        reject(\"Extensión de archivo incorrecta\")\n      } else {\n        const fileReader1 = new FileReader()\n        fileReader1.readAsText(file)\n        fileReader1.addEventListener(\"load\", () => {\n          resolve(fileReader1.result!.toString())\n        })\n      }\n    })\n  }\n\n  recuperarConObservable(file: File): Observable<string> {\n    return new Observable((observer: Observer<string>) => {\n      if (!file.name.endsWith(\".html\")) {\n        observer.error(\"Extensión de archivo incorrecta\");\n      } else {\n        const fileReader = new FileReader();\n        fileReader.readAsText(file);\n\n        fileReader.addEventListener(\"load\", () => {\n          observer.next(fileReader.result!.toString());\n          observer.complete();\n        });\n      }\n    });\n  }\n}\n\nEl método 'recuperarConPromesa' recibe un objeto File como parámetro, que se obtiene al seleccionar un archivo a través de un formulario en HTML.\nVerifica si la extensión del archivo es \".html\". Si no lo es, rechaza la promesa con un mensaje de error.\nSi la extensión del archivo es correcta, crea un objeto FileReader y utiliza su método readAsText para leer el contenido del archivo como texto.\nSe añade un evento \"load\" al FileReader, que se dispara cuando la operación de lectura es exitosa. En ese caso, se resuelve la promesa con el resultado.\n\nEl método 'recuperarConObservable' también toma un objeto File como parámetro. Al igual que en el método de promesa, verifica si la extensión del archivo es \".html\". Si no lo es, emite un error a través del objeto Observer.\nSi la extensión del archivo es correcta, crea un objeto FileReader y utiliza su método readAsText para leer el contenido del archivo como texto. Se añade un evento \"load\" al FileReader, que se dispara cuando la operación de lectura es exitosa. En ese caso, emite el resultado (el contenido del archivo convertido a cadena) a través de observer.next().\nFinalmente, completa el observable con observer.complete(), indicando que la secuencia ha terminado.\n\n\n\nModificamos la componente creada por defecto por Angular.\napp.component.ts\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\nimport { FormsModule } from '@angular/forms';\nimport { ArchivoService } from './archivo.service';\n\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, FormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  nombreArchivo = '';\n  resultado: any;\n\n  constructor(private archi: ArchivoService) { }\n\n  async recuperarConPromise(event: any) {\n    try {\n      this.resultado = await this.archi.recuperarConPromesa(event.target.files[0]);\n    } catch (error) {\n      this.resultado = error\n    }\n  }\n\n  recuperarConObservable(event: any) {\n    this.archi.recuperarConObservable(event.target.files[0]).subscribe({\n      next: (resultado) => {\n        this.resultado = resultado;\n      },\n      error: (error) => {\n        this.resultado = error;\n      }\n    });\n  }\n\n}\n\nnombreArchivo: Variable que almacena el nombre del archivo seleccionado.\nresultado: Variable que almacena el resultado de la operación de recuperación de archivos.\nEl constructor recibe una instancia de ArchivoService a través de la inyección de dependencias.\n\nEl método recuperarConPromise: Método asincrónico que utiliza await para esperar a que la promesa retornada por recuperarConPromesa se resuelva. Actualiza this.resultado con el resultado de la operación o un mensaje de error si la promesa es rechazada.\nEl método recuperarConObservable: utiliza la función subscribe para suscribirse a un observable retornado por recuperarConObservable.\nEl objeto pasado a subscribe define dos funciones de devolución de llamada: next para manejar el próximo valor emitido por el observable y error para manejar el error.\n\n\n\n\nLa plantilla HTML de la componente también la modificamos.\napp.component.html\n<div>\n  <label for=\"archivohtml\">Seleccione el archivo HTML:</label>\n  <ul>\n    <li>\n      Con Promise:<input type=\"file\" [(ngModel)]=\"nombreArchivo\" (change)=\"recuperarConPromise($event)\">\n    </li>\n    <li>\n      Con Observable<input type=\"file\" [(ngModel)]=\"nombreArchivo\" (change)=\"recuperarConObservable($event)\">\n    </li>\n  </ul>\n</div>\n<p>Contenido</p>\n<pre>{{resultado}}</pre>\n<router-outlet />\n\n\nLa salida por pantalla luego de seleccionar un archivo HTML debe ser similar a:\n\n\nPodemos probar esta aplicación en la web aquí."
  }
]
